<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python学习笔记-01Python基础]]></title>
      <url>http://2wildkids.com/2016/10/21/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01Python%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#数据类型和变量">数据类型和变量</a><ul>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#常量">常量</a></li>
</ul>
</li>
<li><a href="#使用list和tuple">使用list和tuple</a><ul>
<li><a href="#list">list</a></li>
<li><a href="#tuple">tuple</a></li>
</ul>
</li>
<li><a href="#使用dict和set">使用dict和set</a><ul>
<li><a href="#dict">dict</a></li>
<li><a href="#set">set</a></li>
<li><a href="#再议不可变对象">再议不可变对象</a></li>
</ul>
</li>
<li><a href="#条件判断">条件判断</a><ul>
<li><a href="#条件判断-1">条件判断</a></li>
<li><a href="#再议input">再议input</a></li>
<li><a href="#循环">循环</a></li>
</ul>
</li>
<li><a href="#字符串和编码">字符串和编码</a><ul>
<li><a href="#字符编码">字符编码</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#格式化">格式化</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python可以直接表达的数据类型包括：整数，浮点数，复数，字符串，布尔值和空值。</p>
<h5 id="整数-int"><a href="#整数-int" class="headerlink" title="整数 int"></a>整数 int</h5><p>任意大小，正负皆可。并且可以用0b、0o、0x分别表示二进制、八进制和十六进制数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0b10</span> <span class="comment"># 也可以是 0B10</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0o10</span> <span class="comment"># 也可以是 0O10</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0x10</span> <span class="comment"># 也可以是 0X10</span></div><div class="line"><span class="number">16</span></div><div class="line"></div><div class="line"><span class="comment"># 十进制转其他进制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">2</span>)</div><div class="line"><span class="string">'0b10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">8</span>)</div><div class="line"><span class="string">'0o10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">16</span>)</div><div class="line"><span class="string">'0x10'</span></div><div class="line"></div><div class="line"><span class="comment"># 其他进制转十进制（也可将字符串转换为十进制）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0b10</span>) <span class="comment"># 也可以是 int('10', 2)</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0o10</span>) <span class="comment"># 也可以是 int('10', 8)</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0x10</span>) <span class="comment"># 也可以是 int('10', 16)</span></div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>除了普通的写法之外，也可使<strong>用科学记数法</strong>，即1.23x10^9就是1.23e9 ，0.000012可以写成1.2e-5，等等。</p>
<p><strong>整数运算永远是精确的(结果也是整数)，浮点数运算则有四舍五入的误差</strong>。</p>
<p>Python提供两种除法+求余运算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><code>/</code></strong></td>
<td style="text-align:center">结果为浮点数，即使两数整除，<strong>结果也是浮点数</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>//</code></strong></td>
<td style="text-align:center">结果为整数，也称地板除，对<strong>结果向下取整</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>%</code></strong></td>
<td style="text-align:center">结果为整数，用于计算余数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p>Python中复数用j表示虚数部分，比如说 <code>x=2.4 + 5.6j</code>， 并且可以通过复数的类属性 <code>real</code> 取得实部，类属性 <code>imag</code> 取得虚部，通过类方法 <code>conjugate()</code> 获得共轭复数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">2.4</span> + <span class="number">5.6j</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</div><div class="line"><span class="number">2.4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</div><div class="line"><span class="number">5.6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.conjugate()</div><div class="line">(<span class="number">2.4</span><span class="number">-5.6j</span>)</div></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>使用单引号或双引号括起。而引号本身需要使用转义符<code>\</code>来表达。 用<code>\&#39;</code>来表示<code>&#39;</code>。</p>
<p>转义符还可以用来转义很多字符，如<code>\n</code>表示换行。<code>\t</code>表示制表符。 <code>\</code>本身也需要转义用 <strong>双斜杠</strong> 来代替。</p>
<p>如果一个字符串中很多字符都要转义就会很麻烦，所以Python又提供一种简便的写法，<strong><code>r&#39;&#39;</code>表示两个引号之间的内容是不需要转义的</strong>。 对于多行的字符串，为了避免加入<code>\n</code>的不方便，可以使用<code>&#39;&#39;&#39;something&#39;&#39;&#39;</code>的格式，即<strong>用三个引号来括起字符串，换行会被保留</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 没使用三引号</div><div class="line">&gt;&gt;&gt; a = '123</div><div class="line">  File "&lt;stdin&gt;", line 1</div><div class="line">a = '123</div><div class="line">   ^</div><div class="line">SyntaxError: EOL while scanning string literal</div><div class="line"></div><div class="line"># 使用了三引号</div><div class="line">&gt;&gt;&gt; a = '''123</div><div class="line">... 456</div><div class="line">... 789'''</div><div class="line">&gt;&gt;&gt; a</div><div class="line">'123\n456\n789'</div></pre></td></tr></table></figure>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>只有True和False两种，首字母大写。如果输入一个判断式，则Python会给出布尔值的结果。比方说输入3&gt;2，运行后会得到True。 对于布尔值有三个逻辑运算符，分别是and，or和not。 <strong>本质上True用1存储，False用0存储</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> != <span class="number">0</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == <span class="keyword">False</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><p>Python中用None表示，<strong>不同于数值0</strong>。数值0是有意义的，而None是一个特殊的空值。可以将None赋值给变量，但无法创建None以外的其他NoneType对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; a = None</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; None == a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; None == ''</div><div class="line">False</div><div class="line">&gt;&gt;&gt; None == 0</div><div class="line">False</div></pre></td></tr></table></figure>
<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>Python是一门动态类型语言</strong>，这意味着在Python中，<strong>可以反复把任意数据类型的对象赋值给同一个变量</strong>，相比起静态语言更加地灵活。</p>
<p>在Python中变量名不可以以数字开头，构成可以包括大小写英文，数字及下划线。</p>
<p>当我们写：a=’ABC’ 时，Python解释器干了两件事情：</p>
<ol>
<li>在内存中创建了一个值为<code>&#39;ABC&#39;</code>的字符串对象；</li>
<li>在内存中创建了一个名为a的变量，并把它指向对象<code>&#39;ABC&#39;</code>。</li>
</ol>
<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>Python中没有常量</strong>，因为变量都可以重复赋值。但是一般<strong>约定用全部字母大写的单词来表示一个常量</strong>，如：PI=3.14。</p>
<hr>
<p><br></p>
<h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种Python内置的数据类型，表示<strong>有序集合</strong>，可动态删除和插入。通过索引可以访问列表元素，<strong>索引从0开始</strong>，即访问第一个列表元素。并且列表是循环的，<strong>可以通过索引－1访问最尾的元素</strong>，索引－2访问倒数第二个元素。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</div><div class="line"><span class="string">'Michael'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</div><div class="line"><span class="string">'Tracy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>]</div><div class="line"><span class="string">'Bob'</span></div></pre></td></tr></table></figure>
<p>另外，还可以用 <code>len()</code> 函数获取列表的元素个数。</p>
<p>list 是一个<strong>可变的</strong>有序表，所以，可以往 list 中追加元素到末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>也可以把元素插入到指定的位置，比如索引号为 1 的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>要删除 list 末尾的元素，用 pop() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</div><div class="line"><span class="string">'Adam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</div><div class="line"><span class="string">'Jack'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素的数据类型可以不同，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素也可以是另一个 list，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>] <span class="comment"># 四个元素，其中第三个元素是一个列表</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</div><div class="line"><span class="string">'python'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</div><div class="line">[<span class="string">'asp'</span>, <span class="string">'php'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">0</span>]</div><div class="line"><span class="string">'asp'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">1</span>]</div><div class="line"><span class="string">'php'</span></div></pre></td></tr></table></figure>
<p>要注意s只有4个元素，s[2]作为一个list类型的元素。要拿到’php’可以用 <code>s[2][1]</code>，即把s看作一个二维数组，这样的嵌套可以有很多层。</p>
<p>如果一个 list 中一个元素也没有，就是一个空的 list，它的长度为 0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(L)</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple也是一种<strong>有序列表</strong>，但<strong>tuple一旦初始化就无法再修改</strong>，也因为这个特性，所以代码更安全。和list不同，tuple用小括号来括起。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</div></pre></td></tr></table></figure>
<p>定义空的tuple如下如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">()</div></pre></td></tr></table></figure>
<p>但是，要<strong>定义一个只有1个元素的 tuple</strong>，就要注意一下，如果使用t = (1)来定义，则得到的不是一个tuple，而是整数1，因为括号既可以表示tuple又可以表示数学公式中的小括号。这种情况下默认为后者。要定义1个元素的tuple格式如下，使用一个逗号进行区分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line"><span class="number">1</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="number">1</span>,)</div></pre></td></tr></table></figure>
<p>tuple也有 “可变” 的例子，如果tuple的其中一个元素是list，则这个list元素的内容是可以修改的，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</div></pre></td></tr></table></figure>
<p>这个例子实际修改的是list而不是tuple，tuple指向的位置不会变，而list指向的位置可变，上面的例子实际上是创建了字符串X和Y，然后让tuple的第三个元素也即list元素指向这两个新的字符串。</p>
<hr>
<p><br></p>
<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict即字典，用于存储键值对，查找速度极快。如果使用list来存键值对就需要两个list，要先从key list找出key，再从value list找到对应项的值，因此list越长，耗时越长。用dict实现则可以直接根据key来找value。格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</div><div class="line"><span class="number">95</span></div></pre></td></tr></table></figure>
<p>dict速度快是因为Python内部像字典一样建立了索引，字典有部首表，Python内部也会根据不同key算出一个存放的「页码」(哈希算法)，所以速度非常快。除了初始化赋值还可以对同一个key进行多次赋值，会覆盖原来的value，如果key不存在就会对dict插入一个新的键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>] = <span class="number">20</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Lincoln'</span>] = <span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p>要判断key是否在dict里面有两种方法：</p>
<p>1.使用in关键字，有则返回True，无则返回False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>2.使用dict提供的get方法，有则返回key对应的value，无则返回空值None或者自己指定的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</div><div class="line"><span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>删除一个key则对应的value也会从dict中删除，使用pop方法来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</div><div class="line"><span class="number">75</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>dict的插入和查找速度极快，不会随着key的增加而增加，但需要占用大量的内存</strong>，内存浪费多。list则相反，插入和查找时间随元素增加而增加，但占用空间少。所以dict是一种用空间换时间的方法，注意<strong>dict的key必须是不可变对象</strong>，无法修改key，不然dict就混乱了。<strong>字符串和整数等都可以作为key，list无法作为key</strong>。</p>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict的原理是一样的，同样<strong>不可以放入可变对象做key</strong>，唯一的区别是<strong>set只有key没有value</strong>。显然<strong>set里面是没有重复的元素的</strong>，不然哈希时会出错。<strong>set是有序的，需要使用列表/元组做初始化</strong>，定义方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>列表中有重复元素时set会自动被过滤</strong>，添加可以使用add方法，如s.add(4)。删除则用remove方法，如s.remove(4)。</p>
<p>集合可以看成数学意义上无序和无重复的集合，<strong>可以做交集、并集、差集等操作</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</div><div class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1-s2</div><div class="line">&#123;<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="再议不可变对象"><a href="#再议不可变对象" class="headerlink" title="再议不可变对象"></a>再议不可变对象</h3><p>Python中一切皆对象，而对象又分可变对象和不可变两类对象两类，具体来说，它们的差别就是<strong>对象的内容是否可变</strong>。不可变对象包括int, float, string, tuple，空值等，可变对象包括list, dict, set等。要注意对象和变量的关系，<strong>在Python里，变量都是对对象的引用</strong>。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'b'</span>  <span class="comment"># 字符串对象本身是不可变的</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"></div><div class="line"><span class="comment"># 变量可以指向另一个字符串对象</span></div><div class="line"><span class="comment"># 但字符串对象'abc'并没有改变，它依然存在于内存中</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'bbc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'bbc'</span></div></pre></td></tr></table></figure>
<p>关于参数传递，可以简单总结为以下两点：</p>
<ul>
<li>当一个可变对象作为函数参数时，函数内对参数修改会生效。</li>
<li>当一个不可变对象作为函数参数时，函数内对参数修改无效，因为实际上函数是创建一个新的对象并返回而已，没有修改传入的对象。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</div><div class="line">&gt;&gt; a</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<p>list是可变对象，使用函数操作，内容会变化，注意区分一下<strong>变量</strong>和<strong>对象</strong>，这里a是一个变量，它指向一个列表对象，这个列表对象的内容才是[‘c’, ‘b’, ‘a’]。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line"><span class="string">'Abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'abc'</span></div></pre></td></tr></table></figure>
<p>字符串是不可变对象，所以replace函数并不会修改变量a指向的对象，实际上调用不可变对象的任意方法都不改变该对象自身的内容，只会创建新对象并返回，如果使用一个新的变量来接收返回的对象，就能得到操作结果。不接收则直接打印，<strong>原变量指向的对象不会变化</strong>。</p>
<p>注意，虽然tuple是不可变对象，但是如果使用tuple作为dict或者set的key，还是有可能产生错误，因为tuple允许元素中包含列表，列表内容可变。如果使用了带有列表元素的tuple作为key就会报 <strong><code>TypeError: unhashable type: &#39;list&#39;</code></strong> 的错误。</p>
<hr>
<p><br></p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>Python中代码块是以缩进作区分的，<strong>if－else条件判断注意要在判定条件后写冒号，并且代码块都正确对齐。多个判断条件可以使用多个elif来实现</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">age = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</div><div class="line">print(<span class="string">'teenager'</span>)</div><div class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</div><div class="line">print(<span class="string">'adult'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">'kid'</span>)</div></pre></td></tr></table></figure>
<p>判断条件并不一定要是一个判断式，可以简写为一个变量，<strong>当变量为非零数值，非空字符串，非空list等时，判断为True，否则为False</strong>。</p>
<hr>
<h3 id="再议input"><a href="#再议input" class="headerlink" title="再议input"></a>再议input</h3><p>有时会采取 <strong><code>input(&#39;提示语句&#39;)</code></strong> 的方式读取用户输入，作为判定条件。要注意<strong>用户输入属于字符串类型</strong>，要进行数值比较必须先转换为对应的数据类型，否则会报错。</p>
<p>Python提供int(), float(), str()等方法进行数据类型的转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输入1表示Yes，输入0表示No</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>choose = input(<span class="string">'If you choose yes, please input 1. Otherwise, input 0: '</span>)</div><div class="line">If you choose yes, please input <span class="number">1.</span> Otherwise, input <span class="number">0</span>: <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> choose: <span class="comment"># 没有进行转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">Yes</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> int(choose): <span class="comment"># 进行了转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">No</div></pre></td></tr></table></figure>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Python提供两种循环写法，一种是 <strong><code>for...in...</code></strong> 循环，一种是 <strong><code>while...</code></strong> 循环。for循环依次把list或tuple中的每个元素赋值给目标标识符，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> names:</div><div class="line"><span class="meta">... </span>print(name)</div><div class="line">...</div><div class="line">Michael</div><div class="line">Bob</div><div class="line">Tracy</div></pre></td></tr></table></figure>
<p>当列表为连续数值时，可以用range方法生成，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line"><span class="meta">... </span>sum = sum + x</div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>while循环的写法和if－else很相似，也是在判定条件后面加一个冒号。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">11</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>sum = sum + n</div><div class="line"><span class="meta">... </span>n = n - <span class="number">2</span></div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">11</span></div><div class="line"><span class="number">20</span></div><div class="line"><span class="number">27</span></div><div class="line"><span class="number">32</span></div><div class="line"><span class="number">35</span></div><div class="line"><span class="number">36</span></div></pre></td></tr></table></figure>
<p>另外，对于死循环的程序，可以通过<strong>Ctrl＋C</strong> 强制终止。</p>
<hr>
<p><br></p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li><p>ASCII</p>
<blockquote>
<p>最早的编码，包含大小写英文，数字及一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8位二进制组合(1个字节)，可表示128个不同字符(最高位用于校验)。</p>
</blockquote>
</li>
<li><p>GB2312</p>
<blockquote>
<p>处理中文时一个字节显然不足，至少需要用两个字节，并且不与ASCII冲突，因此有了中国自己制定的GB2312编码，可用于编码中文。</p>
</blockquote>
</li>
<li><p>Shift_JIS和Euc-kr</p>
<blockquote>
<p>日本编码为Shift_JIS，韩文编码为Euc-kr。这样各个国家都用自己不同的标准和编码就很容易在多语言的环境产生冲突，变成乱码。因此又有了通用的一套编码。</p>
</blockquote>
</li>
<li><p>Unicode</p>
<blockquote>
<p>Unicode将所有语言统一到一套编码中，一般使用2个字节，部分非常偏僻的字符会用到4个字节。但是使用Unicode编码，如果在大量英文的环境又非常浪费空间，因为存储和传输时大小是使用ASCII编码的两倍，不划算，于是又有了新的方式。</p>
</blockquote>
</li>
<li><p>UTF-8</p>
<blockquote>
<p>UTF-8是可变长编码，对Unicode字符不同的数字大小编码成1-6个字节，英文字母为1个字节，汉字一般是3个字节。需要用到4-6字节的字符非常少，这样比较节省空间。</p>
</blockquote>
</li>
</ul>
<p><strong>Example</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">ASCII</th>
<th style="text-align:center">Unicode</th>
<th style="text-align:center">UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">01000001</td>
<td style="text-align:center">00000000 01000001</td>
<td style="text-align:center">01000001</td>
</tr>
<tr>
<td style="text-align:center">中</td>
<td style="text-align:center">(超出范围)</td>
<td style="text-align:center">01001110 00101101</td>
<td style="text-align:center">11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
</div>
<h4 id="插播一段课外知识"><a href="#插播一段课外知识" class="headerlink" title="插播一段课外知识"></a>插播一段课外知识</h4><p>摘录整理自知乎提问<a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a>。</p>
<p>为什么要分Unicode和UTF-8，它们两者有什么区别和关联呢？</p>
<p>其实最早的时候，由于各地区使用的编码方式不同，使用不同语言的人交流就成了一个大问题。国际标准组织ISO制订了统一的<strong>通用字符集（Universal Character Set，UCS）</strong>，也<strong>简称为Unicode</strong>。<strong>早期的Unicode版本对应于UCS-2编码方式</strong>，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示 2^16 也即 65536 个字符，基本满足各种语言的使用。根据维基的说法，当前最新版本的Unicode标准收录了128,000个字符，已经远远超出两字节所能表示的65536了。所以<strong>把Unicode视作UCS-2是一种过时的说法，Unicode标准存在多于两字节的字符</strong>。</p>
<p><strong>Unicode有多种字符编码实现方式</strong>。一个Unicode字符的code point是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，<strong>会使用不同的字符编码来实现Unicode</strong>。<strong>这些字符编码统称为Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong>。</p>
<p>例如，对于一个仅包含ASCII字符(只需要7位)的Unicode文件，如果每个字符都使用2字节的<strong>原Unicode编码</strong>传输，其第一字节的首位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用<strong>UTF-8编码，这是一种变长编码，它将ASCII字符仍用7位编码表示，占用一个字节（首位补0）</strong>。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以ASCII字符为主的西文文档就大大节省了编码长度。</p>
<p>但是，<strong>现在所说的Unicode一般都指的是字符集而非编码方式</strong>，廖雪峰老师在教程里提到的Unicode编码实际上指的是UCS-2这种编码方式。又因为以前UCS-2和UTF-16是等价的，所以微软的文档习惯把UTF16称为Unicode，这也导致很多开发者容易对此产生误会。</p>
<p>以上内容虽然有部分针对廖雪峰老师教程中描述不准确的地方进行了修改，但可能还是存在一些让人迷惑的说法，更详细的讲解可以看我的博文<a href="http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%EF%BC%8C%E4%BB%A5%E5%8F%8APython3%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">字符集与编码的恩怨情仇，以及Python3中的编码问题</a>。</p>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><p>在计算机存储中，内存统一使用Unicode编码，而硬盘保存或者传输数据就用UTF-8编码。比方说打开记事本时，数据会从硬盘中UTF-8编码格式转换为Unicode格式，保存时则相反。</p>
<p>浏览网页时，服务器端动态生成的内容是Unicode编码，而传输时则会变为传输UTF-8编码格式的网页。所以常常在网页源码中看到 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的语句，表示该网页正是用的UTF-8编码。</p>
<p><strong>按我的理解，可以这样总结：在传输/储存时，为了节省带宽/空间，会使用UTF-8这样的Unicode字符集的实现方式；而在计算机要处理的时候，应当使用原Unicode编码方式，也即每个字符都是固定两字节，这样字符长度统一更便于操作。</strong></p>
<p>特别注意，在涉及到字节流和字符串转换的程序里，我们<strong>应始终坚持使用UTF-8编码进行转换</strong>，从而避免乱码问题。</p>
<p>另外，代码本身也是文本，所以也有编码相关的问题。在编写Python脚本时，一般会在文件头部加入以下两句注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统则会忽略这个注释；</p>
<p>第二行注释是为了告诉<strong>Python解释器，按照UTF-8编码读取源代码</strong>，否则，如果源代码中有中文的话，就会出现乱码了。</p>
<p>注意，这里<strong>仅仅是声明了读取时采用UTF-8编码，但文件本身的编码不一定是UTF-8</strong>，要确定把代码文件编码为UTF-8格式，我们需要对写代码的IDE/文本编辑器进行相应的设置。廖老师提到，<strong>要确保使用UTF-8 without BOM编码</strong>，<strong>那么BOM和without BOM有什么区别呢？</strong>暂不在此进行讨论。</p>
<p>关于Python3中编码的信息，可以再看看<a href="https://docs.python.org/3/howto/unicode.html#introduction-to-unicode" target="_blank" rel="external">官方文档</a>。</p>
<hr>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><p>Python中，<strong>字符串类型中的每个字符采用的是两字节的Unicode编码</strong>，支持多语言。</p>
<h4 id="ord函数"><a href="#ord函数" class="headerlink" title="ord函数"></a>ord函数</h4><p>ord函数可以<strong>获取字符的十进制整数表示</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</div><div class="line"><span class="number">20013</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'文'</span>)</div><div class="line"><span class="number">25991</span></div></pre></td></tr></table></figure>
<p>注意只能传入<strong>单个字符</strong>。</p>
<h4 id="chr函数"><a href="#chr函数" class="headerlink" title="chr函数"></a>chr函数</h4><p>chr函数可以<strong>将十进制整数转换为Unicode编码下对应的字符</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">20013</span>)</div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</div><div class="line"><span class="string">'文'</span></div></pre></td></tr></table></figure>
<p>此外,如果知道了字符的十进制编码，可以将其转换为十六进制，然后<strong>使用<code>\u</code>转义得到对应的Unicode字符</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">20013</span>)</div><div class="line"><span class="string">'0x4e2d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d'</span></div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">25991</span>)</div><div class="line"><span class="string">'0x6587'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u6587'</span></div><div class="line"><span class="string">'文'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span> <span class="comment"># 多个字符</span></div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<p>补充一下，Unicode编码是多语言的，不仅限于中文和英文，还可以使用多种语言的字符及符号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: ord(<span class="string">'한'</span>) <span class="comment"># 韩语</span></div><div class="line">Out[<span class="number">1</span>]: <span class="number">54620</span></div><div class="line">In [<span class="number">2</span>]: hex(<span class="number">54620</span>)</div><div class="line">Out[<span class="number">2</span>]: <span class="string">'0xd55c'</span></div><div class="line">In [<span class="number">3</span>]: <span class="string">'\ud55c'</span></div><div class="line">Out[<span class="number">3</span>]: <span class="string">'한'</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: ord(<span class="string">'に'</span>) <span class="comment"># 日语</span></div><div class="line">Out[<span class="number">4</span>]: <span class="number">12395</span></div><div class="line">In [<span class="number">5</span>]: hex(<span class="number">12395</span>)</div><div class="line">Out[<span class="number">5</span>]: <span class="string">'0x306b'</span></div><div class="line">In [<span class="number">6</span>]: <span class="string">'\u306b'</span></div><div class="line">Out[<span class="number">6</span>]: <span class="string">'に'</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: ord(<span class="string">'a'</span>) <span class="comment"># 英语</span></div><div class="line">Out[<span class="number">7</span>]: <span class="number">97</span></div><div class="line">In [<span class="number">8</span>]: hex(<span class="number">97</span>)</div><div class="line">Out[<span class="number">8</span>]: <span class="string">'0x61'</span></div><div class="line">In [<span class="number">9</span>]: <span class="string">'\u0061'</span></div><div class="line">Out[<span class="number">9</span>]: <span class="string">'a'</span></div><div class="line"></div><div class="line">In [<span class="number">10</span>]: ord(<span class="string">'1'</span>) <span class="comment"># 数字</span></div><div class="line">Out[<span class="number">10</span>]: <span class="number">49</span></div><div class="line">In [<span class="number">11</span>]: hex(<span class="number">49</span>)</div><div class="line">Out[<span class="number">11</span>]: <span class="string">'0x31'</span></div><div class="line">In [<span class="number">12</span>]: <span class="string">'\u0031'</span></div><div class="line">Out[<span class="number">12</span>]: <span class="string">'1'</span></div><div class="line"></div><div class="line">In [<span class="number">13</span>]: ord(<span class="string">','</span>) <span class="comment"># 符号</span></div><div class="line">Out[<span class="number">13</span>]: <span class="number">44</span></div><div class="line">In [<span class="number">14</span>]: hex(<span class="number">44</span>)</div><div class="line">Out[<span class="number">14</span>]: <span class="string">'0x2c'</span></div><div class="line">In [<span class="number">15</span>]: <span class="string">'\u002c'</span></div><div class="line">Out[<span class="number">15</span>]: <span class="string">','</span></div></pre></td></tr></table></figure>
<p>从以上代码可以看到，这里的Unicode编码中<strong>每个字符都是固定用两字节表示（一个字符用4位16进制数表示，每个16进制数需要4bit，所以一共是4*4 = 16bits = 2bytes）</strong>，<strong>和廖老师教程中所说的若干个字节不一致，是否真的有多于两字节的Unicode字符呢？有待考究。</strong></p>
<h4 id="bytes类型"><a href="#bytes类型" class="headerlink" title="bytes类型"></a>bytes类型</h4><p>因为Python程序执行时，字符串类型是用Unicode编码的，一个字符对应若干字节（<strong>若干字节还是固定两个字节呢？</strong>），要在网络中传输或存储到硬盘中就要把字符串变为bytes类型（<strong>因为传输和存储都是以字节为单位的，所以需要进行转换。又因为要节省资源，所以会使用别的编码方式如utf-8</strong>）。</p>
<p>Python显示bytes类型的数据会用b作前缀，要注意 <strong><code>b&#39;ABC&#39;</code></strong> 和 <strong><code>&#39;ABC&#39;</code></strong> 的差别，尽管内容一样，但前者的每个字符都只占1个字节，而后者在Python中以Unicode进行编码，每个字符占两个字节。也即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x41\x42\x43'</span>  <span class="comment"># bytes类型，每个英文字符占1个字节</span></div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u0041\u0042\u0043'</span> <span class="comment"># Unicode类型，每个英文字符占2个字节，前8bit用0填充</span></div><div class="line"><span class="string">'ABC'</span></div></pre></td></tr></table></figure>
<p>Unicode字符串可以通过 <strong><code>encode()</code></strong> 方法编码为指定的bytes，如ASCII编码，utf-8编码etc，bytes类型的数据如果字符不属于ASCII码的范围，就用 <strong><code>&#39;\x##</code></strong> 的格式表示。 相应地，如果读取字节流的数据，就要用 <strong><code>decode()</code></strong> 方法解码。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<h4 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h4><p><strong>对字符串使用len函数会得到字符的数目</strong>，而<strong>对字节流使用len函数则会得到有多少字节</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>) <span class="comment"># 字符串'中文'包含两个字符</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u4e2d\u6587'</span>) <span class="comment"># 用4个字节表示字符串'中文'</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 字符串'中文'编码为utf-u格式后，占6个字节</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 用6个字节表示字节流'中文'</span></div><div class="line"><span class="number">6</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>) <span class="comment"># 字符串'ABC'包含三个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u0041\u0042\u0043'</span>) <span class="comment"># 用6个字节表示字符串'ABC'</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)) <span class="comment"># 字符串'ABC'编码为ASCII格式后，占3个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\x41\x42\x43'</span>) <span class="comment"># 用3个字节表示字节流'ABC'</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>和C语言类似，Python中使用百分号 <code>％</code> 占位符实现格式化的功能。<code>％s</code>表示用字符串替换，<code>％d</code>，<code>％f</code>，<code>％x</code>分别表示用整数，浮点数和十六进制数替换。其中<code>％s</code>可以将任意数据类型转换为字符串。而<code>％d</code>和<code>％f</code>则可以指定整数和小数部分的位数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的格式化</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %d %f %x'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.200000 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %s可以转换任意数据类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %s %s %s'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.2 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %d可以控制整数部分的位数，不足的位数默认以空格填充</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%4d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'   5'</span></div><div class="line"></div><div class="line"><span class="comment"># 除了用空格填充之外，也可以使用0填充不足的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%04d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'0005'</span></div><div class="line"></div><div class="line"><span class="comment"># %f也可以控制整数和小数部分的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%f - %.2f - %2.2f - %02.2f'</span> % (<span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>)</div><div class="line"><span class="string">'1.200000 - 1.20 - 1.20 - 1.20'</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>只有一个占位符时，后面变量不需要用括号括起。</li>
<li>如果字符串本身包含<code>％</code>，则需要转义，用<code>％％</code>来表示百分号。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %'</span> % <span class="number">7</span> <span class="comment"># 没有转义百分号</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: incomplete format</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span> <span class="comment"># 转义了百分号</span></div><div class="line"><span class="string">'growth rate: 7 %'</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符集与编码的恩怨情仇]]></title>
      <url>http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87/</url>
      <content type="html"><![CDATA[<p>最近在整理Python学习笔记的时候，发现自己一直以来对Unicode的认识和廖雪峰老师在Python3教程中所说的有不一致的地方，抱着求知的态度，查找多方资料后总算是弄明白了，也就整理成了这一篇文章。</p>
<p>编码问题一直以来都是很多程序员的噩梦，有时候好不容易写好一个带着详细注释的代码文件，保存一下再打开就发现注释全都乱码了。自己工作的时候还好，摸索一下弄对编码就好了。但是如果是多人协作或者发布产品时，没有统一好编码就会造成很大的问题，特别是对于来自不同国家使用不同语言的工作人员/用户来说。因此，统一编码是非常重要的，也就有了Unicode的出现。</p>
<p>下文将通过以下顺序进行讲解：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#编码的历史">编码的历史</a></li>
<li><a href="#标准、字符集与编码">标准、字符集与编码</a><ul>
<li><a href="#character-repertoire">Character repertoire</a></li>
<li><a href="#coded-character-set">Coded character set</a></li>
<li><a href="#character-encoding-form">Character encoding form</a></li>
<li><a href="#character-encoding-scheme">Character encoding scheme</a></li>
</ul>
</li>
<li><a href="#带bom和不带bom">带BOM和不带BOM</a></li>
<li><a href="#windows中的编码问题">Windows中的编码问题</a></li>
<li><a href="#python3中的编码问题">Python3中的编码问题</a></li>
<li><a href="#参考与感谢">参考与感谢</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="编码的历史"><a href="#编码的历史" class="headerlink" title="编码的历史"></a>编码的历史</h2><p>首先需要理解一下<strong>为什么要进行编码</strong>。我们知道，对计算机而言，一切信息都不过是01比特串，不同的01组合成不同的比特串从而可以表示不同的信息。但是，对人类来说，我们阅读写作所用的是自然语言，于是就存在着<strong>如何使用01比特串来表示自然语言</strong>这样一个问题。</p>
<p>在计算机中，8个比特（bit）组成1个字节（byte），可以表示256种不同状态。在最早的时候，计算机使用者用的都是英语，于是美国人就设计了<strong>ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）</strong>，它包含了大小写英文，数字，控制码以及其它一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8个比特(也即1个字节)，可表示128个不同字符(最高位留出，用于校验)。这样计算机就能使用不同的字节来表示英文了，显示时GUI工具或者字体渲染器只需要根据字节来显示相应的字母就可以了。</p>
<p>后来随着计算机技术的发展，各个国家都开始使用计算机了，但并不是每个国家都使用英语呀。中华文化博大精深，光是常用汉字就有6000多个，显然处理中文时一个字节是不足够的，至少要用两个字节，并且不能与ASCII冲突，因此就有了中国自己制定的<strong>GB2312标准</strong>（每个字符两字节）。后来由于中文字实在太多了，然后还有一些少数民族使用的文字，于是又相继推出了GBK标准和GB18030标准。</p>
<p>日本和韩国也不例外，日本制定了<strong>Shift_JIS标准</strong>，韩国制定了<strong>Euc-kr标准</strong>。还有很多使用其他语言的国家/地区也纷纷制定了适合自己语言的编码标准。</p>
<p>但是，各个国家都用自己不同的标准和编码，在多语言的环境下就很容易产生冲突，产生乱码。国际标准组织ISO看不下去了，就制定了一套统一的标准：<strong>通用字符集（Universal Character Set，UCS）</strong>，后来发展为俗称的<strong>Unicode标准</strong>，将多种语言文字统一到一套标准中。</p>
<h2 id="标准、字符集与编码"><a href="#标准、字符集与编码" class="headerlink" title="标准、字符集与编码"></a>标准、字符集与编码</h2><p>在查找相关资料的过程中，我发现<strong>标准、字符集、编码这几个概念相当容易被混淆</strong>，甚至不少资深程序员也会说混。在廖雪峰老师的Python3教程中，他所说的Unicode指的是一种编码，而现在我们讨论Unicode的时候，一般是指Unicode字符集，它有多种编码，如UTF-8、UTF-16和UTF-32。那是不是廖雪峰老师所说的是错误的呢？<strong>XXX标准、XXX字符集、XXX编码到底有什么区别呢？</strong></p>
<p>首先呀，像前面一节说到的那样，根据需要会制定出不同的<strong>标准（standard）</strong>。有时候一套标准只涉及到字符集，就称为字符集标准。但是一套标准里面还可能涉及到实现该字符集的一种或多种编码以及其它一些细节。</p>
<p><strong>字符集（character set）</strong>是什么呢？更准确的说，应该称其为<strong>编码字符集coded character set (CCS)</strong>。它定义的是<strong>字符和code point的映射关系</strong>，code point通常是用十六进制表示的整数，比方说Unicode字符集中，使用4位十六进制数的code point <code>0061</code>（十进制的97） 来表示小写字母 <code>a</code>。字符集里的每一条标识包括code point，对应的字符以及一个明确的字符名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061</span><span class="string">'a'</span>; LATIN SMALL LETTER A</div><div class="line"><span class="number">0062</span><span class="string">'b'</span>; LATIN SMALL LETTER B</div><div class="line"><span class="number">0063</span><span class="string">'c'</span>; LATIN SMALL LETTER C</div><div class="line">...</div><div class="line"><span class="number">007</span>B<span class="string">'&#123;'</span>; LEFT CURLY BRACKET</div></pre></td></tr></table></figure>
<p>接下来再说说最难说清楚的<strong>编码、编码方式、编码方案、实现方式、字符编码（character encoding）</strong>，这几个术语经常都会混用，甚至在同一篇文献中的不同地方也常常出现不同的称谓，它们之间或许有一些细微的差别，但是由于中文文献中混用得太多，基本上都被认为是同一样东西了。</p>
<p>那<strong>为什么有时候很难分清标准、字符集、编码这几个概念呢？</strong></p>
<p>其实呀，对于 ASCII、GB2312、Big5、GBK、GB18030 之类的标准来说，基本上一个字符集只对应一种编码。比如 ASCII标准 本身就直接规定了 ASCII字符集 和 ASCII编码；而 GB2312标准 则是一套字符集标准，实际上用 EUC-CN 来编码。GBK 和 GB18030 等也类似。</p>
<p>又因为很多文献中，写作并不严谨，有时就会省略掉 “标准”、”字符集”、”编码”这样的后缀，只使用名称。在提及 ASCII 的时候，实际上指的既可以是 ASCII字符集 又可以是 ASCII编码，还可以是 ASCII标准 这样一个整体；提及 GB2312 时，指的则是 GB2312字符集 和 EUC-CN编码 组合起来的整体。于是呀，很多人受到这些遗留标准的影响，以为字符集和编码是同一回事儿，而无法正确理解字符集和编码的关系。</p>
<p>但是，<strong>对 Unicode标准 来说，字符集和编码是明确区分的</strong>。Wikipedia的Unicode词条是这样说的：</p>
<blockquote>
<p><strong>Unicode</strong> is a computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world’s writing systems. <strong>Developed in conjunction with the Universal Coded Character Set (UCS) standard</strong> and <strong>published as The Unicode Standard.</strong> …… The standard consists of a set of code charts for visual reference, an encoding method and set of standard character encodings, a set of reference data files, and a number of related items, such as character properties, rules for normalization, decomposition, collation, rendering, and bidirectional display order (for the correct display of text containing both right-to-left scripts, such as Arabic and Hebrew, and left-to-right scripts).</p>
</blockquote>
<p>那么这里又产生一个新问题了？<strong>UCS和Unicode的关系是怎样的呢？</strong></p>
<p>最开始的时候，UCS和Unicode是两个不同的标准，由不同的组织提出。Unicode是Unicode联盟进行整理和编码的。和Unicode联盟类似，ISO也做了类似的事情，创造了UCS字符集标准。后来双方意识到世界上并不需要两套通用字符集，于是就开始整合，到了Unicode2.0时，Unicode和UCS的编码（字符集）就基本一致了，所以<strong>粗略来说，可以认为Unicode和UCS是同一样东西，它们是共同发展的</strong>。</p>
<p>但是从细节上来说，UCS中除了字符集，还定义有<strong>UCS-2（曾被称为Unicode，但现在Unicode字符集的范围已经远远超出UCS-2所能表示的，所以UCS-2被废弃了）</strong>、UCS-4等等用于实现UCS字符集的编码；而Unicode标准不但能够使用UCS-2和UCS-4编码，还针对传输/存储定义了另外一些编码，如UTF-8、UTF-16（可以认为是UCS-2的扩展）和UTF-32（可以认为是UCS-4的子集）等等。综上所述，<strong>说 Unicode 是一种编码是带误导性并且不合时的。</strong></p>
<p>再贴一段Wikipedia上的原话：</p>
<blockquote>
<p>Unicode can be implemented by different character encodings. The most commonly used encodings are UTF-8, UTF-16 and the now-obsolete UCS-2.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>Unicode（字符集标准） 可以使用不同的字符编码进行实现。 最常用的编码（方式）有UTF-8，UTF-16以及现在已经废弃了的UCS-2。</p>
</blockquote>
<p>最后再总结一下几个概念吧：</p>
<h3 id="Character-repertoire"><a href="#Character-repertoire" class="headerlink" title="Character repertoire"></a>Character repertoire</h3><p>字符集，是一个系统所能支持的所有抽象字符（包含一种或多种语言以及使用的标点符号）的集合。它有可能是闭合的，比如ASCII标准的字符集，只包含西文字符和符号等等；也可能是开放的，比如Unicode标准的字符集，可以允许继续添加新的字符。</p>
<h3 id="Coded-character-set"><a href="#Coded-character-set" class="headerlink" title="Coded character set"></a>Coded character set</h3><p>编码字符集，是一个把字符映射为code point的函数，每个code point对应一个字符。比方说给定一个Character repertoire，拉丁字母中的大写字母A可以被表示为65这个code point。多个编码字符集可能使用同一个Character repertoire，但采用不同的映射方式。</p>
<h3 id="Character-encoding-form"><a href="#Character-encoding-form" class="headerlink" title="Character encoding form"></a>Character encoding form</h3><p>字符编码方式，是code point和一个/多个code unit之间的映射。比方说一个使用16 bit code unit来存储信息的系统，它的一个code unit最多能表示0~65535，对于code point小于等于65535的字符，一个code unit就能存储了，而code point大于65535的字符则需要使用多个code unit来存储。</p>
<h3 id="Character-encoding-scheme"><a href="#Character-encoding-scheme" class="headerlink" title="Character encoding scheme"></a>Character encoding scheme</h3><p>字符编码方案，是code unit和octets序列之间的映射。在传统的二进制数字概念中，1 byte（字节）=8 bit（位）。<strong>大多数因特网标准使用octet（八位组）这个术语而不是使用字节来表示8 bit</strong>。该术语起始于TCP/IP发展的早期，当时许多早期的工作是在诸如DEC－10这样的系统上进行的，然而这些系统的结构使用的字节(byte)长度是10位（bit）,因此出现了octet的单位，即准确定义 1 octet = 8 bit。字符编码方案包括UTF-8、UTF-16等等。</p>
<p>所以呀，从这里可以看出<strong>编码方式和编码方案还是有那么一些区别的</strong>，我们知道英文字母只需要8 bit就能存储了，如果都采用16 bit的code unit来存就会造成很大的浪费。正因为这样，所以又有了编码方案，在存储/传输的实现上进行改变，从而节省空间/带宽。但是混用得实在太多了，也就很难再分清了。</p>
<h2 id="带BOM和不带BOM"><a href="#带BOM和不带BOM" class="headerlink" title="带BOM和不带BOM"></a>带BOM和不带BOM</h2><p>先贴一段wikipedia的原文：</p>
<blockquote>
<p>The byte order mark (BOM) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), whose appearance as a magic number at the start of a text stream can signal several things to a program consuming the text:</p>
</blockquote>
<ul>
<li><blockquote>
<p>What byte order, or endianness, the text stream is stored in;</p>
</blockquote>
</li>
<li><blockquote>
<p>The fact that the text stream is Unicode, to a high level of confidence;</p>
</blockquote>
</li>
<li><blockquote>
<p>Which of several Unicode encodings that text stream is encoded as.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>BOM use is optional, and, if used, should appear at the start of the text stream.</p>
</blockquote>
<p>BOM其实就是用来标示Unicode纯文本字节流用的是哪一种编码，它设计出来不是用来支持HTML和XML的。要识别文本的编码，HTML可以使用charset属性，XML可以使用encoding属性，没必要使用BOM。使用BOM主要是微软的习惯，UNIX系统是不鸟BOM的。</p>
<p>有一个最主要的原因是，在UNIX系统中，所有脚本语言通用的首行 <code>#!</code> 标示依赖于shell解析，而很多shell出于兼容的考虑是不检测BOM的。因此在文本开头加入BOM时，shell会把它解释为某个普通字符，从而破坏了 <code>#!</code> 标示。另外还有一点就是，BOM本身违反了一个UNIX设计的常见原则，就是文档中存在的数据必须可见，而BOM不能作为可见字符被文本编辑器编辑。</p>
<p>注意，我们<strong>在使用文件编辑器保存文本文件时，应当保存为UTF-8 without BOM的格式</strong>，在UTF-8文件中放置 BOM 主要是微软的习惯。BOM是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。</p>
<h2 id="Windows中的编码问题"><a href="#Windows中的编码问题" class="headerlink" title="Windows中的编码问题"></a>Windows中的编码问题</h2><p>这一节所说的Windows中的编码，主要是指Windows自带的文本编辑器-记事本中的语境。</p>
<p>在记事本中：</p>
<ul>
<li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码[1]。</li>
<li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16[2]。</li>
<li>所谓的「UTF-8」指的是带 BOM 的 UTF-8[3]。</li>
</ul>
<p><strong>标注</strong></p>
<ul>
<li><p>[1] Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。</p>
</li>
<li><p>[2] 把带有 BOM 的小端序 UTF-16（即UTF-16LE）称作「Unicode」也是 Windows 的臭毛病。Windows 从 Windows 2000 开始就已经支持 surrogate pair 了，所以已经是 UTF-16 了，「UCS-2」这个说法已经不合适了。UCS-2 只能编码 BMP 范围内的字符，从 1996 年起就在 Unicode/ISO 标准中被 UTF-16 取代了（UTF-16 通过蛋疼的 surrogate pair 来编码超出 BMP 的字符）。都十多年了，求求大家别再误称了……</p>
</li>
<li><p>[3] 把带 BOM 的 UTF-8 称作「UTF-8」又是 Windows 的臭毛病。如果忽略 BOM，那么在 ASCII 范围内与 ASCII 一致。</p>
</li>
</ul>
<h2 id="Python3中的编码问题"><a href="#Python3中的编码问题" class="headerlink" title="Python3中的编码问题"></a>Python3中的编码问题</h2><p>廖雪峰老师说Python3中字符串使用Unicode编码，但正如我们前面所说的，现在说Unicode是一种编码是不合时的，准确来说，Python3中字符串用的是严格使用两个字节的UCS-2编码，即使是英文字母也使用两个字节。</p>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><p><strong>廖雪峰-Python3教程</strong></p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="external">字符串和编码</a></li>
</ul>
<p><strong>Python官方文档</strong></p>
<ul>
<li><a href="https://docs.python.org/3/c-api/unicode.html" target="_blank" rel="external">Unicode Objects and Codecs</a></li>
<li><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="external">Unicode HOWTO</a></li>
</ul>
<p><strong>知乎</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？</a></li>
<li><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">Unicode 和 UTF-8 有何区别？</a></li>
<li><a href="https://www.zhihu.com/question/20167122" target="_blank" rel="external">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a></li>
<li><a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a></li>
</ul>
<p><strong>Wikipedia</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Wide_character" target="_blank" rel="external">Wide character</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode#Mapping_and_encodings" target="_blank" rel="external">Unicode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Byte_order_mark" target="_blank" rel="external">Byte order mark</a></li>
<li><a href="https://en.wikipedia.org/wiki/Character_encoding#Code_unit" target="_blank" rel="external">Character encoding</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="external">Universal Coded Character Set</a></li>
</ul>
<p>最后，特别感谢知乎用户<a href="https://www.zhihu.com/people/lianghai" target="_blank" rel="external">梁海</a>、<a href="https://www.zhihu.com/people/chen-fu-zhou" target="_blank" rel="external">陈甫鸼</a>和<a href="https://www.zhihu.com/people/yu-yang-31-64" target="_blank" rel="external">于洋</a>，他们的回答都对我构建这篇文章很有帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何处理Hexo和MathJax的兼容问题]]></title>
      <url>http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天写文章写得正高兴，码Latex公式的时候突然发现无法渲染，经过一番推敲和实践，最终解决了这个问题，在这篇博文中简单记录一下，方便其他遇到同样问题的朋友们也能顺利解决。<strong>不想看解决思路的朋友也可以<a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#小结">跳到文章末尾直接看解决方案（Jump to the end to see sulution）</a></strong>。</p>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>先重现一下这个问题。在写文章的时候，我码了一个相当简单的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$$</div></pre></td></tr></table></figure>
<p>渲染出来却变成了（红框内变为了斜体）：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer1.png" alt="before"></p>
<a id="more"></a>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>琢磨了一下，MathJax支持是开了的，这么简单的公式都渲染不出，肯定不是MathJax要背的锅。简单地测试了一下，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125;$$</div></pre></td></tr></table></figure>
<p>这个公式是能work的，那到底是什么问题呢？回到前面的公式，细心观察一下，不难发现渲染之后<strong>下划线 <code>_</code> 被吞掉了</strong>，而<strong>两个下划线 <code>_</code> 之间的文本变为了斜体</strong>，这就很有意思了。</p>
<p>浏览一下网页源码，可以看到对应这一条公式的代码是：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer2.png" alt="before"></p>
<p>原来下划线被渲染成了 <code>&lt;em&gt;</code>，在HTML里这个tag是用于将文本准换为斜体进行强调的。为什么会产生这样的错误呢？其实，在Markdown语法中 <em>两个下划线之间的文本会被转换为斜体</em>，所以<strong>这个错误是由Markdown渲染器引起的</strong>。Markdown本身没有支持Latex，在渲染时正则匹配到两条下划线就会把下划线替换成了 <code>&lt;em&gt;</code>，于是到了MathJax渲染公式时就彻底懵了。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>意识到这个问题的本质后，带着疑问，我先来到Next主题的<a href="https://github.com/iissnan/hexo-theme-next/" target="_blank" rel="external">Github主页</a>，在<a href="https://github.com/iissnan/hexo-theme-next/issues?utf8=%E2%9C%93&amp;q=mathjax" target="_blank" rel="external">issue</a>里面搜索MathJax。很可惜，没有找到直接的答案，但是思路清晰了一些。<strong>Next不背这个锅</strong>，我们要做的是<strong>更换Hexo使用的Markdown渲染器</strong>。</p>
<p>接下来我又到Hexo的<a href="https://github.com/hexojs/hexo/" target="_blank" rel="external">Github主页</a>搜索相关的解决方案，在<a href="https://github.com/hexojs/hexo/issues/524" target="_blank" rel="external">issue #524</a> 中，有人提到了<strong>可以使用 rawblock 来解决</strong>，可是每次要写公式都得在公式前后加上 rawblock 来声明实在太烦了，对于公式大户来说简直要崩溃（想想之后要写机器学习的相关文章，一大堆公式证明，已经想手动再见了）。</p>
<p>另一个提出的解决方案是<strong>更换pandoc渲染器</strong>，pandoc大法固然好，但要下载安装完pandoc然后再装hexo插件实在是太重量级了.. 我只是想轻松愉悦地写写博客呀。当然，感兴趣的朋友也不妨去<a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="external">hexo-renderer-pandoc主页</a>看看。</p>
<p>有没有更好的方法呢？我在<a href="https://segmentfault.com/q/1010000003987383/a-1020000003987577/revision" target="_blank" rel="external">segmentfault</a>查到另一位朋友写的解决方案，可以<strong>使用 hexo-renderer-markdown-it 进行渲染</strong>，似乎是个不错的思路，在hexo-renderer-markdown-it的<a href="https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started" target="_blank" rel="external">文档</a>中可以看到操作相当简单：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-markdown-it --save</code></li>
</ol>
<p>两行命令即可完成，先卸载Hexo自带的Markdown解析器 hexo-renderer-marked 再安装 hexo-renderer-markdown-it 就可以了。安装完以后，先 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态网页，然后 <code>hexo s</code> 查看，这回公式能正常显示了：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/After_Change_Markdown_Renderer1.png" alt="after"></p>
<p>但是这是我又发现一个新的问题，使用 hexo-renderer-markdown-it 渲染之后，我原本为Markdown编写的<strong>TOC里的链接都失效了</strong>，而<strong>侧边栏的快速导航链接也都失效了</strong>。这怎么可以呢？文章写得短还好，鼠标滚轮滚一滚就好了。要是写得长那岂不就得浪费很多时间才能定位到自己想看的地方？这可不行！！！</p>
<p>继续查找更优的解决方案，Hexo有没有更好的Markdown渲染插件呢？有的，在<a href="https://hexo.io/plugins/" target="_blank" rel="external">Hexo主站的插件页</a>搜索关键字 Markdown，发现了 hexo-renderer-kramed 这个插件，打开它的<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">Github主页</a>，描述已经说得很清楚，作者fork了 hexo-renderer-marked 项目，并且只针对MathJax支持进行了改进，这正是我们需要的！！卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），然后安装 hexo-renderer-kramed：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>这下，不仅能正常使用TOC，也能完美地支持MathJax渲染了。至此，问题得到了解决。</p>
<p>P.S. 其实，这个问题就是因为Markdown渲染和MathJax渲染冲突造成的，除了换别的渲染器，<strong>直接修改渲染用的正则表达式</strong>也是一种解决思路，但是这个思路有一定风险，如果引起了别的bug而没有及时发现，自己又没有做好备份和记录，就需要浪费很多额外的时间来定位问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单来说，要让你的Hexo支持MathJax渲染公式，你只需要使用两条命令：<br>To fully support MathJax in your Hexo blog, you can simply use the following commands:</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>第一条命令用于卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），它是hexo自带的Markdown渲染引擎。<br>The first command uninstall Hexo’s default Markdown renderer.</p>
<p>第二条命令用于安装 hexo-renderer-kramed 插件，这个渲染插件针对MathJax支持进行了改进。安装完成后，重新生成博客就会惊喜地发现你的公式已经能够正常显示了。<br>The second command install new Markdown renderer which can support MathJax fully. After installation, you should regenerate your blog to see the changes.</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>作为一名编程人员，不屈服于bug，不妥协于简陋的solution是很重要的。除此之外，也要善于定位问题和解决问题，能够弄清楚出问题的地方，并且利用丰富的网络资源来解决问题。</p>
<p>最后，感谢开源和分享。</p>
<p>最后的最后，再码一条写在SVM笔记里的长公式检验一下吧：</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad  i=1,2,...,m\qquad(9)</script><p>完美~ The end.</p>
<p>补充一下评论中L同学的问题，关于行内代码，确实还存在一点问题，之后有时间会再研究一下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用推荐算法]]></title>
      <url>http://2wildkids.com/2016/10/04/%E5%B8%B8%E7%94%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这篇<a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247483811&amp;idx=1&amp;sn=fc3ee4ddfc4a8d6014a4cd90cdb5983c&amp;scene=4#wechat_redirect" target="_blank" rel="external">文章</a>首发在【阿里技术】这个微信公众号，内容上主要围绕电商中用到的一些推荐算法，参考了 Xavier Amatriain 在CMU的 Machine Learning 暑期学校上的讲授的内容。不仅有提到一些基础的推荐算法，也讲了一些推荐系统领域比较新的研究方向，个人认为是一篇不错的概括性文章，摘录在博客里，加入一点自己的理解。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC -->
<ul>
<li><a href="#推荐系统简介">推荐系统简介</a></li>
<li><a href="#传统的推荐算法">传统的推荐算法</a><ul>
<li><a href="#非个性化推荐：热度排行（popularity）">非个性化推荐：热度排行（Popularity）</a></li>
<li><a href="#协同过滤（collaborative-filtering）">协同过滤（Collaborative Filtering）</a></li>
<li><a href="#基于内容知识的推荐（content-basedknowledge-based）">基于内容/知识的推荐（Content-based/Knowledge-based）</a></li>
<li><a href="#混合方法（hybird-approaches）">混合方法（Hybird Approaches）</a></li>
</ul>
</li>
<li><a href="#推荐算法的最新研究">推荐算法的最新研究</a><ul>
<li><a href="#学习排序（learning-to-rank）">学习排序（Learning to Rank）</a></li>
<li><a href="#页面整体优化（page-optimization）">页面整体优化（Page Optimization）</a></li>
<li><a href="#情景推荐：张量分解分解机（factoriztion-machine）">情景推荐：张量分解/分解机（Factoriztion Machine）</a></li>
<li><a href="#深度学习（deep-learning）">深度学习（Deep Learning）</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image2.jpeg" alt="g2"></p>
<p>推荐系统本身就是为了解决信息过载这个问题而出现的，在互联网出现以后，人们在生活中所能获取到的消息呈爆炸性增长。从衣食住行再到其他一些更高端的需求，我们都有非常多的选择，但是要怎么在较短的时间内从这么多的选择里找到自己最感兴趣的那个呢？推荐系统解决的就是这样一个问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image3.jpeg" alt="g3"></p>
<p>事实上，<strong>解决信息过载的问题并不是只有推荐系统这一个手段</strong>。PC时代早期出现的门户网站是一种手段，帮助上网的人快速找到想要浏览的网站。而搜索引擎也是一种很好的办法，通过关键字来筛选出用户想要看的网页。但以上两种途径展示的内容对任意两个上网用户来说都是相同的。由于每个人的喜好总会有一部分和别人重叠，而一部分比较特殊，为了展示的内容能尽可能符合大多数人的期望，导航/搜索引擎只能给出重叠最多的部分，也即最流行的网站/网页，没有办法做到根据不同用户的喜好提供不同结果。推荐系统则致力于解决这一难点，实现千人千面的效果。</p>
<p>P.S. 事实上，目前在搜索引擎这个研究领域，已经有根据用户搜索习惯和搜索历史进行个性化结果展示的研究了，可以说是吸取了推荐系统的精髓进行改进的结果吧。随着计算机处理数据的能力上升，个性化将是未来的必然趋势。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image4.jpeg" alt="g4"></p>
<p>Netflix举办的百万美元竞赛绝对是推荐系统发展史上一个重要的标志，可以说从那以后，推荐系统的研究才开始真正地被重视，随后就是百花齐放，越来越多的算法和推荐架构被提出来了。</p>
<p>特别Mark一下<strong>推荐系统的未来——基于上下文的推荐</strong>，这个确实是很值得思考的。尽管目前关注推荐系统的研究已经不少了，但绝大部分都是使用协同过滤技术，或者把推荐视作一个二分类问题来解决的。有一个很明显的缺点就是它们都需要大量的标记数据才能实现准确的预测。还有一个问题就是，这里说的推荐并没有针对用户实际所处的环境来给出结果，只是从用户的历史记录和习惯来推测，给出他可能喜欢的其它商品，而<strong>没有关注用户是否真的有需求</strong>。<strong>怎么把我们从大量历史数据中学习到的知识应用到用户所处的具体场景中？</strong>这是一个等待研究的相当有价值的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image5.jpeg" alt="g5"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image6.jpeg" alt="g6"></p>
<p>这些指标都蛮有意思的，但是并不是都能通过离线测试来得出，比方说用户满意度、惊喜性等等，都是一些比较主观的东西，在这种情况下，怎么能够提高这些指标呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image7.jpeg" alt="g7"></p>
<p>这里列了几个比较传统的因素：相似的人越喜欢一件物品，那么用户就越有可能也喜欢它；用户对相似的物品越喜爱，那么也越有可能喜欢这一件物品；对这件物品的评论中赞赏的话越多，则用户也越有可能对这件物品感兴趣；用户和这件物品的历史交互行为越多，也意味着用户对这件物品越感兴趣…</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image8.jpeg" alt="g8"></p>
<p>虽然说我们做研究主要是针对推荐的算法，但在工业界里，一个真正的推荐产品，必须要有良好的用户界面，准确的产品定位，否则从一开始就输了，连用户数据都获取不到，自然也就没有所谓个性化的后话了。特别地，花在处理数据上的时间应该是最多的，因为从真实场景中收集到的数据往往都有很大的噪音，如果不经过处理就放进算法跑的话，算法再好也难以获得好的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image9.jpeg" alt="g9"></p>
<h2 id="传统的推荐算法"><a href="#传统的推荐算法" class="headerlink" title="传统的推荐算法"></a>传统的推荐算法</h2><h3 id="非个性化推荐：热度排行（Popularity）"><a href="#非个性化推荐：热度排行（Popularity）" class="headerlink" title="非个性化推荐：热度排行（Popularity）"></a>非个性化推荐：热度排行（Popularity）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image10.jpeg" alt="g10"></p>
<p>其实在没有电商的时候，传统的线下店铺就是采用热度排行的方式来增加销量的，因为能展示给客户的商品有限，所以只能选最热门的商品放在店铺里。</p>
<p>虽然这种做法可以避免新用户的冷启动窘境，因为我们不需要知道新用户是怎样的，只要知道大的趋势就可以了。但这样做对新的商品来说显然是致命的，因为热门的商品被展示得越多就越热门，长期占据热度榜，而新商品得不到被展示的机会，就只能烂在仓库里了。这个问题也被称为<strong>马太效应（The Matthew Effect）</strong>。</p>
<p>比较有意思的是这里指出除了单纯地考虑热度，<strong>在基于热度排行时还可以综合考虑一些其它因素</strong>。事实上，即使是如此强调个性化的今天，热度依然是影响用户做出购买决定的一个很重要的因素，所以在构建推荐系统时也要充分考虑到这一点。</p>
<h3 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h3><h4 id="Memory-based-方法"><a href="#Memory-based-方法" class="headerlink" title="Memory-based 方法"></a>Memory-based 方法</h4><p>Memory-based 方法又可以称为 <strong>neighborhood-based方法</strong>。可以简单分为User-based CF和Item-based CF两种思路。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image11.jpeg" alt="g11"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image12.jpeg" alt="g12"></p>
<p>注意一下Step3过滤这个步骤，比方说用户已经买过某一本书，如果再推荐他重复购买是不合理的。但是，对于一些可能会周期性购买的物品（如抽纸、沐浴露etc），我们要怎么处理呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image13.jpeg" alt="g13"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image14.jpeg" alt="g14"></p>
<p>可以说各有各好处吧，Item-based更流行除了准确性好之外，物品的变动相对用户较少也是一个很大的原因，这能够减少很多计算花费。但是相对地，Item-based可能没有办法很好地承担<strong>开拓用户的眼界</strong>这个功能，是不是真的这样呢？值得思考。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image15.jpeg" alt="g15"></p>
<p>这里提到的缺点是需要注意的，但<strong>并不是说协同过滤就必定有这些缺点</strong>，我们可以针对这些缺点对协同过滤进行改良。这里记录一下一些简单的思路：</p>
<ul>
<li><p>冷启动问题怎么解决呢？是否可以引入一些领域知识？或者引入额外的数据来源（社交、地点、时间etc）呢？如果引入了，又该怎么使用呢？</p>
</li>
<li><p>过去的行为真的决定现在吗？过去的行为有哪些特征是可以视为用户的特征的呢？有哪些特征可能只是干扰因素呢？</p>
</li>
<li><p>怎么才能引入小众偏好，让推荐系统更强调个性化呢？</p>
</li>
</ul>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image16.jpeg" alt="g16"></p>
<p>LSH是一个相当有意思的减少计算量的方法。协同过滤的一个最基本步骤就是计算相似性，而无论从用户的角度还是从物品的角度来看，维度都相当高，计算花费很大。而使用LSH进行映射后，既能保持相似关系不会发生太大的变化，又能降低维度，确实是一种很好的解决方案。不过<strong>要特别注意哈希函数的选择</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image17.jpeg" alt="g17"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image18.jpeg" alt="g18"></p>
<h4 id="Model-based方法"><a href="#Model-based方法" class="headerlink" title="Model-based方法"></a>Model-based方法</h4><p>基于模型的方法，用到的技术就比较多涉及到机器学习领域了。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image19.jpeg" alt="g19"></p>
<h5 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image20.jpeg" alt="g20"></p>
<p>关联规则挖掘其实跟买东西的场景是非常搭的，有兴趣的朋友不妨查查 “啤酒与尿布” 这个经典案例。</p>
<p>值得注意的是：我们<strong>从结果反推出的 “现象” 并不一定是事实</strong>，这其中有可能存在巧合的因素，所以我们一定要慎重地对待。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image21.jpeg" alt="g21"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image22.jpeg" alt="g22"></p>
<p>Mark一下这里产生悖论的原因：<strong>数据的不同分组之间基数差异很大</strong>，导致合并时产生了偏差。用上面的例子来说就是对顾客分组是，在职人员的数量要远多于大学生的数量，在把这两个分组合并为顾客来考虑时就会产生偏差。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image23.jpeg" alt="g23"></p>
<h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image24.jpeg" alt="g24"></p>
<p>事实上，我们并不一定要在同一个簇里面找推荐物品的候选集，完全可以基于簇之间来使用KNN，把最近邻的簇对应的物品集作为候选，这样做就有一定概率引入一些额外的物品，给用户带来惊喜了。当然，如何平衡好这一点和推荐的准确性是需要研究的。</p>
<h5 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image25.jpeg" alt="g25"></p>
<p>比方说把推荐看作一个二分类问题，预测用户是否购买/点击；把推荐看作一个回归问题，预测用户对推荐物品的评分。这样来看的话，很多有监督学习的机器学习技术都能被用上了。但是，如何获得大量独立同分布的训练数据会是一个很大的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image26.jpeg" alt="g26"></p>
<ul>
<li>如何应对评分矩阵的稀疏性？ —— 现实问题，用户接触到的商品仅占非常小的一部分，会进行反馈的就更少了</li>
<li>如何降低大规模矩阵计算的时间开销？ —— 决定能否满足实时性的需求</li>
</ul>
<p>图片中的两条式子可能有些模糊，它们分别是是：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}' \qquad(1)</script><p>和</p>
<script type="math/tex; mode=display">R_{m \times n} \approx U_{m \times k} S_{k \times k} V_{k \times n}' \qquad(2)</script><p>式（1）是标准的SVD矩阵分解，式（2）则是<strong>利用SVD技术进行低阶近似</strong>，也称为<strong>截断SVD（Truncated SVD）</strong>，它只取最大的k个奇异值，而k要远小于原矩阵的行数m和列数n，因此能够大大地降低计算开销。由于篇幅原因，这里就不科普SVD相关的知识了，详细内容可以check一下<a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank" rel="external">维基百科里对SVD的描述</a>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image27.jpeg" alt="g27"></p>
<p>Funk提出的这种矩阵分解算法在很大程度上弥补了标准SVD的不足，它不需要关注缺失值，而且计算复杂度也降低了很多。这种矩阵分解方法后来被Netflix Prize的冠军Koren称为<strong>Latent Factor Model（简称LFM）</strong>，也即后来大名鼎鼎的<strong>隐语义模型</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image28.jpeg" alt="g28"></p>
<p>加入偏置项是一种很直觉的想法，举一个简单的例子，对商品要求较高的用户通常会给出较低的评分，所以在满意程度同等时，他给出的评分可能比其他用户都要低。如果我们不排除这个影响的话，他的评分就会错误地拉低了商品的评价。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image29.jpeg" alt="g29"></p>
<p>更进一步地，我们还可以考虑用户的历史行为对评分的影响。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image30.jpeg" alt="g30"></p>
<p>向量化可以理解为对原事物表现形式的改变，不仅仅用于推荐系统领域，也是很多其他研究领域的基础。比方说自然语言处理，要理解对话，就先就要把对话的句子进行向量化，将句子分解为不同的单词，每个单词对应一个维度（最近Google翻译已经改进为以句子为单元了，使得翻译更加准确，不过由于我没有进行过自然语言处理相关的研究，所以不太清楚具体的情况）。</p>
<h5 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image31.jpeg" alt="g31"></p>
<p>Boltzmann机是全连接的一个网络，参数相当多，即使去除同同一层内的连接，变为RBM，参数依然很多。参数越多，自然拟合的能力就越强，所以RBM可以说是浅层学习（相对于深度学习的一个概念，毕竟RBM就只有两层神经元）中非常强大的一个模型。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image32.jpeg" alt="g32"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image33.jpeg" alt="g33"></p>
<p>Mark一下，<strong>一个用户一个RBM</strong>，也即为每个用户都训练一个RBM模型，这样开销固然很大，但私以为这样做要比协同过滤更加符合<strong>个性化</strong>的需求。除了开销大之外，这种方法还需要海量的训练数据，否则无法得到可以接受的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image34.jpeg" alt="g34"></p>
<p>自从深度学习火了之后，越来越多的研究者开始对其进行研究。在推荐系统领域也不例外，虽然RBM并不算“深”，但是可以帮助我们理解深度学习技术是如何应用到推荐系统领域的。我个人还不是太过了解深度学习，上面的PPT也不是讲得讲得很清楚（在推荐系统问题中应用的RBM是改良过的）。感兴趣的朋友不妨阅读一下腾讯数字音乐部智能推荐组编写的文章——<strong><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=417547354&amp;idx=1&amp;sn=1cda80702cff4f9d0f739f75d30eb773" target="_blank" rel="external">解密深度学习在智能推荐系统的实践与应用</a></strong>。</p>
<h5 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image35.jpeg" alt="g35"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image36.jpeg" alt="g36"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image37.jpeg" alt="g37"></p>
<p>Mark一下：<strong>图模型可以发现协同过滤发现不来的弱相似性，给推荐带来一定的惊喜。</strong></p>
<h3 id="基于内容-知识的推荐（Content-based-Knowledge-based）"><a href="#基于内容-知识的推荐（Content-based-Knowledge-based）" class="headerlink" title="基于内容/知识的推荐（Content-based/Knowledge-based）"></a>基于内容/知识的推荐（Content-based/Knowledge-based）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image38.jpeg" alt="g38"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image39.jpeg" alt="g39"></p>
<h3 id="混合方法（Hybird-Approaches）"><a href="#混合方法（Hybird-Approaches）" class="headerlink" title="混合方法（Hybird Approaches）"></a>混合方法（Hybird Approaches）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image40.jpeg" alt="g40"></p>
<p>所谓混合方法，指的是将多个算法集成在一起来完成任务，更详细的讲解可以查询集成学习相关的内容了解。</p>
<h2 id="推荐算法的最新研究"><a href="#推荐算法的最新研究" class="headerlink" title="推荐算法的最新研究"></a>推荐算法的最新研究</h2><h3 id="学习排序（Learning-to-Rank）"><a href="#学习排序（Learning-to-Rank）" class="headerlink" title="学习排序（Learning to Rank）"></a>学习排序（Learning to Rank）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image41.jpeg" alt="g41"></p>
<p>对NDCG和MRR这两种排序评价准则感兴趣的朋友可以浏览<a href="http://www.cnblogs.com/startover/archive/2013/06/18/3141616.html" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="页面整体优化（Page-Optimization）"><a href="#页面整体优化（Page-Optimization）" class="headerlink" title="页面整体优化（Page Optimization）"></a>页面整体优化（Page Optimization）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image42.jpeg" alt="g42"></p>
<h3 id="情景推荐：张量分解-分解机（Factoriztion-Machine）"><a href="#情景推荐：张量分解-分解机（Factoriztion-Machine）" class="headerlink" title="情景推荐：张量分解/分解机（Factoriztion Machine）"></a>情景推荐：张量分解/分解机（Factoriztion Machine）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image43.jpeg" alt="g43"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image44.jpeg" alt="g44"></p>
<h3 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image45.jpeg" alt="g45"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image46.jpeg" alt="g46"></p>
<p>Mark一下：<strong>仅仅利用行为数据的RNN可能效果有限，可以结合更多数据来源。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image47.jpeg" alt="g47"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image48.jpeg" alt="g48"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image49.jpeg" alt="g49"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction]]></title>
      <url>http://2wildkids.com/2016/10/03/Introduction/</url>
      <content type="html"><![CDATA[<p>自从知道了Github Pages和Hexo这对绝佳搭配之后，一直心心念念地想做一个自己的独立博客。虽然从阅读量来说，肯定还是在CSDN、简书或者知乎专栏发布会有更多被阅读的机会，但总感觉或多或少地有些阻碍，不能随心所欲地写作。之前倒是一直把Github当作一个博客，天天把markdown写的笔记contribute到仓库里面，不过鉴于Github支持的是源生的markdown，而markdown本身是不支持latex公式的，所以多少有点遗憾。Anyway，终于用Github Pages+Hexo搭建了这个博客，有MathJax和七牛图床的支持，终于可以随心所欲地写作了~</p>
<p>鉴于大四一直在忙自己的项目和论文，所以少有时间做些真正原创的技术分享，前期主要打算在这个博客做一些阅读笔记。暑假一直在读周志华博士写的《机器学习》一书，把本科生课程部分（书的前半部分）的笔记基本都整理好了，放在了Github上面，但这显然是不够的，想做研究当然还是得往更深的技术里钻，所以书的后半部分还要继续细读精读。另一方面，这本书比较新，所以习题部分目前网上还没有比较好的解答。书中的公式有些比较复杂，对工程人员来说理解可能有不少困难，所以我也希望可以用课余的时间认真地把这本书的习题过一遍，如何对公式进行向量化，如何融入到实际的项目中，用代码进行实现。希望可以分享出来，为开源做点贡献，为其他书友带来一点帮助，自己应该也会有不少的收获。之后会逐渐把笔记和解答迁移到这个博客里，需要花费的时间也比较多，不过贵在坚持。</p>
<a id="more"></a>
<p>因为个人研究方向主攻数据挖掘的推荐系统领域，所以阅读的书籍和文章也比较多涉及这个方面。而中文书籍中，个人认为推荐系统领域最好的一本入门书籍是项亮的《推荐系统实践》，之后也会在这个博客中更新阅读这本书的笔记。另外也会搬运一些机器学习和数据挖掘比较好的文章到这个博客中，加入一些自己的理解，算是记录自己成长的轨迹吧，虽然不是技术原创，但在阅读和学习的过程中，记录下自己的见解，以后再看也会有很大的帮助。</p>
<p>另外，我个人也非常喜欢Python这门编程语言，在数据科学方面的研究中，Python是一个不可多得的利器，所以要是遇到好的Python相关的文章，也会收录到这个博客中。再有就是linux和Hadoop、Spark方面的一些笔记了，要做大数据总是免不了碰到这些东西。虽然工具年年变，说不定以后Spark就不像现在这么火了，但是好的工具总是有研究价值的，好好学的话还是会有不错的收获。</p>
<p>最后，也是一点小寄望吧，希望以后可以能逐渐有多一些技术原创，多一些项目分享，目前就先脚踏实地地积累知识吧。</p>
<p>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://2wildkids.com/2016/09/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Test-MathJAX"><a href="#Test-MathJAX" class="headerlink" title="Test MathJAX"></a>Test MathJAX</h3><script type="math/tex; mode=display">a = \frac{1}{5}</script><p>something is equals to $\alpha 5$.</p>
]]></content>
    </entry>
    
  
  
</search>
