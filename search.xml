<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python学习笔记-12常用内建模块（下）]]></title>
      <url>http://2wildkids.com/2017/02/05/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#itertools">itertools</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#count">count</a></li>
<li><a href="#cycle">cycle</a></li>
<li><a href="#repeat">repeat</a></li>
<li><a href="#takewhile">takewhile</a></li>
<li><a href="#chain">chain</a></li>
<li><a href="#groupby">groupby</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#contextlib">contextlib</a><ul>
<li><a href="#引言">引言</a></li>
<li><a href="#上下文管理的实现">上下文管理的实现</a></li>
<li><a href="#contextmanager装饰器">@contextmanager装饰器</a></li>
<li><a href="#closing函数">closing函数</a></li>
</ul>
</li>
<li><a href="#xml">XML</a><ul>
<li><a href="#简介-1">简介</a></li>
<li><a href="#dom-vs-sax">DOM vs SAX</a></li>
<li><a href="#在python中使用sax">在Python中使用SAX</a></li>
<li><a href="#小结-1">小结</a></li>
<li><a href="#练习">练习</a></li>
</ul>
</li>
<li><a href="#htmlparser">HTMLParser</a><ul>
<li><a href="#简介-2">简介</a></li>
<li><a href="#html字符实体">HTML字符实体</a></li>
<li><a href="#使用htmlparser解析html">使用HTMLParser解析HTML</a></li>
<li><a href="#小结-2">小结</a></li>
<li><a href="#练习-1">练习</a></li>
</ul>
</li>
<li><a href="#urllib">urllib</a><ul>
<li><a href="#简介-3">简介</a></li>
<li><a href="#get">Get</a></li>
<li><a href="#post">Post</a></li>
<li><a href="#小结-3">小结</a></li>
<li><a href="#练习-2">练习</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>Python之所以自称 <strong>“batteries included”</strong>，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p>
<p>本章将介绍一些常用的内建模块。</p>
<h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Python的内建模块 <code>itertools</code> 提供了非常有用的用于操作迭代对象的函数。我们首先看看 <code>itertools</code> 提供的几个“无限”迭代器：</p>
<hr>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count()</code> 返回的是一个无限的迭代器，默认初始值为0，步长为1（按Python的传参规则，只传入一个参数时，传入的参数被视作初始值）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> natuals:</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>上述代码会打印出自然数序列，但问题是它根本停不下来，只能按 <code>Ctrl+C</code> 退出。</p>
<hr>
<h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><p><code>cycle()</code> 会把传入的<strong>一个序列</strong>无限重复下去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cs = itertools.cycle(<span class="string">'ABC'</span>) <span class="comment"># 注意字符串也是序列的一种，还可以是列表、元组等</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> cs:</div><div class="line"><span class="meta">... </span>    print(c)</div><div class="line">...</div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="string">'C'</span></div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="string">'C'</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>同样停不下来。</p>
<hr>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat()</code> 负责把<strong>一个元素</strong>无限重复下去，不过 <code>repeat()</code> 提供了第二个参数，用于限定重复的次数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ns = itertools.repeat(<span class="string">'A'</span>, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> ns:</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line">A</div><div class="line">A</div><div class="line">A</div></pre></td></tr></table></figure>
<hr>
<h3 id="takewhile"><a href="#takewhile" class="headerlink" title="takewhile"></a>takewhile</h3><p>前面介绍了几种产生“无限”迭代器的方法，有没有办法对它们进行控制呢？有的~我们可以通过 <code>takewhile()</code>等函数，根据条件判断来截取出有限的序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ns = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt;= <span class="number">10</span>, natuals)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(ns)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>这里我们只截取序列中小于等于10的数，所以迭代器产生的数不符合该条件时就会停止迭代，也就不会无限地排列下去了。</p>
<p>除了 <code>takewhile()</code> 之外，<code>itertools</code> 还提供了一些非常有用的迭代器操作函数，在后面几个小节中会进行介绍。</p>
<hr>
<h3 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h3><p><code>chain()</code> 可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.chain(<span class="string">'ABC'</span>, <span class="string">'XYZ'</span>):</div><div class="line"><span class="meta">... </span>    print(c)</div><div class="line">...</div><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line">X</div><div class="line">Y</div><div class="line">Z</div></pre></td></tr></table></figure>
<hr>
<h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h3><p><code>groupby()</code> 可以把迭代器中<strong>相邻的重复元素</strong>挑出来放在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">'AAABBBCCAAA'</span>):</div><div class="line"><span class="meta">... </span>    print(key, list(group))</div><div class="line">...</div><div class="line">A [<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</div><div class="line">B [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]</div><div class="line">C [<span class="string">'C'</span>, <span class="string">'C'</span>]</div><div class="line">A [<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</div></pre></td></tr></table></figure>
<p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是同一组的，而函数返回值将作为该组的key。如果我们想忽略大小写来分组，可以让元素 <code>&#39;A&#39;</code> 和 <code>&#39;a&#39;</code> 都返回相同的key：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">'AaaBBbcCAAa'</span>, <span class="keyword">lambda</span> c: c.upper()):</div><div class="line"><span class="meta">... </span>    print(key, list(group))</div><div class="line">...</div><div class="line">A [<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</div><div class="line">B [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'b'</span>]</div><div class="line">C [<span class="string">'c'</span>, <span class="string">'C'</span>]</div><div class="line">A [<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>itertools</code> 模块提供的全部是处理迭代功能的函数，它们的返回值不是 <code>list</code>，而是 <code>Iterator</code>，也即它们的值不是立刻计算出放在内存中的，只有进行迭代时（例如使用 <code>for</code> 循环）才会被真正计算出来。</p>
<hr>
<p><br></p>
<h2 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在Python中，<strong>读写文件要注意使用完毕后必须进行关闭</strong>（文件对象占用大量资源并且同一时间操作系统只能打开有限数量的文件）。在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/09IO%E7%BC%96%E7%A8%8B.md" target="_blank" rel="external">09IO编程</a>中，已经介绍了利用 <code>try...finally</code> 机制关闭文件资源的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</div><div class="line">    f.read()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">if</span> f:</div><div class="line">        f.close()</div></pre></td></tr></table></figure>
<p>但是，写 <code>try...finally</code> 非常繁琐，所以后续又介绍了使用 <code>with</code> 语句的方法。<code>with</code> 语句允许我们非常方便地使用资源，而不必担心资源没有关闭。使用 <code>with</code> 语句改写后，上面的代码就可以简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.read()</div></pre></td></tr></table></figure>
<p>事实上，并不是只有 <code>open()</code> 函数返回的文件对象才能使用 <code>with</code> 语句。<strong>任何对象，只要正确实现了上下文管理，就可以用于 <code>with</code> 语句</strong>。</p>
<hr>
<h3 id="上下文管理的实现"><a href="#上下文管理的实现" class="headerlink" title="上下文管理的实现"></a>上下文管理的实现</h3><p>上下文管理是通过 <code>__enter__</code> 和 <code>__exit__</code> 这两个方法实现的。下面的类就实现了这两个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Begin'</span>)</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></div><div class="line">        <span class="keyword">if</span> exc_type:</div><div class="line">            print(<span class="string">'Error'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'End'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Query info about %s...'</span> % self.name)</div></pre></td></tr></table></figure>
<p>这样我们就可以把自己写的资源对象用于 <code>with</code> 语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> Query(<span class="string">'Bob'</span>) <span class="keyword">as</span> q:</div><div class="line">    q.query()</div></pre></td></tr></table></figure>
<hr>
<h3 id="contextmanager装饰器"><a href="#contextmanager装饰器" class="headerlink" title="@contextmanager装饰器"></a>@contextmanager装饰器</h3><p>编写 <code>__enter__</code> 和 <code>__exit__</code> 还是太繁琐了，有没有更简单的办法呢？有！Python的标准库 <code>contextlib</code> 提供了更简单的写法，借助它，上面的代码可以改写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Query info about %s...'</span> % self.name)</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_query</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Begin'</span>)</div><div class="line">    q = Query(name)</div><div class="line">    <span class="keyword">yield</span> q</div><div class="line">    print(<span class="string">'End'</span>)</div></pre></td></tr></table></figure>
<p>简单解析一下，我们定义一个简单的 <code>Query</code> 类，只有一个 <code>query()</code> 方法。同时我们定义了一个 <code>create_query()</code> 函数，由于这个函数包含 <code>yield</code> 关键字，所以实际上它是一个生成器。不过这个生成器只生成和抛出一个 <code>Query</code> 类的对象。</p>
<p><code>@contextmanager</code> 这个装饰器<strong>接收一个生成器，并为生成器抛出的对象添加上下文管理的功能</strong>。这样 <code>with</code> 语句就可以正常地工作了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> create_query(<span class="string">'Bob'</span>) <span class="keyword">as</span> q:</div><div class="line">    q.query()</div></pre></td></tr></table></figure>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用 <code>@contextmanager</code> 实现。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"&lt;%s&gt;"</span> % name)</div><div class="line">    <span class="keyword">yield</span></div><div class="line">    print(<span class="string">"&lt;/%s&gt;"</span> % name)</div><div class="line"></div><div class="line"><span class="keyword">with</span> tag(<span class="string">"h1"</span>):</div><div class="line">    print(<span class="string">"hello"</span>)</div><div class="line">    print(<span class="string">"world"</span>)</div></pre></td></tr></table></figure>
<p>上述代码执行结果为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></div><div class="line">hello</div><div class="line">world</div><div class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure>
<p>代码的执行顺序是：</p>
<ul>
<li><code>with</code> 语句首先执行 <code>yield</code> 前面的语句，因此打印出 <code>&lt;h1&gt;</code>；</li>
<li><code>yield</code> 之后会跳出生成器（<code>tag()</code> 函数），执行 <code>with</code> 语句内部的所有语句，因此打印出 <code>hello</code> 和 <code>world</code>；</li>
<li>执行完 <code>with</code> 语句内部的所有语句继续回到生成器；</li>
<li>执行 <code>yield</code> 后面的语句，打印出 <code>&lt;/h1&gt;</code>；</li>
<li>此时生成器所有语句执行完毕，不再生成，结束上下文。</li>
</ul>
<p>借助 <code>@contextmanager</code> 装饰器，我们能够更加方便地实现上下文管理。</p>
<hr>
<h3 id="closing函数"><a href="#closing函数" class="headerlink" title="closing函数"></a>closing函数</h3><p>前面一节介绍了如何为一个对象实现上下文管理功能，使得它能被作用于 <code>with</code> 语句。但是，得自己编写一个生成器还是很麻烦！有没有更更方便的办法呢？有！我们可以用 <code>closing()</code> 方法！</p>
<p><code>closing()</code> 的本质如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">closing</span><span class="params">(thing)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">yield</span> thing</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        thing.close()</div></pre></td></tr></table></figure>
<p>其实它就是一个经过 <code>@contextmanager</code> 装饰的生成器，它的作用就是把任意对象变为上下文对象，使其支持 <code>with</code> 语句。</p>
<p>再改写一次上面 <code>Query</code> 的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Query info about %s...'</span> % self.name)</div><div class="line"></div><div class="line"><span class="keyword">with</span> closing(Query(<span class="string">'Bob'</span>)) <span class="keyword">as</span> q:</div><div class="line">    q.query()</div></pre></td></tr></table></figure>
<p>这次更加简单了~</p>
<p><code>@contextlib</code> 还有一些其他装饰器，可以帮助我们编写更简洁的代码。</p>
<hr>
<p><br></p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍然有很多地方会用到XML，所以我们有必要了解如何在Python中如何处理XML。</p>
<hr>
<h3 id="DOM-vs-SAX"><a href="#DOM-vs-SAX" class="headerlink" title="DOM vs SAX"></a>DOM vs SAX</h3><p>一般来说，处理XML有两种方法，即DOM和SAX：</p>
<ul>
<li>DOM会先把整个XML读入内存，然后解析为树，因此DOM占用的内存大，解析慢。优点是可以任意遍历树的节点。</li>
<li>SAX则是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</li>
</ul>
<p><strong>正常情况下，优先考虑SAX，因为DOM实在太占内存</strong>。</p>
<hr>
<h3 id="在Python中使用SAX"><a href="#在Python中使用SAX" class="headerlink" title="在Python中使用SAX"></a>在Python中使用SAX</h3><p>在Python中使用SAX解析XML非常简洁，通常我们需要关心3个事件：<code>start_element</code>，<code>end_element</code> 和 <code>char_data</code>，准备好处理这3个事件的函数后就可以解析XML了。那么这些事件到底是什么意思呢？举个例子，当SAX解析器读到一个节点时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>python<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>会产生3个事件：</p>
<ul>
<li><code>start_element</code> 事件：读取 <code>&lt;a href=&quot;/&quot;&gt;</code> 时；</li>
<li><code>char_data</code> 事件：读取 <code>python</code> 时；</li>
<li><code>end_element</code> 事件：读取 <code>&lt;/a&gt;</code> 时。</li>
</ul>
<p>首先实现好处理这3个事件的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_element</span><span class="params">(name, attrs)</span>:</span></div><div class="line">    print(<span class="string">'Start element:'</span>, name, <span class="string">'with attributes:'</span>, attrs)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">end_element</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'End element:'</span>, name)</div><div class="line"></div><div class="line"><span class="comment"># 使用repr()函数可以将字符串转换为可打印的表示方式</span></div><div class="line"><span class="comment"># 这样就能更清楚地观察到空白字符了</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">char_data</span><span class="params">(data)</span>:</span></div><div class="line">    print(<span class="string">'Character data:'</span>, repr(data))</div></pre></td></tr></table></figure>
<p>然后创建解析器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = ParserCreate()</div><div class="line">p.StartElementHandler = start_element</div><div class="line">p.EndElementHandler = end_element</div><div class="line">p.CharacterDataHandler = char_data</div></pre></td></tr></table></figure>
<p>尝试解析一个XML字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">xml = <span class="string">r'''&lt;?xml version="1.0"?&gt;</span></div><div class="line">&lt;ol&gt;</div><div class="line">    &lt;li&gt;&lt;a href="/python"&gt;Python&lt;/a&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;a href="/ruby"&gt;Ruby&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;/ol&gt;</div><div class="line">'''</div><div class="line"></div><div class="line">print(p.Parse(xml))</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Start element: ol <span class="keyword">with</span> attributes: &#123;&#125;</div><div class="line">Character data: <span class="string">'\n'</span></div><div class="line">Character data: <span class="string">'    '</span></div><div class="line">Start element: li <span class="keyword">with</span> attributes: &#123;&#125;</div><div class="line">Start element: a <span class="keyword">with</span> attributes: &#123;<span class="string">'href'</span>: <span class="string">'/python'</span>&#125;</div><div class="line">Character data: <span class="string">'Python'</span></div><div class="line">End element: a</div><div class="line">End element: li</div><div class="line">Character data: <span class="string">'\n'</span></div><div class="line">Character data: <span class="string">'    '</span></div><div class="line">Start element: li <span class="keyword">with</span> attributes: &#123;&#125;</div><div class="line">Start element: a <span class="keyword">with</span> attributes: &#123;<span class="string">'href'</span>: <span class="string">'/ruby'</span>&#125;</div><div class="line">Character data: <span class="string">'Ruby'</span></div><div class="line">End element: a</div><div class="line">End element: li</div><div class="line">Character data: <span class="string">'\n'</span></div><div class="line">End element: ol</div></pre></td></tr></table></figure>
<p><strong>注意，遇到换行符之后，即使后续还有其他内容，<code>char_data</code> 事件也会结束再被触发</strong>。因此，读取一大段文本时，<code>CharacterDataHandler</code> 可能会被多次调用，如果我们想要将文本放在一起输出而非分开输出，就要先保存下来，在 <code>EndElementHandler</code> 中再进行合并。</p>
<p>除了解析XML外，我们要如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也最有效的生成XML的方法就是拼接字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line">L.append(<span class="string">r'&lt;?xml version="1.0"?&gt;'</span>)</div><div class="line">L.append(<span class="string">r'&lt;root&gt;'</span>)</div><div class="line">L.append(encode(<span class="string">'some &amp; data'</span>))</div><div class="line">L.append(<span class="string">r'&lt;/root&gt;'</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">''</span>.join(L)</div></pre></td></tr></table></figure>
<p>注意，在使用XML字符串时，我们最好<strong>使用 <code>r</code> 表示该字符串不进行转义，三引号表示保留换行</strong>，从而避免一些不必要的错误和麻烦。</p>
<p>如果要生成复杂的XML呢？这时建议不要用XML，而是改成用JSON。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>解析XML时，注意找出自己感兴趣的节点，响应事件时，可以先把节点中的数据保存起来，等待解析完毕后，再进行处理。对这一章所用模块知识感兴趣的话可以查看<a href="https://docs.python.org/3/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="external">官方文档</a>。此外，觉得自带的XML库不够给力的话可以使用更为强大的<strong>第三方库<a href="http://lxml.de/" target="_blank" rel="external">lxml</a></strong>。</p>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>编写程序使用SAX解析<a href="http://weather.yahooapis.com/forecastrss?u=c&amp;w=2151330" target="_blank" rel="external">Yahoo天气RSS</a>的XML格式天气预报，获取地点、当天天气和次日天气：</p>
</blockquote>
<p>由于现在Yahoo天气已经不再提供这个RSS服务了，所以链接已经失效了。这里我们直接解析一个廖老师提供好的XML字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">data = <span class="string">r'''&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;</span></div><div class="line">&lt;rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"&gt;</div><div class="line">    &lt;channel&gt;</div><div class="line">        &lt;title&gt;Yahoo! Weather - Beijing, CN&lt;/title&gt;</div><div class="line">        &lt;lastBuildDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/lastBuildDate&gt;</div><div class="line">        &lt;yweather:location city="Beijing" region="" country="China"/&gt;</div><div class="line">        &lt;yweather:units temperature="C" distance="km" pressure="mb" speed="km/h"/&gt;</div><div class="line">        &lt;yweather:wind chill="28" direction="180" speed="14.48" /&gt;</div><div class="line">        &lt;yweather:atmosphere humidity="53" visibility="2.61" pressure="1006.1" rising="0" /&gt;</div><div class="line">        &lt;yweather:astronomy sunrise="4:51 am" sunset="7:32 pm"/&gt;</div><div class="line">        &lt;item&gt;</div><div class="line">            &lt;geo:lat&gt;39.91&lt;/geo:lat&gt;</div><div class="line">            &lt;geo:long&gt;116.39&lt;/geo:long&gt;</div><div class="line">            &lt;pubDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/pubDate&gt;</div><div class="line">            &lt;yweather:condition text="Haze" code="21" temp="28" date="Wed, 27 May 2015 11:00 am CST" /&gt;</div><div class="line">            &lt;yweather:forecast day="Wed" date="27 May 2015" low="20" high="33" text="Partly Cloudy" code="30" /&gt;</div><div class="line">            &lt;yweather:forecast day="Thu" date="28 May 2015" low="21" high="34" text="Sunny" code="32" /&gt;</div><div class="line">            &lt;yweather:forecast day="Fri" date="29 May 2015" low="18" high="25" text="AM Showers" code="39" /&gt;</div><div class="line">            &lt;yweather:forecast day="Sat" date="30 May 2015" low="18" high="32" text="Sunny" code="32" /&gt;</div><div class="line">            &lt;yweather:forecast day="Sun" date="31 May 2015" low="20" high="37" text="Sunny" code="32" /&gt;</div><div class="line">        &lt;/item&gt;</div><div class="line">    &lt;/channel&gt;</div><div class="line">&lt;/rss&gt;</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>我们需要的信息有三样，分别是地点、当天天气和次日天气。在这段XML中，地点可以从 <code>yweather:location</code> 标签的 <code>city</code> 属性和 <code>country</code> 属性中获得。当天天气从第一个 <code>yweather:forecast</code> 标签的 <code>text</code>、<code>low</code> 和 <code>high</code> 这三个属性获得。次日天气则在第二个 <code>yweather:forecast</code> 标签中。并且注意到，我们只需要编写处理 <code>start_element</code> 事件的函数就可以取出所有这些信息了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherSaxHandler</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.result = dict()</div><div class="line">        self.count = <span class="number">0</span></div><div class="line">        self.result[<span class="string">'forecast'</span>] = dict()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_element</span><span class="params">(self, name, attrs)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'yweather:location'</span>:</div><div class="line">            self.result[<span class="string">'city'</span>] = attrs[<span class="string">'city'</span>]</div><div class="line">            self.result[<span class="string">'country'</span>] = attrs[<span class="string">'country'</span>]</div><div class="line">        <span class="keyword">elif</span> name == <span class="string">'yweather:forecast'</span>:</div><div class="line">            <span class="keyword">if</span> self.count == <span class="number">0</span>:</div><div class="line">                self.result[<span class="string">'forecast'</span>][<span class="string">'today'</span>] = attrs</div><div class="line">                self.count += <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> self.count == <span class="number">1</span>:</div><div class="line">                self.result[<span class="string">'forecast'</span>][<span class="string">'tomorrow'</span>] = attrs</div><div class="line">                self.count += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_weather</span><span class="params">(data)</span>:</span></div><div class="line"></div><div class="line">    handler = WeatherSaxHandler()</div><div class="line">    p = ParserCreate()</div><div class="line">    p.StartElementHandler = handler.start_element</div><div class="line">    p.Parse(data)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'city'</span>: handler.result[<span class="string">'city'</span>],</div><div class="line">        <span class="string">'country'</span>: handler.result[<span class="string">'country'</span>],</div><div class="line">        <span class="string">'today'</span>: &#123;</div><div class="line">            <span class="string">'text'</span>: handler.result[<span class="string">'forecast'</span>][<span class="string">'today'</span>][<span class="string">'text'</span>],</div><div class="line">            <span class="string">'low'</span>: int(handler.result[<span class="string">'forecast'</span>][<span class="string">'today'</span>][<span class="string">'low'</span>]),</div><div class="line">            <span class="string">'high'</span>: int(handler.result[<span class="string">'forecast'</span>][<span class="string">'today'</span>][<span class="string">'high'</span>])</div><div class="line">        &#125;,</div><div class="line">        <span class="string">'tomorrow'</span>: &#123;</div><div class="line">            <span class="string">'text'</span>: handler.result[<span class="string">'forecast'</span>][<span class="string">'tomorrow'</span>][<span class="string">'text'</span>],</div><div class="line">            <span class="string">'low'</span>: int(handler.result[<span class="string">'forecast'</span>][<span class="string">'tomorrow'</span>][<span class="string">'low'</span>]),</div><div class="line">            <span class="string">'high'</span>: int(handler.result[<span class="string">'forecast'</span>][<span class="string">'tomorrow'</span>][<span class="string">'high'</span>])</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 测试:</span></div><div class="line"></div><div class="line">weather = parse_weather(data)</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'city'</span>] == <span class="string">'Beijing'</span>, weather[<span class="string">'city'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'country'</span>] == <span class="string">'China'</span>, weather[<span class="string">'country'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'today'</span>][<span class="string">'text'</span>] == <span class="string">'Partly Cloudy'</span>, weather[<span class="string">'today'</span>][<span class="string">'text'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'today'</span>][<span class="string">'low'</span>] == <span class="number">20</span>, weather[<span class="string">'today'</span>][<span class="string">'low'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'today'</span>][<span class="string">'high'</span>] == <span class="number">33</span>, weather[<span class="string">'today'</span>][<span class="string">'high'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'tomorrow'</span>][<span class="string">'text'</span>] == <span class="string">'Sunny'</span>, weather[<span class="string">'tomorrow'</span>][<span class="string">'text'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'tomorrow'</span>][<span class="string">'low'</span>] == <span class="number">21</span>, weather[<span class="string">'tomorrow'</span>][<span class="string">'low'</span>]</div><div class="line"><span class="keyword">assert</span> weather[<span class="string">'tomorrow'</span>][<span class="string">'high'</span>] == <span class="number">34</span>, weather[<span class="string">'tomorrow'</span>][<span class="string">'high'</span>]</div><div class="line">print(<span class="string">'Weather:'</span>, str(weather))</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>
<p>假设第一步已经完成了，第二步我们应该如何解析HTML呢？</p>
<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p>
<p>好在Python提供了 <code>HTMLParser</code> 模块帮助我们解析HTML，非常方便，只需简单几行代码即可完成。</p>
<hr>
<h3 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h3><p>在学习 <code>HTMLParser</code> 之前，我们需要首先了解一下HTML需要注意的地方。<strong>在HTML中，某些字符是预留的</strong>。<br>在HTML中不能使用小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），这是因为浏览器会误认为它们是标签符号。<br>如果希望正确地显示预留字符，我们必须在HTML的源代码中使用<strong><a href="http://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="external">字符实体（character entities）</a></strong>。</p>
<p>具体来说，常用的字符实体如下：</p>
<table class="dataintable">
    <tbody><tr>
      <th style="width:20%">显示结果</th>
      <th style="width:20%">描述</th>
      <th style="width:30%">实体名称</th>
      <th style="width:30%">实体编号</th>
    </tr>

    <tr>
      <td>&nbsp;</td>
      <td>空格</td>
      <td>&amp;nbsp;</td>
      <td>&amp;#160;</td>
    </tr>

    <tr>
      <td>&lt;</td>
      <td>小于号</td>
      <td>&amp;lt;</td>
      <td>&amp;#60;</td>
    </tr>

    <tr>
      <td>&gt;</td>
      <td>大于号</td>
      <td>&amp;gt;</td>
      <td>&amp;#62;</td>
    </tr>

    <tr>
      <td>&amp;</td>
      <td>和号</td>
      <td>&amp;amp;</td>
      <td>&amp;#38;</td>
    </tr>

    <tr>
      <td>"</td>
      <td>引号</td>
      <td>&amp;quot;</td>
      <td>&amp;#34;</td>
    </tr>

    <tr>
      <td>'</td>
      <td>撇号&nbsp;</td>
      <td>&amp;apos; (IE不支持)</td>
      <td>&amp;#39;</td>
    </tr>

    <tr>
      <td>￠</td>
      <td>分（cent）</td>
      <td>&amp;cent;</td>
      <td>&amp;#162;</td>
    </tr>

    <tr>
      <td>£</td>
      <td>镑（pound）</td>
      <td>&amp;pound;</td>
      <td>&amp;#163;</td>
    </tr>

    <tr>
      <td>¥</td>
      <td>元（yen）</td>
      <td>&amp;yen;</td>
      <td>&amp;#165;</td>
    </tr>

    <tr>
      <td>€</td>
      <td>欧元（euro）</td>
      <td>&amp;euro;</td>
      <td>&amp;#8364;</td>
    </tr>

    <tr>
      <td>§</td>
      <td>小节</td>
      <td>&amp;sect;</td>
      <td>&amp;#167;</td>
    </tr>

    <tr>
      <td>©</td>
      <td>版权（copyright）</td>
      <td>&amp;copy;</td>
      <td>&amp;#169;</td>
    </tr>

    <tr>
      <td>®</td>
      <td>注册商标</td>
      <td>&amp;reg;</td>
      <td>&amp;#174;</td>
    </tr>

    <tr>
      <td>™</td>
      <td>商标</td>
      <td>&amp;trade;</td>
      <td>&amp;#8482;</td>
    </tr>

    <tr>
      <td>×</td>
      <td>乘号</td>
      <td>&amp;times;</td>
      <td>&amp;#215;</td>
    </tr>

    <tr>
      <td>÷</td>
      <td>除号</td>
      <td>&amp;divide;</td>
      <td>&amp;#247;</td>
    </tr>
</tbody></table>

<p>完整的字符实体表可以查看W3School的<a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="external">HTML 实体符号参考手册</a>。</p>
<p>注意到表格中有<strong>实体名称</strong>和<strong>实体编号</strong>两种形式，在编写HTML代码时这两种形式都是可以使用的。即字符实体既可以写作 <code>&amp;entity_name;</code> 的形式，也可以写作 <code>&amp;#entity_number;</code> 的形式。比如需要显示小于号时可以写作 <code>&amp;lt;</code> 也可以写作 <code>&amp;#60;</code>。使用实体名而不是编号的好处是，名称更易于记忆。不过坏处是，<strong>浏览器也许并不支持所有实体名称（但对实体编号的支持却很好）</strong>。特别地，<strong>实体编号可以写作十进制形式，也可以写作十六进制形式</strong>，<code>&amp;#60</code> 等价于 <code>&amp;#x3C</code>。</p>
<hr>
<h3 id="使用HTMLParser解析HTML"><a href="#使用HTMLParser解析HTML" class="headerlink" title="使用HTMLParser解析HTML"></a>使用HTMLParser解析HTML</h3><p>类似于XML的SAX解析方法，使用 <code>HTMLParser</code> 解析HTML时，我们只需要为不同的事件编写相应的处理函数就可以了。以下面的代码为例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</div><div class="line"><span class="keyword">from</span> html.entities <span class="keyword">import</span> name2codepoint</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></div><div class="line">        print(<span class="string">'This is a start tag: %s'</span> % tag)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_endtag</span><span class="params">(self, tag)</span>:</span></div><div class="line">        print(<span class="string">'This is an end tag: %s'</span> % tag)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_startendtag</span><span class="params">(self, tag, attrs)</span>:</span></div><div class="line">        print(<span class="string">'This is a start-end tag: %s'</span> % tag)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></div><div class="line">        print(<span class="string">'This is data:'</span>, repr(data))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_comment</span><span class="params">(self, data)</span>:</span></div><div class="line">        print(<span class="string">'This is a comment:'</span>, data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_entityref</span><span class="params">(self, name)</span>:</span></div><div class="line">        print(<span class="string">'This is a named character reference: %s'</span> % chr(name2codepoint[name]))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_charref</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'x'</span>):</div><div class="line">            print(<span class="string">'This is a numeric character reference: %s'</span> % chr(int(name[<span class="number">1</span>:], <span class="number">16</span>)))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'This is a numeric character reference: %s'</span> % chr(int(name)))</div><div class="line"></div><div class="line">parser = MyHTMLParser(convert_charrefs=<span class="keyword">False</span>)</div><div class="line">parser.feed(<span class="string">r'''</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;Test&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;!-- test html parser --&gt;</div><div class="line">        &lt;p&gt;My personal website is &lt;a href="http://www.2wildkids.com/"&gt;www.2wildkids.com&lt;/a&gt;. Welcome to visit it.&lt;/p&gt;</div><div class="line">        &lt;img src="http://oe0e8k1nf.bkt.clouddn.com/avator-lion.jpg" /&gt;</div><div class="line">        &lt;p&gt;&amp;times; is a named character reference and &amp;#215; is a numeric character reference.</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;''')</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n'</span></div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n'</span></div><div class="line">This <span class="keyword">is</span> a start tag: html</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n    '</span></div><div class="line">This <span class="keyword">is</span> a start tag: head</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n        '</span></div><div class="line">This <span class="keyword">is</span> a start tag: title</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'Test'</span></div><div class="line">This <span class="keyword">is</span> an end tag: title</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n    '</span></div><div class="line">This <span class="keyword">is</span> an end tag: head</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n    '</span></div><div class="line">This <span class="keyword">is</span> a start tag: body</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n        '</span></div><div class="line">This <span class="keyword">is</span> a comment:  test html parser</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n        '</span></div><div class="line">This <span class="keyword">is</span> a start tag: p</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'My personal website is '</span></div><div class="line">This <span class="keyword">is</span> a start tag: a</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'www.2wildkids.com'</span></div><div class="line">This <span class="keyword">is</span> an end tag: a</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'. Welcome to visit it.'</span></div><div class="line">This <span class="keyword">is</span> an end tag: p</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n        '</span></div><div class="line">This <span class="keyword">is</span> a start-end tag: img</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n        '</span></div><div class="line">This <span class="keyword">is</span> a start tag: p</div><div class="line">This <span class="keyword">is</span> a named character reference: ×</div><div class="line">This <span class="keyword">is</span> data: <span class="string">' is a named character reference and '</span></div><div class="line">This <span class="keyword">is</span> a numeric character reference: ×;</div><div class="line">This <span class="keyword">is</span> data: <span class="string">' is a numeric character reference.\n    '</span></div><div class="line">This <span class="keyword">is</span> an end tag: body</div><div class="line">This <span class="keyword">is</span> data: <span class="string">'\n'</span></div><div class="line">This <span class="keyword">is</span> an end tag: html</div></pre></td></tr></table></figure>
<p><code>feed()</code> 方法可以多次调用，所以HTML字符串可以一部分一部分地塞进去，而无需一次传入完整的HTML文档。</p>
<p>代码比较简单，不需要过多地讲解。有几个小知识点需要注意一下：</p>
<ul>
<li>HTML中每个标签可能会有一些属性，比如 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性还有大小属性等等，这些属性传入事件处理函数时，会被整合到一个元组（<code>attrs</code> 参数）中，每个属性会以键值对的形式被存放在这个元组里。</li>
<li>处理实体名称需要 <code>name2codepoint</code> 这个字典，注意导入的方式。它可以将实体名称映射为十进制code point，然后再使用 <code>chr()</code> 函数就能得到对应的Unicode字符了。</li>
<li>处理实体编号需要先判断使用了十进制表示形式还是十六进制表示形式。</li>
</ul>
<p>还有一个问题，因为廖老师教程中使用的是Python3的早期版本，在早期版本中，<code>HTMLParser</code>类初始化时 <code>convert_charrefs</code> 参数默认是 <code>False</code>，不会把HTML字符串中的字符实体转换为Unicode字符。而在Python3.5版本中，这一参数被修改为默认是 <code>True</code>，所以传入HTML字符串时会自动进行转换，转换后自然就无法触发 <code>handle_entityref()</code> 事件和 <code>handle_charref()</code> 事件了。这个小问题刚开始也让我小卡了一下，在查看<a href="https://docs.python.org/3.5/library/html.parser.html?highlight=htmlparser" target="_blank" rel="external">官方文档</a>后终于解决了问题。</p>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>借助 <code>HTMLParser</code> 模块，我们可以非常方便地把网页中的文本、图像等解析出来。此外，我们也可以使用更为强大的<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">第三方库 <code>BeautifulSoup</code></a>。</p>
<hr>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>查看<a href="https://www.python.org/events/python-events/" target="_blank" rel="external">Python官网的新闻页</a>，用浏览器查看该网页的源码，尝试解析出Python官网发布的会议名称、时间和地点。</p>
</blockquote>
<p>由于源码较长，所以就不在笔记中展示出来了，源码文件 <code>Our Events _ Python.org.html</code> 放在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/Res" target="_blank" rel="external">Res目录</a>下。</p>
<p>首先分析一下源码，会议名称、时间和地点在源码中是这样表示的：</p>
<p><strong>会议名称</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"event-title"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.python.org/events/python-events/491/"</span>&gt;</span>PyCon Belarus 2017<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>会议时间</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2017-02-04T00:00:00+00:00"</span>&gt;</span>04 Feb. – 05 Feb. <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"say-no-more"</span>&gt;</span> 2017<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>会议地点</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"event-location"</span>&gt;</span>Minsk, Belarus<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
<p>并且，出现会议名称后一定会紧接着出现相应的会议时间和会议地点。因此，提取策略可以分为以下步骤：</p>
<ol>
<li><strong>提取会议名称</strong>：在 <code>h3</code> 标签触发 <code>handle_starttag</code> 事件时，判断其 <code>class</code> 属性是否为 <code>event-title</code> ，是则紧接着触发的一次 <code>handle_data</code> 事件所得的就是会议名称。</li>
<li><strong>提取会议时间</strong>：在 <code>time</code> 标签触发 <code>handle_starttag</code> 事件时，则紧接着触发的两次 <code>handle_data</code> 事件所得的分别是会议日期和年份。</li>
<li><strong>提取会议地点</strong>：在 <code>span</code> 标签触发 <code>handle_starttag</code> 事件时，判断其 <code>class</code> 属性是否为 <code>event-location</code> ，是则紧接着触发的一次 <code>handle_data</code> 事件所得的就是会议地点。</li>
</ol>
<p>我们可以设置一个 <code>flag</code> 变量来标记触发事件的标签，方便在 <code>handle_data</code> 时判断处理。又因为会议日期和年份是分开的，我们可以使用一个中间变量 <code>date</code> 来暂存日期，待和年份合并后再进行输出。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></div><div class="line">        super().__init__(**kw)</div><div class="line">        self.flag = <span class="string">''</span></div><div class="line">        self.date = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></div><div class="line">        <span class="keyword">if</span> tag == <span class="string">'h3'</span>:</div><div class="line">            <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</div><div class="line">                <span class="keyword">if</span> attr[<span class="number">0</span>] == <span class="string">'class'</span> <span class="keyword">and</span> attr[<span class="number">1</span>] == <span class="string">'event-title'</span>:</div><div class="line">                    self.flag = <span class="string">'title'</span></div><div class="line">        <span class="keyword">elif</span> tag == <span class="string">'time'</span>:</div><div class="line">            self.flag = <span class="string">'time'</span></div><div class="line">        <span class="keyword">elif</span> tag == <span class="string">'span'</span>:</div><div class="line">            <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</div><div class="line">                <span class="keyword">if</span> attr[<span class="number">0</span>] == <span class="string">'class'</span> <span class="keyword">and</span> attr[<span class="number">1</span>] == <span class="string">'event-location'</span>:</div><div class="line">                    self.flag = <span class="string">'location'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.flag == <span class="string">'title'</span>:</div><div class="line">            print(<span class="string">'会议名称:'</span>, data)</div><div class="line">            self.flag = <span class="string">''</span></div><div class="line">        <span class="keyword">elif</span> self.flag == <span class="string">'time'</span>:</div><div class="line">            <span class="keyword">if</span> self.date == <span class="string">''</span>:</div><div class="line">                self.date = self.date + data</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.date = self.date + data</div><div class="line">                print(<span class="string">'会议时间:'</span>, self.date)</div><div class="line">                self.date = <span class="string">''</span></div><div class="line">                self.flag = <span class="string">''</span></div><div class="line">        <span class="keyword">elif</span> self.flag == <span class="string">'location'</span>:</div><div class="line">            print(<span class="string">'会议地点:'</span>, data, <span class="string">'\n'</span>)</div><div class="line">            self.flag = <span class="string">''</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">r'E:\wheels\learnpython\My_Python_Notebook\Res\Our Events _ Python.org.html'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line"></div><div class="line">    html = f.read()</div><div class="line">    parser = MyHTMLParser(convert_charrefs=<span class="keyword">False</span>)</div><div class="line">    parser.feed(html)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">会议名称: PyCon Belarus <span class="number">2017</span></div><div class="line">会议时间: <span class="number">04</span> Feb. – <span class="number">05</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: Minsk, Belarus</div><div class="line"></div><div class="line">会议名称: PyTennessee <span class="number">2017</span></div><div class="line">会议时间: <span class="number">04</span> Feb. – <span class="number">06</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: Nashville, Tennessee, USA</div><div class="line"></div><div class="line">会议名称: PythonFOSDEM <span class="number">2017</span></div><div class="line">会议时间: <span class="number">04</span> Feb. – <span class="number">06</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: Université Libre de Bruxelles, Franklin Rooseveltlaan <span class="number">50</span>, <span class="number">1050</span> Brussel, Belgium</div><div class="line"></div><div class="line">会议名称: FOSDEM <span class="number">2017</span></div><div class="line">会议时间: <span class="number">04</span> Feb. – <span class="number">06</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: Université Libre de Bruxelles, Franklin Rooseveltlaan <span class="number">50</span>, <span class="number">1050</span> Brussel, Belgium</div><div class="line"></div><div class="line">会议名称: PyCon Colombia <span class="number">2017</span></div><div class="line">会议时间: <span class="number">10</span> Feb. – <span class="number">12</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: Bogota, Colombia</div><div class="line"></div><div class="line">会议名称: PyCon Pune <span class="number">2017</span></div><div class="line">会议时间: <span class="number">16</span> Feb. – <span class="number">20</span> Feb.  <span class="number">2017</span></div><div class="line">会议地点: COEP, Pune, India</div><div class="line"></div><div class="line">会议名称: PyCon Cameroon</div><div class="line">会议时间: <span class="number">20</span> Jan. – <span class="number">23</span> Jan.  <span class="number">2017</span></div><div class="line">会议地点: Molyko Buea,Cameroon</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>urllib</code> 库提供了一系列用于操作URL的功能。</p>
<hr>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p><code>urllib</code> 的 <code>request</code> 模块可以非常方便地抓取URL内容，<code>urlopen()</code> 函数首先发送一个GET请求到指定的页面，然后返回HTTP的响应。比方说，对豆瓣的一个URL（<a href="https://api.douban.com/v2/book/2129650" target="_blank" rel="external">https://api.douban.com/v2/book/2129650</a>）进行抓取，并返回响应：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line"></div><div class="line"><span class="keyword">with</span> request.urlopen(<span class="string">'https://api.douban.com/v2/book/2129650'</span>) <span class="keyword">as</span> f:</div><div class="line">    data = f.read()</div><div class="line">    print(<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</div><div class="line">        print(<span class="string">'%s: %s'</span> % (k, v))</div><div class="line">    print(<span class="string">'Data:'</span>, data.decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<p>可以看到HTTP响应状态，header，以及返回的JSON数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status: <span class="number">200</span> OK</div><div class="line">Server: nginx</div><div class="line">Date: Tue, <span class="number">26</span> May <span class="number">2015</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">27</span> GMT</div><div class="line">Content-Type: application/json; charset=utf<span class="number">-8</span></div><div class="line">Content-Length: <span class="number">2049</span></div><div class="line">Connection: close</div><div class="line">Expires: Sun, <span class="number">1</span> Jan <span class="number">2006</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span> GMT</div><div class="line">Pragma: no-cache</div><div class="line">Cache-Control: must-revalidate, no-cache, private</div><div class="line">X-DAE-Node: pidl1</div><div class="line">Data: &#123;<span class="string">"rating"</span>:&#123;<span class="string">"max"</span>:<span class="number">10</span>,<span class="string">"numRaters"</span>:<span class="number">16</span>,<span class="string">"average"</span>:<span class="string">"7.4"</span>,<span class="string">"min"</span>:<span class="number">0</span>&#125;,<span class="string">"subtitle"</span>:<span class="string">""</span>,<span class="string">"author"</span>:[<span class="string">"廖雪峰编著"</span>],<span class="string">"pubdate"</span>:<span class="string">"2007-6"</span>,<span class="string">"tags"</span>:[&#123;<span class="string">"count"</span>:<span class="number">20</span>,<span class="string">"name"</span>:<span class="string">"spring"</span>,<span class="string">"title"</span>:<span class="string">"spring"</span>&#125;...&#125;</div></pre></td></tr></table></figure>
<p>如果我们要想<strong>模拟浏览器发送GET请求</strong>，就需要使用 <code>Request</code> 对象，通过往 <code>Request</code> 对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line"></div><div class="line">req = request.Request(<span class="string">'http://www.douban.com/'</span>)</div><div class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25'</span>)</div><div class="line"><span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</div><div class="line">    print(<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</div><div class="line">        print(<span class="string">'%s: %s'</span> % (k, v))</div><div class="line">    print(<span class="string">'Data:'</span>, f.read().decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<p>这样豆瓣会返回适合iPhone的移动版网页：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"</span>&gt;</div><div class="line">    &lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"telephone=no"</span>&gt;</div><div class="line">    &lt;link rel=<span class="string">"apple-touch-icon"</span> sizes=<span class="string">"57x57"</span> href=<span class="string">"http://img4.douban.com/pics/cardkit/launcher/57.png"</span> /&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<hr>
<h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><p>如果要以POST方式发送一个请求，就需要<strong>把参数数据以bytes的形式传入</strong>。</p>
<p>比方说，我们模拟微博登录，需要先读取用于登录的邮箱和口令，然后按照 <a href="weibo.cn">weibo.cn</a> 登录页的格式以 <code>username=xxx&amp;password=xxx</code> 的方式来传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</div><div class="line"></div><div class="line">print(<span class="string">'Login to weibo.cn...'</span>)</div><div class="line">email = input(<span class="string">'Email: '</span>)</div><div class="line">passwd = input(<span class="string">'Password: '</span>)</div><div class="line">login_data = parse.urlencode([</div><div class="line">    (<span class="string">'username'</span>, email),</div><div class="line">    (<span class="string">'password'</span>, passwd),</div><div class="line">    (<span class="string">'entry'</span>, <span class="string">'mweibo'</span>),</div><div class="line">    (<span class="string">'client_id'</span>, <span class="string">''</span>),</div><div class="line">    (<span class="string">'savestate'</span>, <span class="string">'1'</span>),</div><div class="line">    (<span class="string">'ec'</span>, <span class="string">''</span>),</div><div class="line">    (<span class="string">'pagerefer'</span>, <span class="string">'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F'</span>)</div><div class="line">])</div><div class="line"></div><div class="line">req = request.Request(<span class="string">'https://passport.weibo.cn/sso/login'</span>)</div><div class="line">req.add_header(<span class="string">'Origin'</span>, <span class="string">'https://passport.weibo.cn'</span>)</div><div class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25'</span>)</div><div class="line">req.add_header(<span class="string">'Referer'</span>, <span class="string">'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F'</span>)</div><div class="line"></div><div class="line"><span class="keyword">with</span> request.urlopen(req, data=login_data.encode(<span class="string">'utf-8'</span>)) <span class="keyword">as</span> f:</div><div class="line">    print(<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</div><div class="line">        print(<span class="string">'%s: %s'</span> % (k, v))</div><div class="line">    print(<span class="string">'Data:'</span>, f.read().decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<p>如果登录成功，我们获得的响应如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Status: <span class="number">200</span> OK</div><div class="line">Server: nginx/<span class="number">1.2</span><span class="number">.0</span></div><div class="line">...</div><div class="line">Set-Cookie: SSOLoginState=<span class="number">1432620126</span>; path=/; domain=weibo.cn</div><div class="line">...</div><div class="line">Data: &#123;<span class="string">"retcode"</span>:<span class="number">20000000</span>,<span class="string">"msg"</span>:<span class="string">""</span>,<span class="string">"data"</span>:&#123;...,<span class="string">"uid"</span>:<span class="string">"1658384301"</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果登录失败，我们获得的响应如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">Data: &#123;<span class="string">"retcode"</span>:<span class="number">50011015</span>,<span class="string">"msg"</span>:<span class="string">"\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef"</span>,<span class="string">"data"</span>:&#123;<span class="string">"username"</span>:<span class="string">"example@python.org"</span>,<span class="string">"errline"</span>:<span class="number">536</span>&#125;&#125;</div><div class="line">Handler</div></pre></td></tr></table></figure>
<p>如果还需要更复杂的控制，比如通过一个<a href="http://baike.baidu.com/link?url=5YFSQ99ffvFNdUhG-6B5uZDPbFd21G-7occaszKEl8F3tWuikeXQde0JgTz62mUiC3tHpLgMfG_AR0qAz6leFbPtysU13Um4sR4_gkug0PbOE7GudBm9cXhJIqMY37X-4h_AD6gZP79pMzwCjQy8XDLKOCWqLw1EPryESUSkIgNiT8T2i7zTzNXEJIAuzXVY" target="_blank" rel="external">代理服务器(Proxy)</a> 去访问网站，我们需要利用 <code>ProxyHandler</code> 来处理，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proxy_handler = urllib.request.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'http://www.example.com:3128/'</span>&#125;)</div><div class="line">proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()</div><div class="line">proxy_auth_handler.add_password(<span class="string">'realm'</span>, <span class="string">'host'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>)</div><div class="line">opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)</div><div class="line"><span class="keyword">with</span> opener.open(<span class="string">'http://www.example.com/login.html'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><code>urllib</code> 提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的发出的请求中的header来伪装，User-Agent就是用来标识浏览器的。</p>
<hr>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>利用 <code>urllib</code> 读取XML，将XML一节的天气预报数据由硬编码改为由 <code>urllib</code> 获取</p>
</blockquote>
<p>由于雅虎天气API已经跪了，这里改用百度天气API来尝试。</p>
<p>接口例子：<a href="http://api.map.baidu.com/telematics/v3/weather?location=广州&amp;ak=8IoIaU655sQrs95uMWRWPDIa" target="_blank" rel="external"><code>http://api.map.baidu.com/telematics/v3/weather?location=广州&amp;ak=8IoIaU655sQrs95uMWRWPDIa</code></a></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherSaxHandler</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.result = dict()</div><div class="line">        self.currentTag = <span class="string">''</span> <span class="comment">#</span></div><div class="line">        self.flag = <span class="keyword">True</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_element</span><span class="params">(self, name, attrs)</span>:</span></div><div class="line">        self.currentTag = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char_data</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.flag == <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> self.currentTag == <span class="string">'currentCity'</span>:</div><div class="line">                self.result[<span class="string">'城市'</span>] = data</div><div class="line">            <span class="keyword">elif</span> self.currentTag == <span class="string">'date'</span>:</div><div class="line">                self.result[<span class="string">'当前'</span>] = data</div><div class="line">            <span class="keyword">elif</span> self.currentTag == <span class="string">'weather'</span>:</div><div class="line">                self.result[<span class="string">'天气'</span>] = data</div><div class="line">            <span class="keyword">elif</span> self.currentTag == <span class="string">'wind'</span>:</div><div class="line">                self.result[<span class="string">'风速'</span>] = data</div><div class="line">            <span class="keyword">elif</span> self.currentTag == <span class="string">'temperature'</span>:</div><div class="line">                self.result[<span class="string">'气温'</span>] = data</div><div class="line">                self.flag = <span class="keyword">False</span></div><div class="line">            self.currentTag = <span class="string">''</span> <span class="comment"># 记得每次解析完信息要重置</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_weather</span><span class="params">(data)</span>:</span></div><div class="line"></div><div class="line">    handler = WeatherSaxHandler()</div><div class="line">    p = ParserCreate()</div><div class="line">    p.StartElementHandler = handler.start_element</div><div class="line">    p.CharacterDataHandler = handler.char_data</div><div class="line">    p.Parse(data)</div><div class="line">    <span class="keyword">return</span> handler.result</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_xml</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">with</span> request.urlopen(url) <span class="keyword">as</span> f:</div><div class="line">        data = f.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">        print(<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">        <span class="keyword">return</span> parse_weather(data)</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">print(fetch_xml(<span class="string">'http://api.map.baidu.com/telematics/v3/weather?location=guangzhou&amp;ak=8IoIaU655sQrs95uMWRWPDIa'</span>))</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Status: <span class="number">200</span> OK</div><div class="line">&#123;<span class="string">'气温'</span>: <span class="string">'21 ~ 14℃'</span>, <span class="string">'城市'</span>: <span class="string">'guangzhou'</span>, <span class="string">'风速'</span>: <span class="string">'微风'</span>, <span class="string">'当前'</span>: <span class="string">'周六 02月04日 (实时：19℃)'</span>, <span class="string">'天气'</span>: <span class="string">'小雨'</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-12常用内建模块（上）]]></title>
      <url>http://2wildkids.com/2017/02/05/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#datetime">datetime</a><ul>
<li><a href="#获取当前日期和时间">获取当前日期和时间</a></li>
<li><a href="#获取指定日期和时间">获取指定日期和时间</a></li>
<li><a href="#datetime转换为timestamp">datetime转换为timestamp</a></li>
<li><a href="#timestamp转换为datetime">timestamp转换为datetime</a></li>
<li><a href="#str转换为datetime">str转换为datetime</a></li>
<li><a href="#datetime转换为str">datetime转换为str</a></li>
<li><a href="#datetime加减">datetime加减</a></li>
<li><a href="#本地时间转换为utc时间">本地时间转换为UTC时间</a></li>
<li><a href="#时区转换">时区转换</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#练习">练习</a></li>
</ul>
</li>
<li><a href="#collections">collections</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#namedtuple">namedtuple</a></li>
<li><a href="#deque">deque</a></li>
<li><a href="#defaultdict">defaultdict</a></li>
<li><a href="#ordereddict">OrderedDict</a></li>
<li><a href="#counter">Counter</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#base64">base64</a><ul>
<li><a href="#简介-1">简介</a></li>
<li><a href="#原理">原理</a></li>
<li><a href="#python中的实现方式">Python中的实现方式</a></li>
<li><a href="#小结-2">小结</a></li>
<li><a href="#练习-1">练习</a></li>
</ul>
</li>
<li><a href="#struct">struct</a><ul>
<li><a href="#为何需要struct">为何需要struct</a></li>
<li><a href="#struct的用法">struct的用法</a></li>
<li><a href="#使用struct分析bmp文件">使用struct分析bmp文件</a></li>
<li><a href="#小结-3">小结</a></li>
<li><a href="#练习-2">练习</a></li>
</ul>
</li>
<li><a href="#hashlib">hashlib</a><ul>
<li><a href="#摘要算法简介">摘要算法简介</a></li>
<li><a href="#python实现">Python实现</a></li>
<li><a href="#摘要算法应用">摘要算法应用</a></li>
<li><a href="#练习一">练习一</a></li>
<li><a href="#加盐">加盐</a></li>
<li><a href="#练习二">练习二</a></li>
<li><a href="#小结-4">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>Python之所以自称 <strong>“batteries included”</strong>，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p>
<p>本章将介绍一些常用的内建模块。</p>
<h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><code>datetime</code> 是Python处理日期和时间的标准库。</p>
<h3 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h3><p>我们先看如何获取当前日期和时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now() <span class="comment"># 获取当前datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(now)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">07.198690</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(now))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">datetime</span>.<span class="title">datetime</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>注意到，<code>datetime</code> 模块包含一个 <code>datetime</code>类，我们可以通过 <code>from datetime import datetime</code> 来导入 <code>datetime</code> 类。如果仅使用 <code>import datetime</code> 导入，则必须引用全名 <code>datetime.datetime</code> 才能使用这个类。<code>datetime.now()</code> 可以返回当前日期和时间，其类型是 <code>datetime.datetime</code>。</p>
<hr>
<h3 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h3><p>要指定某个日期和时间，我们直接用参数构造一个 <code>datetime</code> 类实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(dt)</div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h3><p>在计算机中，时间实际上是用数字表示的。我们把<strong>1970年1月1日 00:00:00 UTC+00:00时区</strong>的时刻称为<strong>新纪元时间（epoch time）</strong>，记为数字0（1970年以前的时间timestamp为负数），<strong>当前时间就是相对于epoch time的秒数，称为timestamp</strong>。</p>
<p>你可以认为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">timestamp = <span class="number">0</span> <span class="comment"># 等价于1970-1-1 00:00:00 UTC+0:00</span></div></pre></td></tr></table></figure>
<p>对应的北京时间是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">timestamp = <span class="number">0</span> <span class="comment"># 等价于1970-1-1 08:00:00 UTC+8:00</span></div></pre></td></tr></table></figure>
<p>也即epoch time是北京时间1970年1月1日的早上8点钟。</p>
<p>可见<strong>timestamp的值与时区毫无关系</strong>，无论在哪个时区，同一时刻timestamp的值都相同，实际时间只需要再按时区推算就可以了。这就是为什么计算机存储的当前时间是以timestamp表示的，因为<strong>全球各地的计算机在任意时刻的timestamp都是完全相同的</strong>（假定时间已校准）。</p>
<p>把一个 <code>datetime</code> 类型转换为timestamp只需要简单调用 <code>timestamp()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></div><div class="line"><span class="number">1429417200.0</span></div></pre></td></tr></table></figure>
<p>注意<strong>Python的timestamp是一个浮点数</strong>。如果有小数位，小数位表示<strong>毫秒数</strong>。</p>
<p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p>
<hr>
<h3 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h3><p>要把timestamp转换为 <code>datetime</code>，使用 <code>datetime</code> 提供的 <code>fromtimestamp()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。<strong>上述转换是在timestamp和本地时间做转换（本地时间是指当前操作系统设定的时区）</strong>。例如北京时区是东8区，则本地时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>实际上就是UTC+8:00时区的时间，也即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span> UTC+<span class="number">8</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">00</span> UTC+<span class="number">0</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>timestamp也可以直接被转换到UTC标准时区的时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t)) <span class="comment"># 本地时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h3><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把 <code>str</code> 转换为 <code>datetime</code>。转换方法是通过 <code>datetime.strptime()</code> 实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2015-6-1 18:19:59'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(cday)</div><div class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-01</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></div></pre></td></tr></table></figure>
<p>字符串 <code>&#39;%Y-%m-%d %H:%M:%S&#39;</code> 规定了日期和时间部分的格式。当然也可以根据实际需要进行修改，详细的说明请参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="external">Python文档</a>。注意，<strong>转换后的 <code>datetime</code> 是不带时区信息的</strong>。</p>
<hr>
<h3 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h3><p>如果已经有了 <code>datetime</code> 对象，要把它格式化为字符串显示给用户，就需要转换为 <code>str</code>，转换方法是通过 <code>strftime()</code> 实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</div><div class="line">Mon, May <span class="number">05</span> <span class="number">16</span>:<span class="number">28</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>对日期和时间进行加减实际上就是把 <code>datetime</code> 往后或往前计算，得到新的 <code>datetime</code>。加减可以直接用 <code>+</code> 和 <code>-</code> 运算符，不过需要导入 <code>timedelta</code> 这个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div></pre></td></tr></table></figure>
<p>可见，使用 <code>timedelta</code> 你可以很容易地算出前几天和后几天的时刻。</p>
<p>我们也可以使用 <code>timedelta</code> 很方便地计算出两个日期之间的差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = datetime(<span class="number">2016</span>,<span class="number">8</span>,<span class="number">19</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = datetime(<span class="number">2017</span>,<span class="number">1</span>,<span class="number">16</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(p-f)</div><div class="line"><span class="number">150</span> days, <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h3><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而<strong>UTC时间指UTC+0:00时区的时间</strong>。<code>datetime</code> 类型有一个时区属性 <code>tzinfo</code>，但是默认为 <code>None</code>，所以无法区分这个 <code>datetime</code> 到底是哪个时区，除非强行给 <code>datetime</code> 设置一个时区：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tz_utc_8 = timezone(timedelta(hours=<span class="number">8</span>)) <span class="comment"># 创建时区UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.replace(tzinfo=tz_utc_8) <span class="comment"># 强制设置为UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>, tzinfo=datetime.timezone(datetime.timedelta(<span class="number">0</span>, <span class="number">28800</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">02</span>:<span class="number">10.871012</span>+<span class="number">08</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不应该强制设置为时区信息。</p>
<hr>
<h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>我们可以先通过 <code>utcnow()</code> 拿到当前的UTC时间，再转换为任意时区的时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(bj_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"><span class="comment"># astimezone()将utc_dt转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div><div class="line"><span class="comment"># astimezone()将bj_dt转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt2)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>注意，上述代码中首先通过 <code>utcnow()</code> 方法获取到一个处于UTC时间的 <code>datetime</code> 实例（按照系统时间推算出的，所以如果系统时间错则得到的实例也是错的），这个实例本身没有时区信息，所以要通过 <code>replace()</code> 方法强制设置时区信息为UTC时区。然后利用这个带时区的 <code>datetime</code>，通过 <code>astimezone()</code> 方法就可以转换到任意时区了。注意，任何带时区（不必是UTC时区）的 <code>datetime</code> 都可以被正确转换到别的时区，例如上述 <code>bj_dt</code> 到 <code>tokyo_dt</code> 的转换。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>datetime</code> 表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<p>如果要存储 <code>datetime</code>，最佳方法是将其转换为 <code>timestamp</code> 再存储，因为 <code>timestamp</code> 的值与时区完全无关。</p>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>假设你获取了用户输入的日期和时间如 <code>2015-1-21 9:01:30</code>，以及一个时区信息如 <code>UTC+5:00</code>，均是 <code>str</code>，请编写一个函数将其转换为 <code>timestamp</code>：</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone, timedelta</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_timestamp</span><span class="params">(dt_str, tz_str)</span>:</span></div><div class="line"></div><div class="line">    tz_match = re.match(<span class="string">r'UTC([\+\-]\d+?):00'</span>, tz_str)</div><div class="line">    idate = datetime.strptime(dt_str, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">    idate = idate.replace(tzinfo=timezone(timedelta(hours=int(tz_match.group(<span class="number">1</span>)))))</div><div class="line">    <span class="keyword">return</span> idate.timestamp()</div><div class="line"></div><div class="line"><span class="comment"># 测试:</span></div><div class="line"></div><div class="line">t1 = to_timestamp(<span class="string">'2015-6-1 08:10:30'</span>, <span class="string">'UTC+7:00'</span>)</div><div class="line"><span class="keyword">if</span> t1 == <span class="number">1433121030.0</span>:</div><div class="line">    print(<span class="string">'Pass.'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'Fail.'</span>)</div><div class="line"></div><div class="line">t2 = to_timestamp(<span class="string">'2015-5-31 16:10:30'</span>, <span class="string">'UTC-09:00'</span>)</div><div class="line"><span class="keyword">if</span> t2 == <span class="number">1433121030.0</span>:</div><div class="line">    print(<span class="string">'Pass.'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'Fail.'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>collections</code> 是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>我们知道 <code>tuple</code> 可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = (<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>但是，代码中使用 <code>(1, 2)</code> 的方式来写很难看出这个 <code>tuple</code> 是用来表示一个点的。如果我们特地为定义一个“点”类而编写代码，又有点小题大作。怎么办呢？<code>collections</code> 模块中的 <code>namedtuple</code> 可以帮到我们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p><code>namedtuple()</code> 是一个函数，它可以用来方便地创建一个按需定制的 <code>tuple</code> 类的子类，我们可以把这样得到的子类看作一种特殊的元组，可以采用访问属性的方式来引用该元组的元素，使用十分方便。</p>
<p>可以验证创建的 <code>Point</code> 是 <code>tuple</code> 的一种子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(p, Point)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(p, tuple)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>类似的，如果要用坐标和半径表示一个圆，也可以用 <code>namedtuple</code> 来创建一个 <code>Circle</code> 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># namedtuple('名称', [属性list]):</span></div><div class="line">Circle = namedtuple(<span class="string">'Circle'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'r'</span>])</div></pre></td></tr></table></figure>
<hr>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>使用 <code>list</code> 存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为 <code>list</code> 是线性存储，数据量大的时候，插入和删除效率很低。<code>deque</code> 是为了更高效实现插入和删除操作而创造的双向列表，适合用于队列和栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">'x'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">'y'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q</div><div class="line">deque([<span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'x'</span>])</div></pre></td></tr></table></figure>
<p><code>deque</code> 除了实现 <code>list</code> 的 <code>append()</code> 和 <code>pop()</code> 外，还支持 <code>appendleft()</code> 和 <code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<hr>
<h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>使用 <code>dict</code> 时，如果引用的Key不存在，就会抛出 <code>KeyError</code>。如果希望key不存在时也能返回一个默认值，可以使用 <code>defaultdict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">'N/A'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] <span class="comment"># key1存在</span></div><div class="line"><span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key2'</span>] <span class="comment"># key2不存在，返回默认值</span></div><div class="line"><span class="string">'N/A'</span></div></pre></td></tr></table></figure>
<p>注意<strong>默认值是调用函数返回的</strong>，而函数在创建 <code>defaultdict</code> 对象时传入。除了在Key不存在时返回默认值，<code>defaultdict</code> 的其他行为跟 <code>dict</code> 是完全一样的。</p>
<hr>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>使用 <code>dict</code> 时，Key是无序的。在对 <code>dict</code> 做迭代时，我们无法确定Key的顺序。</p>
<p>如果要保持Key的顺序，可以用 <code>OrderedDict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></div><div class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></div><div class="line">OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div></pre></td></tr></table></figure>
<p>注意，<strong><code>OrderedDict</code> 的Key是按照插入的顺序排列的，不是Key本身排序</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'z'</span>] = <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'y'</span>] = <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'x'</span>] = <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(od.keys()) <span class="comment"># 按照插入的Key的顺序返回</span></div><div class="line">[<span class="string">'z'</span>, <span class="string">'y'</span>, <span class="string">'x'</span>]</div></pre></td></tr></table></figure>
<p><code>OrderedDict</code> 可以实现一个FIFO（先进先出）的 <code>dict</code>，当容量超出限制时，优先删除最早添加的Key：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LastUpdatedOrderedDict</span><span class="params">(OrderedDict)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></div><div class="line">        super(LastUpdatedOrderedDict, self).__init__()</div><div class="line">        self._capacity = capacity</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        containsKey = <span class="number">1</span> <span class="keyword">if</span> key <span class="keyword">in</span> self <span class="keyword">else</span> <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> len(self) - containsKey &gt;= self._capacity:</div><div class="line">            last = self.popitem(last=<span class="keyword">False</span>)</div><div class="line">            print(<span class="string">'remove:'</span>, last)</div><div class="line">        <span class="keyword">if</span> containsKey:</div><div class="line">            <span class="keyword">del</span> self[key]</div><div class="line">            print(<span class="string">'set:'</span>, (key, value))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'add:'</span>, (key, value))</div><div class="line">        OrderedDict.__setitem__(self, key, value)</div></pre></td></tr></table></figure>
<p>解析一下上面的例子，我们实现了一个容量有限的先进先出的 <code>dict</code> —— <code>LastUpdatedOrderedDict</code>，在实例化时，<code>__init__()</code> 方法会被调用来初始化要创建的实例。<code>self</code> 参数指的便是要创建的实例本身，此外我们传入一个 <code>capacity</code> 参数用来表示这个 <code>dict</code> 的容量。需要注意，在这个 <code>__init__()</code> 方法中，我们使用 <code>super(LastUpdatedOrderedDict, self).__init__()</code> 这个语句来进行初始化，它会自动找到 <code>LastUpdatedOrderedDict</code> 的父类，把实例 <code>self</code> 转换为一个特殊的父类对象，从而可以调用父类的 <code>__init__()</code> 方法。<code>self._capacity = capacity</code> 这一句则是给实例绑定容量属性，使用 <code>_capacity</code> 这个变量名来和传入参数区别开来，前置单下划线表示这个属性应被视作私有属性来使用。</p>
<p>再看看 <code>__setitem__()</code> 方法，首先判断一下设置的key在 <code>dict</code> 里是否存在，如果存在则 <code>containsKey</code> 为1否则为0。接下来判断容量是否超出，如果超出则pop掉最前面的一个key-value对。然后再判断key是否存在，是则先删除掉原来的key-value对。最后调用父类的 <code>__setitem__()</code> 方法来完成赋值。</p>
<hr>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p><code>Counter</code> 是一个简单的计数器，例如，统计字符出现的个数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'programming'</span>:</div><div class="line"><span class="meta">... </span>    c[ch] = c[ch] + <span class="number">1</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">Counter(&#123;<span class="string">'g'</span>: <span class="number">2</span>, <span class="string">'m'</span>: <span class="number">2</span>, <span class="string">'r'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'i'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'p'</span>: <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<p><code>Counter</code> 实际上也是 <code>dict</code> 的一个子类，上面的结果可以看出，字符 <code>&#39;g&#39;、&#39;m&#39;、&#39;r&#39;</code> 各出现了两次，其他字符各出现了一次。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>collections</code> 模块提供了一些有用的集合类，我们可以根据需要选用。</p>
<hr>
<p><br></p>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Base64是一种用64个字符来表示任意二进制数据的方法。</p>
<p>用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Base64的原理很简单，首先，它使用总共64个字符进行编码（26个大小写字母+10个数字+加号+左斜杠）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, ... <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, ... <span class="string">'0'</span>, <span class="string">'1'</span>, ... <span class="string">'+'</span>, <span class="string">'/'</span>]</div></pre></td></tr></table></figure>
<p>然后，对二进制数据进行处理时，每3个字节一组，就得到 <code>3x8=24 bit</code>，重新划分为4组，每组正好6个bit，有 <code>2^6=64</code> 种取值，对应64个字符的一个，：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/base64-encode.png" alt="base64-encode"></p>
<p>这样我们就可以把二进制数据的3个字节使用4个字符来表示，这就是Base64编码。采用Base64编码会把3字节的二进制数据编码为4字节（4个字符所以是4字节）的文本数据，长度会增加33%。但好处是编码后的文本数据可以在邮件正文、网页等直接显示，而不会出现乱码的情况。</p>
<p><strong>如果要编码的二进制数据不是3的倍数，最后多出1个或2个字节怎么办呢？</strong> Base64编码采用 <code>\x00</code> 字节在末尾补充到3个字节，在编码的末尾会使用 <code>=</code> 号表示补了多少字节。解码的时候，会自动去掉用于补足的 <code>\x00</code> 字节。</p>
<hr>
<h3 id="Python中的实现方式"><a href="#Python中的实现方式" class="headerlink" title="Python中的实现方式"></a>Python中的实现方式</h3><p>Python内置的 <code>base64</code> 模块可以直接进行base64的编解码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">b'binary\x00string'</span>)</div><div class="line"><span class="string">b'YmluYXJ5AHN0cmluZw=='</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(<span class="string">b'YmluYXJ5AHN0cmluZw=='</span>)</div><div class="line"><span class="string">b'binary\x00string'</span></div></pre></td></tr></table></figure>
<p>上面的代码中我们使用了 <code>b</code> 把字符串转为二进制，然后传入 <code>b64encode()</code> 函数进行编码，字符串长度为13个字节（注意 <code>\x00</code> 是一个字符，占1字节）。可以看到编码后所得字符串20个字节，并且使用两个 <code>=</code> 号表明编码过程中，由于13无法整除3，所以末尾补充了两个 <code>\x00</code>。<strong>注意，<code>=</code> 号是算在20个字节（<code>15÷3×4=20 bit</code>）里面的，而不是额外放在编码后的字符串后面。</strong></p>
<p>由于标准的Base64编码后可能出现字符 <code>+</code> 和 <code>/</code>，在URL中就不能直接作为参数，所以又有一种 <strong>“url safe” 的base64编码</strong>，把字符 <code>+</code> 和 <code>/</code> 分别替换成 <code>-</code> 和 <code>_</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">b'i\xb7\x1d\xfb\xef\xff'</span>)</div><div class="line"><span class="string">b'abcd++//'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>base64.urlsafe_b64encode(<span class="string">b'i\xb7\x1d\xfb\xef\xff'</span>)</div><div class="line"><span class="string">b'abcd--__'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>base64.urlsafe_b64decode(<span class="string">'abcd--__'</span>)</div><div class="line"><span class="string">b'i\xb7\x1d\xfb\xef\xff'</span></div></pre></td></tr></table></figure>
<p>我们也可以自定义64个字符的排列顺序，也即自定义Base64编码，不过，通常情况下没有必要这样做。注意，<strong>Base64仅仅是一种通过查表进行编码的方法，不能用于加密</strong>，即使使用自定义的编码表也不行（依然能很容易被破解）。Base64<strong>适用于小段内容的编码</strong>，比如数字证书签名、Cookie的内容等。由于 <code>=</code> 字符也可能出现在Base64编码中，但 <code>=</code> 用在URL、Cookie里面会造成歧义，所以，很多人会在Base64编码后把 <code>=</code> 去掉：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 标准Base64:</div><div class="line">'abcd' -&gt; 'YWJjZA=='</div><div class="line"># 自动去掉=:</div><div class="line">'abcd' -&gt; 'YWJjZA'</div></pre></td></tr></table></figure>
<p>那么去掉 <code>=</code> 后解码要怎样完成呢？不用担心，因为Base64是把3个字节变为4个字节，所以，Base64编码的长度一定是4的倍数，解码时我们只需要在末尾加上足够的 <code>=</code> 把Base64字符串的长度变回4的倍数，就可以正常解码了。</p>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Base64是一种把任意二进制转换为文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>
<hr>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>请写一个能兼容去掉 <code>=</code> 的base64编码字符串的解码函数：</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> base64</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_base64_decode</span><span class="params">(s)</span>:</span></div><div class="line"></div><div class="line">    remainder = len(s) % <span class="number">4</span></div><div class="line">    <span class="keyword">if</span> remainder == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> base64.b64decode(s)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> base64.b64decode(s+remainder*<span class="string">b'='</span>)</div><div class="line"></div><div class="line"><span class="comment"># 测试:</span></div><div class="line"><span class="keyword">assert</span> <span class="string">b'abcd'</span> == safe_base64_decode(<span class="string">b'YWJjZA=='</span>), safe_base64_decode(<span class="string">'YWJjZA=='</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">b'abcd'</span> == safe_base64_decode(<span class="string">b'YWJjZA'</span>), safe_base64_decode(<span class="string">'YWJjZA'</span>)</div><div class="line">print(<span class="string">'Pass'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h3 id="为何需要struct"><a href="#为何需要struct" class="headerlink" title="为何需要struct"></a>为何需要struct</h3><p>准确地讲，<strong>Python没有专门处理字节的数据类型</strong>。但由于 <code>b&#39;str&#39;</code> 可以用来表示字节，所以在Python中可以认为 <code>字节数组＝二进制str</code>。而在C语言中，我们可以很方便地用 <code>struct</code>、<code>union</code> 等库来处理字节以及字节和int，float的转换。</p>
<p>假设我们要把一个32位无符号整数转换为字节（4个bytes）。在Python中，得这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">10240099</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = (n &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = (n &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b3 = (n &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b4 = n &amp; <span class="number">0xff</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bs = bytes([b1, b2, b3, b4])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bs</div><div class="line"><span class="string">b'\x00\x9c@c'</span></div></pre></td></tr></table></figure>
<p>稍微解析一下，十进制数 <code>10240099</code> 转换为十六进制是 <code>0x009c4063</code>，这里使用与运算和右移来拆分出这个32位无符号整数的每一个byte（注意得到的不是字节数组而是一个整数），其中 <code>b1=0, b2=156, b3=64, b4=99</code>，将这四个整数放入一个列表中传入 <code>bytes()</code> 函数，就能得到字节数组了。注意 <code>bs</code> 中是有4个字节的，<code>len(bs)</code> 的值为4。由于对应整数64的十六进制数 <code>0x40</code> 属于ASCII码范围，所以用字符 <code>@</code> 表示，而对应整数99的十六进制数 <code>0x63</code> 则对应字符 <code>c</code>。</p>
<p>可以看到，这样要逐个byte来拆分，再进行转换实在是非常麻烦。如果要把浮点数转换为字节就无能为力了。幸好，Python提供了一个 <code>struct</code> 模块来解决 <code>bytes</code> 和其他二进制数据类型的转换问题。</p>
<hr>
<h3 id="struct的用法"><a href="#struct的用法" class="headerlink" title="struct的用法"></a>struct的用法</h3><p><code>struct</code> 模块的 <code>pack</code> 函数把任意数据类型变成 <code>bytes</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>struct.pack(<span class="string">'&gt;I'</span>, <span class="number">10240099</span>)</div><div class="line"><span class="string">b'\x00\x9c@c'</span></div></pre></td></tr></table></figure>
<p><code>pack()</code> 的第一个参数是<strong>处理指令</strong>，这里 <code>&#39;&gt;I&#39;</code> 的意思分为两部分：</p>
<ul>
<li>字节顺序：<code>&gt;</code> 表示的是使用大端序作为字节顺序。</li>
<li>数据类型：<code>I</code> 表示的是要转换一个32位无符号整数。可以有多个数据类型从而转换出多个数。</li>
</ul>
<p>第二个参数要注意和处理指令一致。</p>
<p><code>unpack()</code> 函数与 <code>pack()</code> 相反，它是把 <code>bytes</code> 转换为相应的数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>struct.unpack(<span class="string">'&gt;IH'</span>, <span class="string">b'\xf0\xf0\xf0\xf0\x80\x80'</span>)</div><div class="line">(<span class="number">4042322160</span>, <span class="number">32896</span>)</div></pre></td></tr></table></figure>
<p>这里的 <code>&gt;IH</code> 表示这个字节数组用的是大端序，并且要依次转换出一个32位无符号整数和16位无符号整数。</p>
<p><code>struct</code> 模块定义的数据类型可以参考<a href="https://docs.python.org/3/library/struct.html#format-characters" target="_blank" rel="external">Python官方文档</a>。关于大端序（big-endian，BE）和小端序（little-endian，LE）的区别可以看看<a href="http://www.cnblogs.com/passingcloudss/archive/2011/05/03/2035273.html" target="_blank" rel="external">这篇博文</a>，讲解得很清晰。</p>
<hr>
<h3 id="使用struct分析bmp文件"><a href="#使用struct分析bmp文件" class="headerlink" title="使用struct分析bmp文件"></a>使用struct分析bmp文件</h3><p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们可以使用 <code>struct</code> 来分析一下。</p>
<p>首先找到一个bmp文件，没有的话用Windows自带的【画图】画一个即可。读入它的前30个字节来分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'</span></div></pre></td></tr></table></figure>
<p>BMP格式采用小端序的方式存储数据，文件头的结构按顺序如下：</p>
<ul>
<li>两个字节：’BM’表示Windows位图，’BA’表示OS/2位图；</li>
<li>一个32位无符号整数：表示位图大小；</li>
<li>一个32位无符号整数：保留位，始终为0；</li>
<li>一个32位无符号整数：实际图像的偏移量；</li>
<li>一个32位无符号整数：Header的字节数；</li>
<li>一个32位无符号整数：图像宽度(单位为像素)；</li>
<li>一个32位无符号整数：图像高度(单位为像素)；</li>
<li>一个16位无符号整数：始终为1；</li>
<li>一个16位无符号整数：颜色数。</li>
</ul>
<p>所以，组合起来用unpack读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>struct.unpack(<span class="string">'&lt;ccIIIIIIHH'</span>, s)</div><div class="line">(<span class="string">b'B'</span>, <span class="string">b'M'</span>, <span class="number">691256</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">40</span>, <span class="number">640</span>, <span class="number">360</span>, <span class="number">1</span>, <span class="number">24</span>)</div></pre></td></tr></table></figure>
<p>这里的 <code>c</code> 表示对应的数据类型是一个字符。结果显示，<code>b&#39;B&#39;</code>、<code>b&#39;M&#39;</code> 说明是一张Windows位图，位图大小为640x360，颜色数为24。</p>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用 <code>struct</code> 操作能够更加方便。</p>
<hr>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>请编写一个bmpinfo.py，可以检查任意文件是否是Windows位图文件，如果是，打印出图片大小和颜色数。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> struct</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readBmpFile</span><span class="params">(file)</span>:</span></div><div class="line"></div><div class="line">    f = open(file, <span class="string">'rb'</span>)</div><div class="line">    bs = f.read()</div><div class="line">    f.close()</div><div class="line">    <span class="keyword">return</span> bs[<span class="number">0</span>:<span class="number">30</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkBmp</span><span class="params">(info)</span>:</span></div><div class="line"></div><div class="line">    ts = struct.unpack(<span class="string">'&lt;ccIIIIIIHH'</span>, info)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ts[<span class="number">0</span>] == <span class="string">b'B'</span> <span class="keyword">and</span> ts[<span class="number">1</span>] == <span class="string">b'M'</span>:</div><div class="line">        print(<span class="string">'图片大小：%d * %d'</span> % (ts[<span class="number">6</span>], ts[<span class="number">7</span>]))</div><div class="line">        print(<span class="string">'颜色数：%d'</span> % ts[<span class="number">9</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'非位图文件'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</div><div class="line">        info = readBmpFile(sys.argv[<span class="number">1</span>])</div><div class="line">        checkBmp(info)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        info = input(<span class="string">'Please input the file name: '</span>)</div><div class="line">        checkBmp(info)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><h3 id="摘要算法简介"><a href="#摘要算法简介" class="headerlink" title="摘要算法简介"></a>摘要算法简介</h3><p>Python的 <code>hashlib</code> 模块提供了常见的摘要算法，如MD5，SHA1等等。</p>
<p>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个摘要函数（也称哈希函数），<strong>把任意长度的数据转换为一个固定长度的数据串</strong>（称为<strong>摘要（digest）</strong>，通常表示为由16进制数字组成的字符串）。</p>
<p>摘要函数应当是一个单向函数，也即计算摘要容易，但通过摘要反推原始数据却非常困难。并且即使仅对原始数据做一个bit的修改也会导致计算出的摘要完全不同。</p>
<hr>
<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><p>以常见的摘要算法MD5为例，计算一个字符串的MD5值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">md5 = hashlib.md5()</div><div class="line">md5.update(<span class="string">'how to use md5 in python hashlib?'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(md5.hexdigest())</div></pre></td></tr></table></figure>
<p>计算结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d26a53750bc40b38b65a520292f69306</div></pre></td></tr></table></figure>
<p>如果数据量很大，我们可以多次调用 <code>update()</code> 来传入新数据。只要保证输入一致，那么最后计算的结果一定都是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">md5 = hashlib.md5()</div><div class="line">md5.update(<span class="string">'how to use md5 in '</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">md5.update(<span class="string">'python hashlib?'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(md5.hexdigest())</div></pre></td></tr></table></figure>
<p>但只要改动一个字母，计算的结果就会完全不同。</p>
<p>MD5是最常见的摘要算法，速度很快，所得摘要长度为128 bit，通常用一个32位的16进制字符串表示。</p>
<p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">sha1 = hashlib.sha1()</div><div class="line">sha1.update(<span class="string">'how to use sha1 in '</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">sha1.update(<span class="string">'python hashlib?'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(sha1.hexdigest())</div></pre></td></tr></table></figure>
<p>SHA1所得摘要长度为160 bit，通常用一个40位的16进制字符串表示。</p>
<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要的长度也更长。</p>
<p><strong>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能。</strong>因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为<strong>碰撞（collasion）</strong>。</p>
<hr>
<h3 id="摘要算法应用"><a href="#摘要算法应用" class="headerlink" title="摘要算法应用"></a>摘要算法应用</h3><p>摘要算法能应用到什么地方？举个常用例子：</p>
<p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">123456</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">abc999</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">alice2008</td>
</tr>
</tbody>
</table>
</div>
<p>如果以明文保存用户口令，一旦数据库泄露，所有用户的口令就会落入黑客的手里。此外，网站运维人员是可以访问数据库的，如果他们心有不轨，那么也会很容易地获取到所有用户的口令。</p>
<p>正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">username</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">e10adc3949ba59abbe56e057f20f883e</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">878ef96e86145580c38c87f0410ad153</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">99b1c2188db85afee403b1536010c2c9</td>
</tr>
</tbody>
</table>
</div>
<p>当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。</p>
<hr>
<h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><blockquote>
<p>根据用户输入的口令计算出对应的MD5值，并验证是否与数据库中保存的一致</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">db = &#123;</div><div class="line">    <span class="string">'michael'</span>: <span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,</div><div class="line">    <span class="string">'bob'</span>: <span class="string">'878ef96e86145580c38c87f0410ad153'</span>,</div><div class="line">    <span class="string">'alice'</span>: <span class="string">'99b1c2188db85afee403b1536010c2c9'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_md5</span><span class="params">(password)</span>:</span></div><div class="line"></div><div class="line">    md5 = hashlib.md5()</div><div class="line">    md5.update(password.encode(<span class="string">'utf-8'</span>))</div><div class="line">    <span class="keyword">return</span> md5.hexdigest()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(user, password)</span>:</span></div><div class="line"></div><div class="line">    digest = calc_md5(password)</div><div class="line">    <span class="keyword">if</span> db[user] == digest:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    user = input(<span class="string">'请输入用户名：'</span>)</div><div class="line">    password = input(<span class="string">'请输入密码：'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> login(user, password):</div><div class="line">        print(<span class="string">'密码正确，登录成功。'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'密码错误，登录失败。'</span>)</div></pre></td></tr></table></figure>
<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p>
<p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令。于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>: <span class="string">'123456'</span></div><div class="line"><span class="string">'21218cca77804d2ba1922c33e0151105'</span>: <span class="string">'888888'</span></div><div class="line"><span class="string">'5f4dcc3b5aa765d61d8327deb882cf99'</span>: <span class="string">'password'</span></div></pre></td></tr></table></figure>
<p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<hr>
<h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><p>对于用户来讲，当然不应该使用过于简单的口令。但是，我们能否<strong>在程序设计上对简单口令加强保护</strong>呢？</p>
<p>由于常用口令的MD5值很容易被计算出来，为了加强保护，我们可以对原始口令添加一个复杂字符串（俗称“盐”），这样再计算MD5值就不容易被黑客蒙中了，这种方法俗称<strong>“加盐”</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_md5</span><span class="params">(password)</span>:</span></div><div class="line"></div><div class="line">    md5 = hashlib.md5()</div><div class="line">    md5.update(password.encode(<span class="string">'utf-8'</span>))</div><div class="line">    md5.update(<span class="string">'the-Salt'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">    <span class="keyword">return</span> md5.hexdigest()</div></pre></td></tr></table></figure>
<p>经过加盐处理的MD5口令，只要盐不被黑客知道，即使用户使用简单口令，也很难通过MD5被反推出来。</p>
<p>但是如果有两个用户都使用了相同的简单口令比如123456，数据库中就会存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法<strong>让使用相同口令的用户存储不同的MD5</strong>呢？如果假定用户无法修改登录名，就可以通过把登录名作为“盐”的一部分来计算MD5，从而实现相同口令的用户有不同的MD5值。</p>
<hr>
<h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><blockquote>
<p>根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(username, password)</span>:</span></div><div class="line">    db[username] = calc_md5(password + username + <span class="string">'the-Salt'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_md5</span><span class="params">(password)</span>:</span></div><div class="line"></div><div class="line">    md5 = hashlib.md5()</div><div class="line">    md5.update(password.encode(<span class="string">'utf-8'</span>))</div><div class="line">    <span class="keyword">return</span> md5.hexdigest()</div></pre></td></tr></table></figure>
<blockquote>
<p>根据修改后的MD5算法实现用户登录的验证：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(user, password)</span>:</span></div><div class="line"></div><div class="line">    digest = calc_md5(password + username + <span class="string">'the-Salt'</span>)</div><div class="line">    <span class="keyword">if</span> db[user] == digest:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>摘要算法在很多地方都有广泛的应用。要注意<strong>摘要算法不是加密算法，不能用于加密</strong>（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>
<hr>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-11正则表达式]]></title>
      <url>http://2wildkids.com/2017/01/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#进阶">进阶</a></li>
<li><a href="#re模块">re模块</a></li>
<li><a href="#切分字符串">切分字符串</a></li>
<li><a href="#分组">分组</a></li>
<li><a href="#贪婪匹配">贪婪匹配</a></li>
<li><a href="#编译">编译</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#练习">练习</a><ul>
<li><a href="#习题一">习题一</a></li>
<li><a href="#习题二">习题二</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取 <code>@</code> 前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>
<p>正则表达式是一种用来<strong>匹配字符串的强大工具</strong>。它的设计思想是<strong>用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了</strong>，否则，该字符串就是不合法的。</p>
<p>所以我们判断一个字符串是否是合法的Email的方法是：</p>
<ol>
<li>创建一个匹配Email的正则表达式；</li>
<li>用该正则表达式去匹配用户的输入来判断是否合法。</li>
</ol>
<p>因为正则表达式也是用字符串表示的，所以，我们要首先了解<strong>如何用字符来描述字符</strong>。</p>
<p>在正则表达式中，如果直接给出字符，就是<strong>精确匹配</strong>。用 <code>\d</code> 可以<strong>匹配一个数字</strong>，<code>\w</code> 可以<strong>匹配一个字母或数字</strong>，<code>\s</code> 可以<strong>匹配一个空格（也包括Tab等空白符）</strong>。所以：</p>
<ul>
<li><code>&#39;00\d&#39;</code> 可以匹配 <code>&#39;007&#39;</code>，但无法匹配 <code>&#39;00A&#39;</code>；</li>
<li><code>&#39;\d\d\d&#39;</code> 可以匹配 <code>&#39;010&#39;</code>；</li>
<li><code>&#39;\w\w\d&#39;</code> 可以匹配 <code>&#39;py3&#39;</code>；</li>
<li><code>.</code> 可以匹配任意字符，所以： <code>&#39;py.&#39;</code> 可以匹配 <code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code> 等等。</li>
</ul>
<p>要匹配变长的字符，在正则表达式中，用 <code>*</code> 表示<strong>任意个字符（包括0个）</strong>，用 <code>+</code> 表示<strong>至少一个字符</strong>，用 <code>?</code> 表示<strong>0个或1个字符</strong>，用 <code>{n}</code> 表示<strong>n个字符</strong>，用 <code>{n,m}</code> 表示<strong>n-m个字符</strong>：</p>
<p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code></p>
<p>我们来从左到右解读一下：</p>
<ul>
<li><code>\d{3}</code> 表示匹配3个数字，例如 <code>&#39;010&#39;</code>；</li>
<li><code>\s+</code> 表示至少有一个空格，例如匹配 <code>&#39; &#39;</code>，<code>&#39;  &#39;</code> 等；</li>
<li><code>\d{3,8}</code> 表示3-8个数字，例如 <code>&#39;1234567&#39;</code>。</li>
</ul>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配 <code>&#39;010-12345&#39;</code> 这样的号码呢？由于 <strong><code>&#39;-&#39;</code> 是特殊字符</strong>，在正则表达式中，<strong>要用 <code>&#39;\&#39;</code> 转义</strong>，所以，用于匹配的正则表达式应为 <code>\d{3}\-\d{3,8}</code>。</p>
<p>但是，上面的方法无法匹配 <code>&#39;010 - 12345&#39;</code>，我们需要更复杂的匹配方式。</p>
<hr>
<p><br></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>要做更精确地匹配，可以用 <code>[]</code> 表示一个范围，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code> 可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code> 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code> 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code> 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
<li><code>A|B</code> 可以匹配A或B，所以 <code>(P|p)ython</code> 既可以匹配 <code>&#39;Python&#39;</code> 又可以匹配 <code>&#39;python&#39;</code>。</li>
<li><code>^</code> 表示行的开头，<code>^\d</code> 表示必须以数字开头。</li>
<li><script type="math/tex">` 表示行的结束，`\d</script> 表示必须以数字结束。</li>
</ul>
<p>有趣的是 <code>py</code> 也可以用来匹配 <code>&#39;python&#39;</code>，但是加上 <code>^py$</code> 就变成了整行匹配，只能匹配 <code>&#39;py&#39;</code> 了。</p>
<hr>
<p><br></p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>有了准备知识，我们就可以在Python中使用正则表达式了。Python提供了 <code>re</code> 模块，包含所有正则表达式的功能。注意，在正则表达式中，我们使用 <code>\</code> 来表示转义，但在Python的字符串中，<code>\</code> 同样是一个转义符。因此，使用时我们就要特别注意字符串中的 <code>\</code> 是否能正确地起作用。比方说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'ABC\\-001'</span></div></pre></td></tr></table></figure>
<p>这个字符串中，第一个 <code>\</code> 用于为第二个 <code>\</code> 转义，所以打印这个字符串实际上得到的是 ‘ABC-001’，这样用作正则表达式时，就能正确地转义 <code>-</code>。而：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'ABC\-001'</span></div></pre></td></tr></table></figure>
<p>这个字符串实际上是 <code>&#39;ABC-001&#39;</code>，由于 <code>-</code> 在正则表达式中是一个特殊字符，而这里我们希望的是它只作为用于匹配字符 <code>-</code> 的功能，所以这样得到的正则表达式就出错了。</p>
<p>因此在书写正则表达式时，推荐使用Python字符串的 <code>r</code> 前缀，这样就不用考虑字符转义的问题了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">r'ABC\-001'</span></div></pre></td></tr></table></figure>
<p><strong><code>r</code> 前缀表示后面的字符串中无需转义字符。</strong></p>
<p>接下来看看如何判断正则表达式是否与字符串匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$'</span>, <span class="string">'010-12345'</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$'</span>, <span class="string">'010 12345'</span>)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p><code>re</code> 模块的 <code>match()</code> 方法判断是否匹配，如果匹配成功，返回一个 <code>Match</code> 对象，否则返回 <code>None</code>。常见的判断方法就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test = <span class="string">'用户输入的字符串'</span></div><div class="line"><span class="keyword">if</span> re.match(<span class="string">r'正则表达式'</span>, test):</div><div class="line">    print(<span class="string">'ok'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'failed'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a b   c'</span>.split(<span class="string">' '</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, <span class="string">'a b   c'</span>) <span class="comment"># '\s+'表示至少匹配一个空白字符</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<p>无论多少个空格都可以正常分割。加入 <code>,</code> 试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,]+'</span>, <span class="string">'a,b, c  d'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<p>再加入 <code>;</code> 试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,\;]+'</span>, <span class="string">'a,b;; c  d'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<p>如果用户输入了一组标签，下次记得可以用正则表达式来把不规范的输入转化成正确的数组。</p>
<hr>
<p><br></p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用 <code>()</code> 表示的就是要提取的<strong>分组（Group）</strong>。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code> 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</div><div class="line"><span class="string">'010-12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'010'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'12345'</span></div></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在 <code>Match</code> 对象上用 <code>group()</code> 方法提取出某个子串。注意到 <code>group(0)</code> 永远是原始字符串，<code>group(1)</code>、<code>group(2)</code> …… 表示第1、2、……个子串。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">'19:05:30'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$'</span>, t)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</div><div class="line">(<span class="string">'19'</span>, <span class="string">'05'</span>, <span class="string">'30'</span>)</div></pre></td></tr></table></figure>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'</span></div></pre></td></tr></table></figure>
<p>对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要编写其他代码来配合识别了。</p>
<hr>
<p><br></p>
<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>最后需要特别指出的是，<strong>正则匹配默认是贪婪匹配</strong>，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p>由于 <code>\d+</code> 采用贪婪匹配，直接把后面的0全部匹配了，结果 <code>0*</code> 就只能匹配到空字符串了。</p>
<p>必须让 <code>\d+</code> 采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，这时我们可以使用 <code>?</code> 来让 <code>\d+</code> 采用非贪婪匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，<code>re</code> 模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以<strong>预编译正则表达式</strong>，接下来<strong>重复使用时就不需要编译这个步骤了</strong>，可以直接匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 编译:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</div><div class="line"><span class="comment"># 使用：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</div></pre></td></tr></table></figure>
<p>编译后生成 <code>Regular Expression</code> 对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
<hr>
<p><br></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。</p>
<hr>
<p><br></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="习题一"><a href="#习题一" class="headerlink" title="习题一"></a>习题一</h3><blockquote>
<p>请尝试写一个验证Email地址的正则表达式，可以验证类似以下格式的Email：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">someone@gmail.com</div><div class="line">bill.gates@microsoft.com</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re_email = re.compile(<span class="string">r'^[a-z.]+?@[a-z]+?.com$'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    test = input(<span class="string">'\nPlease input your email address: '</span>)</div><div class="line">    <span class="keyword">if</span> re_email.match(test):</div><div class="line">        print(<span class="string">'ok'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'failed'</span>)</div></pre></td></tr></table></figure>
<hr>
<h3 id="习题二"><a href="#习题二" class="headerlink" title="习题二"></a>习题二</h3><blockquote>
<p>继续上一题，但这次的Email地址带名字，要既能验证地址又能提取出名字：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Tom Paris&gt; tom@voyager.com</div><div class="line">&lt;Mary Liu&gt; mary@microsoft.com</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re_email = re.compile(<span class="string">r'^&lt;([A-Za-z\s]+?)\s([A-Za-z\s]+?)&gt;\s([a-z.]+?@[a-z]+?.com)$'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    test = input(<span class="string">'\nPlease input your email address: '</span>)</div><div class="line">    match = re_email.match(test)</div><div class="line">    <span class="keyword">if</span> match:</div><div class="line">        print(match.group(<span class="number">1</span>)+<span class="string">' '</span>+match.group(<span class="number">2</span>)+<span class="string">"'s email address is: "</span>+match.group(<span class="number">3</span>))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'failed'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-10进程和线程]]></title>
      <url>http://2wildkids.com/2017/01/04/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#简介">简介</a><ul>
<li><a href="#多任务">多任务</a></li>
<li><a href="#进程和线程的含义">进程和线程的含义</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#多进程">多进程</a><ul>
<li><a href="#fork函数">fork函数</a></li>
<li><a href="#multiprocessing">multiprocessing</a></li>
<li><a href="#进程池">进程池</a></li>
<li><a href="#子进程的输入和输出">子进程的输入和输出</a></li>
<li><a href="#进程间通信">进程间通信</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#多线程">多线程</a><ul>
<li><a href="#多线程简单实现">多线程简单实现</a></li>
<li><a href="#线程锁">线程锁</a></li>
<li><a href="#死循环与多核cpu">死循环与多核CPU</a></li>
<li><a href="#小结-2">小结</a></li>
</ul>
</li>
<li><a href="#threadlocal">ThreadLocal</a><ul>
<li><a href="#局部变量的传递">局部变量的传递</a></li>
<li><a href="#threadlocal的用法">ThreadLocal的用法</a></li>
<li><a href="#小结-3">小结</a></li>
</ul>
</li>
<li><a href="#进程-vs-线程">进程 vs. 线程</a><ul>
<li><a href="#比较多进程和多线程">比较多进程和多线程</a></li>
<li><a href="#效率问题">效率问题</a></li>
<li><a href="#计算密集型-vs-io密集型">计算密集型 vs. IO密集型</a></li>
<li><a href="#异步io">异步IO</a></li>
</ul>
</li>
<li><a href="#分布式进程">分布式进程</a><ul>
<li><a href="#简介-1">简介</a></li>
<li><a href="#实现方法">实现方法</a></li>
<li><a href="#小结-4">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>现代操作系统包括Mac OS X，UNIX，Linux，Windows等，它们都是支持“多任务”的操作系统。</p>
<p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>现在多核CPU已经非常普及了，使用不同的核执行不同任务自然也不是什么难事。但是，即使是过去的单核CPU，也可以执行多任务。我们知道，CPU执行代码都是顺序执行的，那么<strong>单核CPU是怎么执行多任务的呢</strong>？</p>
<p>答案就是<strong>操作系统轮流让各个任务交替执行</strong>，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒…… 这样反复执行下去。表面上每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们实际感觉到的就变成了所有任务都在同时执行。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于<strong>任务数量往往是远多于CPU的核心数量的</strong>，要给每个任务都分配一个CPU内核是不现实的，所以实际上操作系统会自动把很多任务轮流调度到每个核心上执行。</p>
<hr>
<h3 id="进程和线程的含义"><a href="#进程和线程的含义" class="headerlink" title="进程和线程的含义"></a>进程和线程的含义</h3><p>对于操作系统来说，一个任务就是一个<strong>进程（Process）</strong>，比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把<strong>进程内的“子任务”称为线程（Thread）</strong>。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，<strong>多个线程可以同时执行</strong>，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正同时执行多线程需要多核CPU才可能实现。</p>
<p>我们前面编写的所有的Python程序，都是执行单任务的进程，并且只有一个线程。如果我们要同时执行多个任务怎么办？有三种解决方案：</p>
<ul>
<li><strong>多进程模式</strong>：启动多个进程，每个进程只有一个线程，但多个进程可以一块执行多个任务；</li>
<li><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程可以一块执行多个任务；</li>
<li><strong>多进程+多线程模式</strong>：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</li>
</ul>
<p>注意，<strong>同时执行的多个任务之间可能是关联的，需要相互通信和协调</strong>。比方说，任务1必须先暂停等待任务2完成后才能继续执行，而任务3和任务4需要操作同一个文件所以不能同时执行。因此，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p>
<p>因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。</p>
<p>Python既支持多进程，又支持多线程，在接下来的这一章，我们会讨论如何编写这两种多任务程序。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>线程是最小的执行单元，进程由至少一个线程组成</strong>。如何调度进程和线程，完全由操作系统决定，程序自己不能决定自己什么时候被执行，执行多长时间。</p>
<p>多进程和多线程的程序涉及到同步、数据共享等问题，编写起来更复杂。</p>
<hr>
<p><br></p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>要让Python程序实现<strong>多进程（multiprocessing）</strong>，我们先得了解操作系统的相关知识。</p>
<p>Unix/Linux操作系统提供了一个 <code>fork()</code> 系统调用函数，它非常特殊。普通的函数在被调用时，调用一次只会返回一次。但是 <code>fork()</code> 函数调用一次会返回两次，因为此时操作系统会自动把当前进程（称为父进程）复制一份（称为子进程），然后分别在父进程和子进程内进行返回。</p>
<p><strong>子进程永远返回0，而父进程返回子进程的ID</strong>。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用 <code>getppid()</code> 就可以拿到父进程的ID。</p>
<p>Python的 <code>os</code> 模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</div><div class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></div><div class="line">pid = os.fork()</div><div class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</div><div class="line">    print(<span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Process (<span class="number">876</span>) start...</div><div class="line">I (<span class="number">876</span>) just created a child process (<span class="number">877</span>).</div><div class="line">I am child process (<span class="number">877</span>) <span class="keyword">and</span> my parent <span class="keyword">is</span> <span class="number">876.</span></div></pre></td></tr></table></figure>
<p>这段代码在执行第一个print时只有一个进程（876），因此只打印一次。然后在执行 <code>fork()</code> 之后，当前进程（876）被复制出一个子进程（877）。当前进程会先返回，返回子进程ID（877），然后往下走进入if-else代码块，进入else语句进行打印；其后子进程（877）返回0，同样往下走，进入if-else代码块，进入if语句进行打印。</p>
<p>由于Windows没有fork调用，上面的代码在Windows上无法运行。而Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的~</p>
<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<hr>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？</p>
<p>由于Python是跨平台的，自然也应该提供跨平台的多进程支持。<code>multiprocessing</code> 模块就是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code> 模块提供了一个 <code>Process</code> 类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 子进程要执行的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</div><div class="line">    print(<span class="string">'Child process will start.'</span>)</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print(<span class="string">'Child process end.'</span>)</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parent process <span class="number">928.</span></div><div class="line">Process will start.</div><div class="line">Run child process test (<span class="number">929</span>)...</div><div class="line">Process end.</div></pre></td></tr></table></figure>
<p>创建子进程时，只需要传入一个执行函数和该函数的参数就可以创建一个 <code>Process</code> 实例。用 <code>start()</code> 方法就可以启动这个子进程，这样创建进程要比 <code>fork()</code> 更简单和灵活。</p>
<p><code>join()</code> 方法可以<strong>等待子进程结束后再继续往下运行</strong>，通常用于进程间的同步。</p>
<hr>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>如果要启动大量的子进程，我们可以用<strong>进程池</strong>的方式来<strong>批量创建子进程</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="comment"># 子进程执行的任务</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class="line">    start = time.time()</div><div class="line">    time.sleep(random.random() * <span class="number">3</span>)</div><div class="line">    end = time.time()</div><div class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">    p = Pool(<span class="number">4</span>) <span class="comment"># 创建一个大小为4的进程池</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment"># 依次创建5个子进程</span></div><div class="line">        p.apply_async(long_time_task, args=(i,))</div><div class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</div><div class="line">    p.close()</div><div class="line">    p.join()</div><div class="line">    print(<span class="string">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Parent process <span class="number">669.</span></div><div class="line">Waiting <span class="keyword">for</span> all subprocesses done...</div><div class="line">Run task <span class="number">0</span> (<span class="number">671</span>)...</div><div class="line">Run task <span class="number">1</span> (<span class="number">672</span>)...</div><div class="line">Run task <span class="number">2</span> (<span class="number">673</span>)...</div><div class="line">Run task <span class="number">3</span> (<span class="number">674</span>)...</div><div class="line">Task <span class="number">2</span> runs <span class="number">0.14</span> seconds.</div><div class="line">Run task <span class="number">4</span> (<span class="number">673</span>)...</div><div class="line">Task <span class="number">1</span> runs <span class="number">0.27</span> seconds.</div><div class="line">Task <span class="number">3</span> runs <span class="number">0.86</span> seconds.</div><div class="line">Task <span class="number">0</span> runs <span class="number">1.41</span> seconds.</div><div class="line">Task <span class="number">4</span> runs <span class="number">1.91</span> seconds.</div><div class="line">All subprocesses done.</div></pre></td></tr></table></figure>
<p>代码解读：</p>
<p>对 <code>Pool</code> 对象调用 <code>join()</code> 方法会等待所有子进程执行完毕，<strong>调用 <code>join()</code> 之前必须先调用 <code>close()</code>，调用 <code>close()</code> 之后就不能往进程池中继续添加新的 <code>Process</code> 了</strong>。</p>
<p>请注意输出的结果，task 0，1，2，3这四个子进程是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为我们定义进程池时定义了大小为4，也即最多同时执行4个进程，所以第5个进程就要等进程池里有空位了才能开始。如果改成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = Pool(<span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>就可以同时跑5个进程。</p>
<p>当没有传入参数时，<strong>Pool的默认大小是CPU的核数</strong>，所以如果电脑是4核CPU则默认进程池大小为4，如果电脑是8核CPU则默认进程池大小为8。</p>
<hr>
<h3 id="子进程的输入和输出"><a href="#子进程的输入和输出" class="headerlink" title="子进程的输入和输出"></a>子进程的输入和输出</h3><p>很多时候，子进程和父进程要执行的不是同一个任务。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code> 模块可以让我们非常方便地启动一个子进程，并且控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令 <code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"></div><div class="line">print(<span class="string">'$ nslookup www.python.org'</span>)</div><div class="line">r = subprocess.call([<span class="string">'nslookup'</span>, <span class="string">'www.python.org'</span>])</div><div class="line">print(<span class="string">'Exit code:'</span>, r)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ nslookup www.python.org</div><div class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></div><div class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">www.python.org    canonical name = python.map.fastly.net.</div><div class="line">Name:    python.map.fastly.net</div><div class="line">Address: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span></div><div class="line"></div><div class="line">Exit code: <span class="number">0</span></div></pre></td></tr></table></figure>
<p>看看帮助文档中 <code>subprocess</code> 模块的 <code>call()</code> 函数的描述：</p>
<blockquote>
<p>Run command with arguments.  Wait for command to complete or timeout, then return the returncode attribute.</p>
</blockquote>
<p>它可以帮助我们建立一个子进程来执行系统调用函数，并且允许传入函数，调用后会等待运行结束并最终返回调用函数的返回值，之后才继续执行后续代码。可以只传入一个列表，列表第一个元素为系统调用的名称，第二个元素为参数。</p>
<p>如果子进程<strong>执行的过程中</strong>还需要其他输入，我们使用 <code>subprocess</code> 模块的 <code>Popen</code> 类初始化子进程，并通过它的 <code>communicate()</code> 方法来实现进程执行过程中的多次输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"></div><div class="line">print(<span class="string">'$ nslookup'</span>)</div><div class="line">p = subprocess.Popen([<span class="string">'nslookup'</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</div><div class="line">output, err = p.communicate(<span class="string">b'set q=mx\npython.org\nexit\n'</span>) <span class="comment"># 每次输入之间用换行符隔开</span></div><div class="line">print(output.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 返回的是字节流，所以要先解码</span></div><div class="line">print(<span class="string">'Exit code:'</span>, p.returncode)</div></pre></td></tr></table></figure>
<p>上面的代码相当于在命令行执行命令 <code>nslookup</code>，然后手动输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set q=mx</div><div class="line">python.org</div><div class="line">exit</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ nslookup</div><div class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></div><div class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">python.org    mail exchanger = <span class="number">50</span> mail.python.org.</div><div class="line"></div><div class="line">Authoritative answers can be found <span class="keyword">from</span>:</div><div class="line">mail.python.org    internet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span></div><div class="line">mail.python.org    has AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6</div><div class="line"></div><div class="line"></div><div class="line">Exit code: <span class="number">0</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的 <code>multiprocessing</code> 模块包装了底层的机制，提供了 <code>Queue</code>、<code>Pipes</code> 等多种方式来交换数据。</p>
<p>我们以 <code>Queue</code> 为例，在父进程中创建两个子进程，第一个子进程往 <code>Queue</code> 里写数据，第二个子进程从 <code>Queue</code> 里读数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="comment"># 写数据进程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></div><div class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</div><div class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</div><div class="line">        q.put(value)</div><div class="line">        time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="comment"># 读数据进程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></div><div class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        value = q.get(<span class="keyword">True</span>)</div><div class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></div><div class="line">    q = Queue()</div><div class="line">    pw = Process(target=write, args=(q,))</div><div class="line">    pr = Process(target=read, args=(q,))</div><div class="line">    <span class="comment"># 启动子进程pw，写入:</span></div><div class="line">    pw.start()</div><div class="line">    <span class="comment"># 启动子进程pr，读取:</span></div><div class="line">    pr.start()</div><div class="line">    <span class="comment"># 等待pw结束:</span></div><div class="line">    pw.join()</div><div class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></div><div class="line">    pr.terminate()</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Process to write: <span class="number">50563</span></div><div class="line">Put A to queue...</div><div class="line">Process to read: <span class="number">50564</span></div><div class="line">Get A <span class="keyword">from</span> queue.</div><div class="line">Put B to queue...</div><div class="line">Get B <span class="keyword">from</span> queue.</div><div class="line">Put C to queue...</div><div class="line">Get C <span class="keyword">from</span> queue.</div></pre></td></tr></table></figure>
<p>在Unix/Linux下，<code>multiprocessing</code> 模块封装了 <code>fork()</code> 调用，使我们不需要关注 <code>fork()</code> 的细节。由于Windows没有fork调用，因此，<code>multiprocessing</code> 需要“模拟”出fork的效果，<strong>父进程的所有Python对象都必须先通过 <code>pickle</code> 序列化再传到子进程去</strong>。所以，如果 <code>multiprocessing</code> 在Windows下调用失败了，就要先考虑是不是序列化失败了。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在Unix/Linux下，可以使用 <code>fork()</code> 调用实现多进程。</p>
<p>要实现跨平台的多进程，可以使用 <code>multiprocessing</code> 模块。</p>
<p>进程间通信可以通过 <code>Queue</code>、<code>Pipes</code> 等实现的。</p>
<hr>
<p><br></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程简单实现"><a href="#多线程简单实现" class="headerlink" title="多线程简单实现"></a>多线程简单实现</h3><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code> 和 <code>threading</code>，<code>_thread</code> 是低级模块，threading是高级模块，对 <code>_thread</code> 进行了封装。绝大多数情况下，我们只需要使用 <code>threading</code> 这个高级模块。</p>
<p>使用 <code>threading</code> 时，我们可以创建 <code>Thread</code> 实例来建立新的线程，然后调用 <code>start()</code> 启动该线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time, threading</div><div class="line"></div><div class="line"><span class="comment"># 新线程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</div><div class="line">    n = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</div><div class="line"></div><div class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</div><div class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</div><div class="line">t.start()</div><div class="line">t.join()</div><div class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">thread MainThread <span class="keyword">is</span> running...</div><div class="line">thread LoopThread <span class="keyword">is</span> running...</div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">1</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">2</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">3</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">4</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">5</span></div><div class="line">thread LoopThread ended.</div><div class="line">thread MainThread ended.</div></pre></td></tr></table></figure>
<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的 <code>threading</code> 模块有个 <code>current_thread()</code> 函数，它永远返回当前线程的实例。<strong>主线程实例的名字叫 <code>MainThread</code>，子线程的名字在创建时指定</strong>，我们用 <code>LoopThread</code> 命名子线程。名字仅仅在打印时用来显示，没有其他意义，如果不起名字Python就会自动给线程命名为 <code>Thread-1</code>，<code>Thread-2</code>……</p>
<hr>
<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响。而<strong>多线程中，所有变量都由所有线程共享</strong>，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程<strong>同时改一个变量</strong>，把内容给改乱了。</p>
<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time, threading</div><div class="line"></div><div class="line"><span class="comment"># 假定这是你的银行存款:</span></div><div class="line">balance = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="comment"># 先加后减，结果应该为0:</span></div><div class="line">    <span class="keyword">global</span> balance</div><div class="line">    balance = balance + n</div><div class="line">    balance = balance - n</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">        change_it(n)</div><div class="line"></div><div class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</div><div class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</div><div class="line">t1.start()</div><div class="line">t2.start()</div><div class="line">t1.join()</div><div class="line">t2.join()</div><div class="line">print(balance)</div></pre></td></tr></table></figure>
<p>注意，<code>change_it()</code> 函数中，使用了global关键字来声明使用的 <code>balance</code> 变量是在函数定义外部的，这样在函数内部的修改也会反映到函数外部。</p>
<p><code>balance</code>，初始值为0，并且启动两个线程，先加后减，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，在某个时刻，线程t1和t2同时对 <code>balance</code> 变量进行修改，那么最终结果就不一定是0了。比方说：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">线程</th>
<th style="text-align:center">balance</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">+5</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-5</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">+8</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-8</td>
</tr>
<tr>
<td style="text-align:center">04</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">+5</td>
</tr>
<tr>
<td style="text-align:center">05</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">+8</td>
</tr>
<tr>
<td style="text-align:center">06</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">13</td>
<td style="text-align:center">-8</td>
</tr>
<tr>
<td style="text-align:center">07</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-5</td>
</tr>
<tr>
<td style="text-align:center">08</td>
<td style="text-align:center">t1,t2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">+5,+8</td>
</tr>
<tr>
<td style="text-align:center">09</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-5</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-8</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">-5</td>
<td style="text-align:center">+5</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">+8</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">t1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-5</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">t2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-8</td>
</tr>
</tbody>
</table>
</div>
<p>假设在08时刻，t1和t2同时执行 <code>balance = balance + n</code> 这个语句，右边的 <code>balance</code> 都取0，那么t1执行完该语句时 <code>balance</code> 为5，而t2执行完时 <code>balance</code> 为8，假设t2后执行完毕，那么 <code>balance</code> 就取8，这时就产生错误了，并且错误会继续累积，当循环次数达到一定规模时，这种错误的累积会非常可怕。</p>
<p>为什么会产生这样的错误呢？其实 呀，这时因为高级语言的一条语句在CPU执行时需要转换为多条汇编指令，即使一个简单的计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">balance = balance + n</div></pre></td></tr></table></figure>
<p>也需要分为两步：</p>
<ol>
<li>计算 <code>balance + n</code>，存入临时变量中；</li>
<li>将临时变量的值赋给 <code>balance</code>。</li>
</ol>
<p>可以看成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = balance + n</div><div class="line">balance = x</div></pre></td></tr></table></figure>
<p>临时变量 <code>x</code> 是一个<strong>局部变量</strong>，两个线程各自都有自己的 <code>x</code>，所以当代码正常执行时：</p>
<p>初始值 <code>balance = 0</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">t1: x1 = balance + <span class="number">5</span> <span class="comment"># x1 = 0 + 5 = 5</span></div><div class="line">t1: balance = x1     <span class="comment"># balance = 5</span></div><div class="line">t1: x1 = balance - <span class="number">5</span> <span class="comment"># x1 = 5 - 5 = 0</span></div><div class="line">t1: balance = x1     <span class="comment"># balance = 0</span></div><div class="line"></div><div class="line">t2: x2 = balance + <span class="number">8</span> <span class="comment"># x2 = 0 + 8 = 8</span></div><div class="line">t2: balance = x2     <span class="comment"># balance = 8</span></div><div class="line">t2: x2 = balance - <span class="number">8</span> <span class="comment"># x2 = 8 - 8 = 0</span></div><div class="line">t2: balance = x2     <span class="comment"># balance = 0</span></div></pre></td></tr></table></figure>
<p>结果 <code>balance = 0</code></p>
<p>但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：</p>
<p>初始值 <code>balance = 0</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t1: x1 = balance + <span class="number">5</span>  <span class="comment"># x1 = 0 + 5 = 5</span></div><div class="line"></div><div class="line">t2: x2 = balance + <span class="number">8</span>  <span class="comment"># x2 = 0 + 8 = 8</span></div><div class="line">t2: balance = x2      <span class="comment"># balance = 8</span></div><div class="line"></div><div class="line">t1: balance = x1      <span class="comment"># balance = 5</span></div><div class="line">t1: x1 = balance - <span class="number">5</span>  <span class="comment"># x1 = 5 - 5 = 0</span></div><div class="line">t1: balance = x1      <span class="comment"># balance = 0</span></div><div class="line"></div><div class="line">t2: x2 = balance - <span class="number">8</span>  <span class="comment"># x2 = 0 - 8 = -8</span></div><div class="line">t2: balance = x2   <span class="comment"># balance = -8</span></div></pre></td></tr></table></figure>
<p>结果 <code>balance = -8</code>，自然就不对了</p>
<p>究其原因，是因为修改 <code>balance</code> 需要多条语句，而执行这几条语句时，线程可能中断，其他线程可能也会对 <code>balance</code> 进行了修改，从而导致多个线程把同一个对象的内容改乱了。所以，我们必须确保一个线程在修改 <code>balance</code> 的时候，别的线程一定不能改。</p>
<p>如果我们要确保 <code>balance</code> 计算正确，就要给 <code>change_it()</code> 上一把锁，当某个线程开始执行 <code>change_it()</code> 时，我们说，该线程获得了锁，因此其他线程不能同时执行 <code>change_it()</code>，只能等待锁被释放，线程获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁可以通过 <code>threading.Lock()</code> 来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">balance = <span class="number">0</span></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">        <span class="comment"># 先要获取锁:</span></div><div class="line">        lock.acquire()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="comment"># 放心地改吧:</span></div><div class="line">            change_it(n)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            <span class="comment"># 改完了一定要释放锁:</span></div><div class="line">            lock.release()</div></pre></td></tr></table></figure>
<p>当多个线程同时执行 <code>lock.acquire()</code> 时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p><strong>获得锁的线程用完后一定要释放锁</strong>，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们<strong>用 <code>try...finally</code> 来确保锁一定会被释放</strong>。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以构造多个不同的锁，<strong>不同的线程持有不同的锁，在试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止</strong>。</p>
<hr>
<h3 id="死循环与多核CPU"><a href="#死循环与多核CPU" class="headerlink" title="死循环与多核CPU"></a>死循环与多核CPU</h3><p>如果你拥有一个多核CPU，肯定就会想到不同的核应该可以同时执行不同的多个线程。</p>
<p>如果写一个死循环的话，会出现什么情况呢？</p>
<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。我们可以监控到一个死循环线程会100%占用一个CPU。如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading, multiprocessing</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></div><div class="line">    x = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = x ^ <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count()):</div><div class="line">    t = threading.Thread(target=loop)</div><div class="line">    t.start()</div></pre></td></tr></table></figure>
<p>启动与CPU核心数量相同的N个线程，可以监控到CPU占用率仅有102%，也就是仅使用了一核。但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个<strong>GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁</strong>，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，<strong>多线程在Python中只能交替执行</strong>，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但<strong>可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响</strong>。</p>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>
<p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程并发在Python中就是一个美丽的梦。</p>
<hr>
<p><br></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="局部变量的传递"><a href="#局部变量的传递" class="headerlink" title="局部变量的传递"></a>局部变量的传递</h3><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">(name)</span>:</span></div><div class="line">    std = Student(name)</div><div class="line">    <span class="comment"># std是局部变量，但是每个函数都要用它，因此必须传进去：</span></div><div class="line">    do_task_1(std)</div><div class="line">    do_task_2(std)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">(std)</span>:</span></div><div class="line">    do_subtask_1(std)</div><div class="line">    do_subtask_2(std)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_2</span><span class="params">(std)</span>:</span></div><div class="line">    do_subtask_2(std)</div><div class="line">    do_subtask_2(std)</div></pre></td></tr></table></figure>
<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的 <code>Student</code> 对象，所以不能共享。</p>
<p>如果用一个全局的 <code>dict</code> 存放所有的 <code>Student</code> 对象，以线程自身作为 <code>key</code> 和存取对应的 <code>Student</code> 对象如何呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">global_dict = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">std_thread</span><span class="params">(name)</span>:</span></div><div class="line">    std = Student(name)</div><div class="line">    <span class="comment"># 把std放到全局变量global_dict中：</span></div><div class="line">    global_dict[threading.current_thread()] = std</div><div class="line">    do_task_1()</div><div class="line">    do_task_2()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 不传入std，而是根据当前线程查找：</span></div><div class="line">    std = global_dict[threading.current_thread()]</div><div class="line">    ...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_2</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 任何函数都可以查找出当前线程的std变量：</span></div><div class="line">    std = global_dict[threading.current_thread()]</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>这种方式理论上是可行的，它最大的优点是消除了 <code>std</code> 对象在每层函数中的传递问题，但是，每个函数获取 <code>std</code> 的代码有点丑。</p>
<hr>
<h3 id="ThreadLocal的用法"><a href="#ThreadLocal的用法" class="headerlink" title="ThreadLocal的用法"></a>ThreadLocal的用法</h3><p>有没有更简单的方式？<code>ThreadLocal</code> 应运而生，不用查找 <code>dict</code>，<code>ThreadLocal</code> 可以自动帮我们做这件事：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></div><div class="line">local_school = threading.local()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 获取当前线程关联的student:</span></div><div class="line">    std = local_school.student</div><div class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></div><div class="line">    local_school.student = name</div><div class="line">    process_student()</div><div class="line"></div><div class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</div><div class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</div><div class="line">t1.start()</div><div class="line">t2.start()</div><div class="line">t1.join()</div><div class="line">t2.join()</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</div><div class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</div></pre></td></tr></table></figure>
<p>全局变量 <code>local_school</code> 就是一个 <code>ThreadLocal</code> 对象，每个线程都可以对它进行读写，线程之间互不影响。你可以把 <code>local_school</code> 看成全局变量，但每个属性如 <code>local_school.student</code> 都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code> 内部会处理。也可以把 <code>local_school</code> 理解为一个全局的 <code>dict</code>，不但可以绑定 <code>local_school.student</code>，还可以绑定其他变量，如 <code>local_school.teacher</code> 等等。</p>
<p><code>ThreadLocal</code> 最常用的地方就是为每个线程绑定一个不同的数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><code>ThreadLocal</code> 虽然是全局的，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<hr>
<p><br></p>
<h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h2><h3 id="比较多进程和多线程"><a href="#比较多进程和多线程" class="headerlink" title="比较多进程和多线程"></a>比较多进程和多线程</h3><p>我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p>
<p>首先，要实现多任务，通常我们会设计<strong>主从模式（Master-Worker模式）</strong>，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<ul>
<li>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</li>
<li>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</li>
</ul>
<p>多进程模式最大的优点就是<strong>稳定性高</strong>，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是<strong>创建进程的代价大</strong>，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，<strong>操作系统能同时运行的进程数也是有限的</strong>，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是<strong>任何一个线程挂掉都可能直接造成整个进程崩溃</strong>，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p><strong>在Windows下，多线程的效率比多进程要高</strong>，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>
<hr>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时。这种每次只完成一个任务的方式称为<strong>单任务模型</strong>，或者<strong>批处理任务模型</strong>。</p>
<p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫<strong>保存现场</strong>），然后，打开数学课本、找出圆规直尺（这叫<strong>准备新环境</strong>），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<hr>
<h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，<strong>要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数</strong>。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。<strong>Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写</strong>。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于<strong>IO密集型任务，任务越多，CPU效率越高，但也有一个限度</strong>。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<hr>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持<strong>异步IO</strong>。如果充分利用操作系统提供的异步IO支持，就可以<strong>用单进程单线程模型来执行多任务</strong>，这种全新的模型称为<strong>事件驱动模型</strong>，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>所谓异步IO，其实这个异步是指使用者发起IO请求后并不马上得到结果。比方说有一些需要处理的数据放在磁盘上，使用者预先知道这些数据的位置，所以预先发起异步IO读请求。而等到真正需要用到这些数据的时候，再等待异步IO完成，对数据进行处理。这样做的话，在发起IO请求到实际使用数据这段时间内，程序还可以继续做其他事情。</p>
<p>对应到Python语言，<strong>单进程的异步编程模型称为协程</strong>，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p>
<hr>
<p><br></p>
<h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在线程和进程中，应当<strong>优先选择进程</strong>，因为进程更稳定，而且，<strong>进程可以分布到多台机器上，而线程最多只能分布到同一台机器的多个CPU上</strong>。</p>
<p>Python的 <code>multiprocessing</code> 模块不但支持多进程，其中 <code>managers</code> 子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于 <code>managers</code> 模块封装很好，我们不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过 <code>Queue</code> 通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的 <code>Queue</code> 可以继续使用，但是，通过 <code>managers</code> 模块把 <code>Queue</code> <strong>通过网络暴露出去</strong>，就可以让其他机器的进程访问 <code>Queue</code> 了。</p>
<hr>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>我们先看服务进程，服务进程负责启动 <code>Queue</code>，把 <code>Queue</code> 注册到网络上，然后往 <code>Queue</code> 里面写入任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># task_master.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random, time, queue</div><div class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</div><div class="line"></div><div class="line"><span class="comment"># 发送任务的队列:</span></div><div class="line">task_queue = queue.Queue()</div><div class="line"><span class="comment"># 接收结果的队列:</span></div><div class="line">result_queue = queue.Queue()</div><div class="line"></div><div class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></div><div class="line">QueueManager.register(<span class="string">'get_task_queue'</span>, callable=<span class="keyword">lambda</span>: task_queue)</div><div class="line">QueueManager.register(<span class="string">'get_result_queue'</span>, callable=<span class="keyword">lambda</span>: result_queue)</div><div class="line"><span class="comment"># 绑定端口5000, 设置验证码'abc':</span></div><div class="line">manager = QueueManager(address=(<span class="string">''</span>, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</div><div class="line"><span class="comment"># 启动Queue:</span></div><div class="line">manager.start()</div><div class="line"><span class="comment"># 获得通过网络访问的Queue对象:</span></div><div class="line">task = manager.get_task_queue()</div><div class="line">result = manager.get_result_queue()</div><div class="line"><span class="comment"># 放几个任务进去:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</div><div class="line">    print(<span class="string">'Put task %d...'</span> % n)</div><div class="line">    task.put(n)</div><div class="line"><span class="comment"># 从result队列读取结果:</span></div><div class="line">print(<span class="string">'Try get results...'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    r = result.get(timeout=<span class="number">10</span>)</div><div class="line">    print(<span class="string">'Result: %s'</span> % r)</div><div class="line"><span class="comment"># 关闭:</span></div><div class="line">manager.shutdown()</div><div class="line">print(<span class="string">'master exit.'</span>)</div></pre></td></tr></table></figure>
<p>请注意，当我们在一台机器上写多进程程序时，创建的 <code>Queue</code> 可以直接拿来用，但是，在分布式多进程环境下，添加任务到 <code>Queue</code> <strong>不可以直接对原始的 <code>task_queue</code> 进行操作</strong>，那样就绕过了 <code>QueueManager</code> 的封装，必须通过 <code>manager.get_task_queue()</code> 获得的 <code>Queue</code> 接口添加任务。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># task_worker.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time, sys, queue</div><div class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</div><div class="line"></div><div class="line"><span class="comment"># 创建类似的QueueManager:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></div><div class="line">QueueManager.register(<span class="string">'get_task_queue'</span>)</div><div class="line">QueueManager.register(<span class="string">'get_result_queue'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 连接到服务器，也就是运行task_master.py的机器:</span></div><div class="line">server_addr = <span class="string">'127.0.0.1'</span> <span class="comment"># 这里因为worker用的也是本机，所以写回送地址就可以了</span></div><div class="line">print(<span class="string">'Connect to server %s...'</span> % server_addr)</div><div class="line"><span class="comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span></div><div class="line">m = QueueManager(address=(server_addr, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</div><div class="line"><span class="comment"># 从网络连接:</span></div><div class="line">m.connect()</div><div class="line"><span class="comment"># 获取Queue的对象:</span></div><div class="line">task = m.get_task_queue()</div><div class="line">result = m.get_result_queue()</div><div class="line"><span class="comment"># 从task队列取任务,并把结果写入result队列:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        n = task.get(timeout=<span class="number">1</span>)</div><div class="line">        print(<span class="string">'run task %d * %d...'</span> % (n, n))</div><div class="line">        r = <span class="string">'%d * %d = %d'</span> % (n, n, n*n)</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        result.put(r)</div><div class="line">    <span class="keyword">except</span> Queue.Empty:</div><div class="line">        print(<span class="string">'task queue is empty.'</span>)</div><div class="line"><span class="comment"># 处理结束:</span></div><div class="line">print(<span class="string">'worker exit.'</span>)</div></pre></td></tr></table></figure>
<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动 <code>task_master.py</code> 服务进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ python3 task_master.py</div><div class="line">Put task <span class="number">3411.</span>..</div><div class="line">Put task <span class="number">1605.</span>..</div><div class="line">Put task <span class="number">1398.</span>..</div><div class="line">Put task <span class="number">4729.</span>..</div><div class="line">Put task <span class="number">5300.</span>..</div><div class="line">Put task <span class="number">7471.</span>..</div><div class="line">Put task <span class="number">68.</span>..</div><div class="line">Put task <span class="number">4219.</span>..</div><div class="line">Put task <span class="number">339.</span>..</div><div class="line">Put task <span class="number">7866.</span>..</div><div class="line">Try get results...</div></pre></td></tr></table></figure>
<p><code>task_master.py</code> 进程发送完任务后，开始等待 <code>result</code> 队列的结果。现在启动 <code>task_worker.py</code> 进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ python3 task_worker.py</div><div class="line">Connect to server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</div><div class="line">run task <span class="number">3411</span> * <span class="number">3411.</span>..</div><div class="line">run task <span class="number">1605</span> * <span class="number">1605.</span>..</div><div class="line">run task <span class="number">1398</span> * <span class="number">1398.</span>..</div><div class="line">run task <span class="number">4729</span> * <span class="number">4729.</span>..</div><div class="line">run task <span class="number">5300</span> * <span class="number">5300.</span>..</div><div class="line">run task <span class="number">7471</span> * <span class="number">7471.</span>..</div><div class="line">run task <span class="number">68</span> * <span class="number">68.</span>..</div><div class="line">run task <span class="number">4219</span> * <span class="number">4219.</span>..</div><div class="line">run task <span class="number">339</span> * <span class="number">339.</span>..</div><div class="line">run task <span class="number">7866</span> * <span class="number">7866.</span>..</div><div class="line">worker exit.</div></pre></td></tr></table></figure>
<p><code>task_worker.py</code> 进程结束，在 <code>task_master.py</code> 进程中会继续打印出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Result: <span class="number">3411</span> * <span class="number">3411</span> = <span class="number">11634921</span></div><div class="line">Result: <span class="number">1605</span> * <span class="number">1605</span> = <span class="number">2576025</span></div><div class="line">Result: <span class="number">1398</span> * <span class="number">1398</span> = <span class="number">1954404</span></div><div class="line">Result: <span class="number">4729</span> * <span class="number">4729</span> = <span class="number">22363441</span></div><div class="line">Result: <span class="number">5300</span> * <span class="number">5300</span> = <span class="number">28090000</span></div><div class="line">Result: <span class="number">7471</span> * <span class="number">7471</span> = <span class="number">55815841</span></div><div class="line">Result: <span class="number">68</span> * <span class="number">68</span> = <span class="number">4624</span></div><div class="line">Result: <span class="number">4219</span> * <span class="number">4219</span> = <span class="number">17799961</span></div><div class="line">Result: <span class="number">339</span> * <span class="number">339</span> = <span class="number">114921</span></div><div class="line">Result: <span class="number">7866</span> * <span class="number">7866</span> = <span class="number">61873956</span></div></pre></td></tr></table></figure>
<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算 <code>n*n</code> 的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p><code>Queue</code> 对象存储在哪？注意到 <code>task_worker.py</code> 中根本没有创建 <code>Queue</code> 的代码，所以，<code>Queue</code> 对象是存储在 <code>task_master.py</code> 进程中的：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_task_master_worker.png" alt="task_master_worker"></p>
<p>而 <code>Queue</code> 之所以能通过网络访问，就是通过 <code>QueueManager</code> 实现的。由于 <code>QueueManager</code> 管理的不止一个 <code>Queue</code>，所以，要给每个 <code>Queue</code> 的网络调用接口起个名字，比如 <code>get_task_queue</code>。</p>
<p><code>authkey</code> 有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果 <code>task_worker.py</code> 的 <code>authkey</code> 和 <code>task_master.py</code> 的 <code>authkey</code> 不一致，肯定连接不上。</p>
<hr>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>
<p>注意 <code>Queue</code> 的作用是用来传递任务和接收结果，每个任务的描述数据要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>
<hr>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-09IO编程]]></title>
      <url>http://2wildkids.com/2016/12/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09IO%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#什么是io">什么是IO</a></li>
<li><a href="#文件读写">文件读写</a><ul>
<li><a href="#读文件">读文件</a></li>
<li><a href="#写文件">写文件</a></li>
<li><a href="#file-like-object">file-like Object</a></li>
<li><a href="#二进制文件">二进制文件</a></li>
<li><a href="#字符编码">字符编码</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#stringio和bytesio">StringIO和BytesIO</a><ul>
<li><a href="#stringio">StringIO</a></li>
<li><a href="#bytesio">BytesIO</a></li>
<li><a href="#为什么使用stringio和bytesio">为什么使用StringIO和BytesIO</a></li>
<li><a href="#读写io需要注意的地方">读写IO需要注意的地方</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#操作目录和文件">操作目录和文件</a><ul>
<li><a href="#简述">简述</a></li>
<li><a href="#环境变量">环境变量</a></li>
<li><a href="#操作目录和文件-1">操作目录和文件</a></li>
<li><a href="#小结-2">小结</a></li>
<li><a href="#练习">练习</a></li>
</ul>
</li>
<li><a href="#序列化">序列化</a><ul>
<li><a href="#序列化和反序列化">序列化和反序列化</a></li>
<li><a href="#序列化（pickle）">序列化（pickle）</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#json进阶">JSON进阶</a></li>
<li><a href="#小结-3">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>IO在计算机中指<strong>输入和输出（Input/Output）</strong>。由于程序运行时，数据是在内存中驻留，并由CPU这个超快的计算核心来进行处理的（处理时会把数据从内存载入到CPU的高速缓存中），而涉及到数据交换的操作，比如磁盘读写、网络传输等的时候，就需要使用IO接口来协调了。</p>
<p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p>
<p>IO编程中，<strong>流（Stream）是</strong>一个很重要的概念，可以把流想象成一个水管，<strong>数据就是水管里的水，但是只能单向流动</strong>。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器程序和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在<strong>速度严重不匹配</strong>的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<ul>
<li><p>第一种方法是让CPU等待，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为<strong>同步IO</strong>；</p>
</li>
<li><p>第二种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以继续执行，这种模式称为<strong>异步IO</strong>。</p>
</li>
</ul>
<p>同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。</p>
<p>你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，<strong>等做好了，我们再通知你</strong>，这样你可以立刻去干别的事情（逛商场），这是异步IO。</p>
<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员亲自跑过来找到你，这是<strong>回调模式</strong>，如果服务员发短信通知你，你就得不停地检查手机，这是<strong>轮询模式</strong>。总之，异步IO的复杂度远远高于同步IO。</p>
<p><strong>操作IO的能力都是由操作系统提供的</strong>，<strong>编程语言所做的只是把操作系统提供的低级C接口封装起来方便使用</strong>，Python也不例外。后面的小节中会详细讨论Python的IO编程接口。</p>
<p>注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时会再作讨论。</p>
<hr>
<p><br></p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，<strong>在磁盘上读写文件的功能都是由操作系统提供的</strong>，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<hr>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，可以使用Python内置的 <code>open()</code> 函数，传入文件名（如果文件和代码文件在相同文件夹下就可以省略路径）和标示符 <code>&#39;r&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'r'</span>)</div></pre></td></tr></table></figure>
<p>标示符 <code>&#39;r&#39;</code> 表示读，这样，我们就成功地打开了一个文件。</p>
<p>如果文件不存在，<code>open()</code> 函数就会抛出一个 <code>IOError</code> 的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'/Users/michael/notfound.txt'</span>, <span class="string">'r'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'/Users/michael/notfound.txt'</span></div></pre></td></tr></table></figure>
<p>如果文件打开成功，我们就可以调用 <code>read()</code> 方法来一次读取文件的全部内容，Python会把为文件的内容读到内存，返回的是一个 <code>str</code> 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">'Hello, world!'</span></div></pre></td></tr></table></figure>
<p>读取完毕后，如果不需要继续操作文件对象，我们就应当调用 <code>close()</code> 方法来关闭它。因为<strong>文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure>
<p>由于读写文件都有可能产生 <code>IOError</code>，一旦出错，后面的 <code>f.close()</code> 就不会调用。所以，为了<strong>保证无论是否出错都能正确地关闭文件</strong>，我们可以使用 <code>try ... finally</code> 来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</div><div class="line">    print(f.read())</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">if</span> f:</div><div class="line">        f.close()</div></pre></td></tr></table></figure>
<p>但是每次都这么写实在太繁琐，所以，Python引入了 <code>with</code> 语句来自动帮我们调用 <code>close()</code> 方法（（在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/08%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95.md" target="_blank" rel="external">上一章</a>中有 <code>with</code> 语句使用及原理的介绍））：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    print(f.read())</div></pre></td></tr></table></figure>
<p>这和前面的 <code>try ... finally</code> 实现的效果是一样的，但是代码更简洁，并且我们不必调用 <code>f.close()</code> 方法。</p>
<p>调用 <code>read()</code> 方法可以一次性读取文件的全部内容。但如果文件有10G，内存就爆了，所以，为了保险起见，我们可以多次调用 <code>read(size)</code> 方法，每次最多读取size个<strong>字节</strong>的内容。</p>
<p>但是有时候文件不一定有严格的格式，比方说读取一篇文章，这时按字节读取就不太合适了。但我们可以调用 <code>readline()</code> 方法，<code>readline()</code> 方法每次读取文件的一行内容。而调用 <code>readlines()</code> 方法则会一次读取文件的所有内容并按行返回一个 <code>list</code> 对象。我们可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</div><div class="line">    print(line.strip()) <span class="comment"># 把末尾的换行符'\n'删掉再打印</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用 <code>open()</code>函数时，传入标识符 <code>&#39;w&#39;</code> 或者 <code>&#39;wb&#39;</code> 表示写文本文件或写二进制文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'w'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello, world!'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure>
<p>你可以多次调用 <code>write()</code> 来写入文件，但是<strong>最后一定要调用 <code>f.close()</code> 来关闭文件</strong>。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是<strong>放在内存中缓存起来，空闲的时候再慢慢写入</strong>。只有调用 <code>close()</code> 方法时，操作系统才会保证把没有写入的数据全部写入磁盘。忘记 <code>close()</code> 的后果是<strong>数据可能只有一部分写到了磁盘，剩下的丢失了</strong>。为了避免这样的情况发生，类似上一节所介绍的，我们可以使用 <code>with</code> 语句自动管理上下文：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(<span class="string">'Hello, world!'</span>)</div></pre></td></tr></table></figure>
<p>如果要写入特定编码的文本文件，还可以给 <code>open()</code> 函数传入 <code>encoding</code> 参数，将要写入的字符串自动转换成指定编码。</p>
<hr>
<h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>在Python中，除了文件对象之外，内存中的字节流，网络流，自定义流等等，拥有 <code>read()</code> 方法的对象统称为 <strong><code>file-like Object</code></strong>。<code>file-like Object</code> 不需要继承自特定的类，只要有 <code>read()</code> 方法就行（文件对象的其他方法不一定都需要实现，可以看看<a href="https://docs.python.org/2.4/lib/bltin-file-objects.html" target="_blank" rel="external">官方说明</a>），这得益于Python鸭子类型的实现。<code>StringIO</code> 就是在内存中创建的 <code>file-like Object</code>，常用作临时缓冲。</p>
<hr>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用 <code>&#39;rb&#39;</code> 模式打开文件即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/test.jpg'</span>, <span class="string">'rb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...'</span> <span class="comment"># 十六进制表示的字节</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，可以给 <code>open()</code> 函数传入 <code>encoding</code> 参数，例如，读取GBK编码的文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">'测试'</span></div></pre></td></tr></table></figure>
<p>遇到有些编码不规范的文件，你可能会遇到 <code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code> 函数还接收一个 <code>errors</code> 参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>, errors=<span class="string">'ignore'</span>)</div></pre></td></tr></table></figure>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在Python中，文件读写是通过 <code>open()</code> 函数打开的文件对象完成的。使用 <code>with</code> 语句操作文件IO是个好习惯。</p>
<hr>
<p><br></p>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候，数据读写不一定是对文件进行的，我们也可以在内存中进行读写操作。</p>
<p><code>StringIO</code> 顾名思义就是<strong>在内存中读写 <code>str</code></strong>。</p>
<p>要把 <code>str</code> 写入 <code>StringIO</code>，我们需要先创建一个 <code>StringIO</code> 对象，然后，像文件一样写入即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</div><div class="line">hello world!</div></pre></td></tr></table></figure>
<p><code>getvalue()</code> 方法用于<strong>获得IO流中的全部内容</strong>。</p>
<p>读取 <code>StringIO</code> 的方法也和读文件类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>) <span class="comment"># 用一个str初始化StringIO</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    s = f.readline()</div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">''</span>: <span class="comment"># 读取完毕，跳出循环</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">break</span></div><div class="line"><span class="meta">... </span>    print(s.strip()) <span class="comment"># 去掉当前行首尾的空格再打印</span></div><div class="line">...</div><div class="line">Hello!</div><div class="line">Hi!</div><div class="line">Goodbye!</div></pre></td></tr></table></figure>
<hr>
<h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p><code>StringIO</code> 操作的只能是 <code>str</code>，如果要操作二进制数据，就需要使用 <code>BytesIO</code>。</p>
<p><code>BytesIO</code> 实现了在内存中读写 <code>bytes</code>，我们创建一个 <code>BytesIO</code>，然后写入一些 <code>bytes</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div></pre></td></tr></table></figure>
<p>请注意，写入的不是 <code>str</code>，而是经过UTF-8编码的 <code>bytes</code>。</p>
<p>和 <code>StringIO</code> 类似，读取 <code>BytesIO</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 用一个bytes初始化BytesIO</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="为什么使用StringIO和BytesIO"><a href="#为什么使用StringIO和BytesIO" class="headerlink" title="为什么使用StringIO和BytesIO"></a>为什么使用StringIO和BytesIO</h3><p>这个问题在Stackoverflow上有<a href="http://stackoverflow.com/questions/4733693/when-is-stringio-used" target="_blank" rel="external">回答</a>，为什么我们不直接使用 <code>str</code> 和 <code>bytes</code>，而要这么别扭地在内存中使用 <code>StringIO</code> 和 <code>BytesIO</code> 呢？其实呀，主要是因为 <strong><code>StringIO</code> 和 <code>BytesIO</code> 都是 <code>file-like Object</code></strong>，可以像文件对象那样使用，当某些库的函数支持文件对象时，我们可以传入 <code>StringIO</code> 和 <code>BytesIO</code>，也能使用，这一点 <code>str</code> 和 <code>bytes</code> 是没法做到的。</p>
<hr>
<h3 id="读写IO需要注意的地方"><a href="#读写IO需要注意的地方" class="headerlink" title="读写IO需要注意的地方"></a>读写IO需要注意的地方</h3><p>以 <code>StringIO</code> 为例，前面我们将到读取 <code>StringIO</code> 时，是<strong>先使用字符串进行初始化，然后再读取</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>) <span class="comment"># 用一个str初始化StringIO</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.readlines()</div><div class="line">[<span class="string">'Hello!\n'</span>, <span class="string">'Hi!\n'</span>, <span class="string">'Goodbye!'</span>]</div></pre></td></tr></table></figure>
<p>但如果我们<strong>没有进行初始化，而是对一个空的 <code>StringIO</code> 进行写入，然后再读取</strong>呢？这时就会像下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello!\n'</span>)</div><div class="line"><span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hi!\n'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Goodbye!'</span>)</div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.readlines()</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>我们发现此时读取不到写入的字符串了，这是为什么呢？其实呀，这时因为<strong>当前所处流的位置（Stream Position）在末尾</strong>，所以读取不到东西了。那怎么知道当前处在流的什么位置呢？我们可以使用 <code>tell()</code> 方法。对比一下：</p>
<p>使用字符串初始化 <code>StringIO</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.tell()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>写入 <code>StringIO</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello!\n'</span>)</div><div class="line"><span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hi!\n'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Goodbye!'</span>)</div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.tell()</div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure>
<p>可以发现，使用字符串初始化时，位置会保持在流的开头，而使用 <code>write()</code> 方法对流进行写入操作后，位置会移动到<strong>写入结束的地方</strong>。那有没有办法在写入以后进行读取呢？有！可以使用前面提到的 <code>getvalue()</code> 方法读取IO流中的全部内容，另外也可以使用 <code>seek()</code> 方法回到前面的某一位置，然后读取该位置后的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.tell()</div><div class="line"><span class="number">19</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">0</span>) <span class="comment"># 回到流的开头位置</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.tell()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>有时候呀，我们可能会在初始化一个 <code>StringIO</code> 之后，想要对其进行写入操作，这时会发生一个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.getvalue()</div><div class="line"><span class="string">'Hello!'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hi!'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.getvalue()</div><div class="line"><span class="string">'Hi!lo!'</span></div></pre></td></tr></table></figure>
<p>可以看到初始化的内容被写入的内容覆盖了，这显然不是我们所希望的。为什么会这样呢？其实呀，跟前面说的问题是一样的，举一反三，都是因为Stream Position引起的。初始化一个 <code>StringIO</code> 后，位置在流的开头，此时写入就会从流的开头写入，而不是像我们所希望的那样从流的末尾写入，稍微改动一下就好了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">0</span>, <span class="number">2</span>) <span class="comment"># 移动到流的末尾</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hi!'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.getvalue()</div><div class="line"><span class="string">'Hello!Hi!'</span></div></pre></td></tr></table></figure>
<p>除了移动到流的末尾，也能移动到某个位置，看看 <code>seek()</code> 方法的描述：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Help on built-<span class="keyword">in</span> function seek:</div><div class="line"></div><div class="line">seek(pos, whence=<span class="number">0</span>, /) method of _io.StringIO instance</div><div class="line">    Change stream position.</div><div class="line"></div><div class="line">    Seek to character offset pos relative to position indicated by whence:</div><div class="line">        <span class="number">0</span>  Start of stream (the default).  pos should be &gt;= <span class="number">0</span>;</div><div class="line">        <span class="number">1</span>  Current position - pos must be <span class="number">0</span>;</div><div class="line">        <span class="number">2</span>  End of stream - pos must be <span class="number">0.</span></div><div class="line">    Returns the new absolute position.</div></pre></td></tr></table></figure>
<p>可以看到 <code>seek()</code> 方法有必选参数 <code>pos</code> 和 可选参数 <code>whence</code>，前者是移动多少，后者是从哪里开始移动。<code>whence</code> 默认为0，也即默认从流的开头移动 <code>pos</code> 个位置。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>StringIO</code> 和 <code>BytesIO</code> 是在内存中操作 <code>str</code> 和 <code>bytes</code> 的方法，和读写文件具有一致的接口。</p>
<hr>
<p><br></p>
<h2 id="操作目录和文件"><a href="#操作目录和文件" class="headerlink" title="操作目录和文件"></a>操作目录和文件</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在命令行下，我们可以通过输入操作系统提供的各种命令，比如dir、cp等，来操作目录和文件。这些命令的本质其实就是简单地调用了<strong>操作系统提供的接口函数</strong>。</p>
<p>那如果想在Python程序中操作目录和文件该怎么办呢？Python内置的 <code>os</code> 模块同样给与我们调用操作系统提供的接口函数的能力。</p>
<p>打开Python交互式命令行，首先看看如何使用 <code>os</code> 模块的基本功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.name</div><div class="line"><span class="string">'posix'</span></div></pre></td></tr></table></figure>
<p>Linux、Unix和Mac OS X系统返回的是 <code>posix</code>，Windows系统返回的则是 <code>nt</code>。</p>
<p>要获取详细的系统信息，可以调用 <code>uname()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.uname()</div><div class="line">posix.uname_result(sysname=<span class="string">'Darwin'</span>, nodename=<span class="string">'MichaelMacPro.local'</span>, release=<span class="string">'14.3.0'</span>, version=<span class="string">'Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64'</span>, machine=<span class="string">'x86_64'</span>)</div></pre></td></tr></table></figure>
<p>注意，<code>uname()</code> 函数在Windows系统上不提供，也就是说，<strong><code>os</code> 模块的能否使用某些函数取决于使用者的操作系统</strong>。</p>
<hr>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在操作系统中定义的环境变量，全部保存在 <code>os.environ</code> 变量中。我们可以直接查看操作系统的所有环境变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ</div><div class="line">environ(&#123;<span class="string">'VERSIONER_PYTHON_PREFER_32_BIT'</span>: <span class="string">'no'</span>, <span class="string">'TERM_PROGRAM_VERSION'</span>: <span class="string">'326'</span>, <span class="string">'LOGNAME'</span>: <span class="string">'michael'</span>, <span class="string">'USER'</span>: <span class="string">'michael'</span>, <span class="string">'PATH'</span>: <span class="string">'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'</span>, ...&#125;)</div></pre></td></tr></table></figure>
<p>要获取某个环境变量的值，可以调用使用 <code>os.environ.get(&#39;key&#39;)</code> 的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">'PATH'</span>)</div><div class="line"><span class="string">'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">'x'</span>, <span class="string">'default'</span>)</div><div class="line"><span class="string">'default'</span></div></pre></td></tr></table></figure>
<p>传入某个环境变量的名称，得到对应的路径。除此之外还可以传入一个字符串作为默认路径（<strong>没有可返回的路径时</strong>会返回默认路径）。</p>
<hr>
<h3 id="操作目录和文件-1"><a href="#操作目录和文件-1" class="headerlink" title="操作目录和文件"></a>操作目录和文件</h3><p>除了前面的 <code>os</code> 模块中，操作目录和文件的函数还有一部分放在 <code>os.path</code> 模块中。比方说用于生成绝对路径的 <code>abspath()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>) <span class="comment"># 点符代表当前工作路径</span></div><div class="line"><span class="string">'F:\\Python35'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'Tools\\demos'</span>)</div><div class="line"><span class="string">'F:\\Python35\\Tools\\demos'</span></div></pre></td></tr></table></figure>
<p>在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/05%E6%A8%A1%E5%9D%97.md" target="_blank" rel="external">05模块</a>中归纳过文件搜索路径的一些知识，当我们在程序中需要用到某个文件时，可以使用两种方式来让程序查找到这个文件：</p>
<ul>
<li>一是使用绝对路径，也即完整的路径；</li>
<li>二是使用相对路径（相对当前工作路径而言的路径），并且可以使用点符 <code>.</code> 来替代当前工作路径。</li>
</ul>
<p>注意，<strong>使用相对路径时是可以不使用点符的</strong>，所以上面代码中，为 <code>Tools\\demos</code> 生成绝对路径也同样可行。</p>
<p>接下来我们试试创建目录和删除目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在某个目录下创建一个新目录，首先生成新目录的完整路径:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/Users/michael'</span>, <span class="string">'testdir'</span>)</div><div class="line"><span class="string">'/Users/michael/testdir'</span></div><div class="line"><span class="comment"># 然后创建一个目录:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">'/Users/michael/testdir'</span>)</div><div class="line"><span class="comment"># 删掉一个目录:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>
<p><strong>把两个路径合成一个时，不要直接拼字符串</strong>，而要通过 <code>os.path.join()</code> 函数，这样可以<strong>正确处理不同操作系统的路径分隔符</strong>。在Linux/Unix/Mac下，<code>os.path.join(&#39;part1&#39;,&#39;part2&#39;)</code> 返回这样的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">part<span class="number">-1</span>/part<span class="number">-2</span></div></pre></td></tr></table></figure>
<p>而Windows下会返回这样的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">part<span class="number">-1</span>\part<span class="number">-2</span></div></pre></td></tr></table></figure>
<p>同样的道理，<strong>要拆分路径时，也不要直接去拆字符串</strong>，而要通过 <code>os.path.split()</code> 函数，这样可以把一个路径拆分为两部分，后一部分总是<strong>最后级别的目录或文件名</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/Users/michael/testdir/file.txt'</span>)</div><div class="line">(<span class="string">'/Users/michael/testdir'</span>, <span class="string">'file.txt'</span>)</div></pre></td></tr></table></figure>
<p><code>os.path.splitext()</code> 函数可以用来<strong>获取文件扩展名</strong>，很多时候非常方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">'/path/to/file.txt'</span>)</div><div class="line">(<span class="string">'/path/to/file'</span>, <span class="string">'.txt'</span>)</div></pre></td></tr></table></figure>
<p>这些合并、拆分路径的函数<strong>并不要求目录和文件真实存在</strong>，它们只是对字符串进行操作。</p>
<p>文件操作使用下面的函数。假定当前目录下有一个 <code>test.txt</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 对文件重命名:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">'test.txt'</span>, <span class="string">'test.py'</span>)</div><div class="line"><span class="comment"># 删掉文件:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">'test.py'</span>)</div></pre></td></tr></table></figure>
<p>但是 <code>os</code> 模块中不存在复制文件的函数！原因是<strong>复制文件并非是由操作系统提供的系统调用</strong>。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是 <code>shutil</code> 模块提供了 <code>copyfile()</code> 的函数，你还可以在 <code>shutil</code> 模块中找到很多实用函数，它们可以看做是对 <code>os</code> 模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isdir(x)]</div><div class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</div></pre></td></tr></table></figure>
<p>要列出所有的 <code>.py</code> 文件，也只需一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]</div><div class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</div></pre></td></tr></table></figure>
<p>是不是非常简洁？</p>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Python的 <code>os</code> 模块封装了操作系统的目录和文件操作，要注意这些函数有的在 <code>os</code> 模块中，有的在 <code>os.path</code> 模块中。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h4><blockquote>
<p>利用 <code>os</code> 模块编写一个能实现 <code>ls -l</code> 输出的程序。</p>
</blockquote>
<p>先看看 <code>ls -l</code> 做的是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu@ubuntu:~/HumanFaceRecognitionWithNN$ ls -l</div><div class="line">total 344</div><div class="line">-rw-rw-r-- 1 ubuntu ubuntu  10301 Dec 14 22:28 face_recognition.py</div><div class="line">drwxrwxr-x 3 ubuntu ubuntu   4096 Dec 21 15:50 test</div><div class="line">-rw-rw-r-- 1 ubuntu ubuntu 328506 Dec 10 15:39 yaleB_face_dataset.mat</div></pre></td></tr></table></figure>
<p>注意这是在Linux上执行的，我们想查看当前路径下有什么文件和文件夹可以使用 <code>ls</code> 或者 <code>dir</code> 命令，而如果我们想了解更详细的信息则可以用 <code>ls -l</code> 或者<code>dir -l</code> 命令。</p>
<p>这里稍微解析一下返回的信息吧，以下面这一条为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">field1</th>
<th style="text-align:center">field2</th>
<th style="text-align:center">field3</th>
<th style="text-align:center">field4</th>
<th style="text-align:center">field5</th>
<th style="text-align:center">field6</th>
<th style="text-align:center">field7</th>
<th style="text-align:center">field8</th>
<th style="text-align:center">field9</th>
<th style="text-align:center">field10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">rw-</td>
<td style="text-align:center">rw-</td>
<td style="text-align:center">r—</td>
<td style="text-align:center">1</td>
<td style="text-align:center">ubuntu</td>
<td style="text-align:center">ubuntu</td>
<td style="text-align:center">10301</td>
<td style="text-align:center">Dec 14 22:28</td>
<td style="text-align:center">face_recognition.py</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>field1 是 <code>File type flag</code>，<strong>标识文件类型</strong>，如果是 <code>-</code> 则表明是普通文件，是 <code>d</code> 则表明是一个目录；</li>
<li>field2、field3、field4 依次是拥有者、拥有者所在的用户组以及其他用户对<strong>该文件/文件夹的操作权限</strong>，<code>r</code> 表示可读，<code>w</code> 表示可写， <code>x</code> 表示可执行。</li>
<li>field5 是<strong>所含链接数</strong>，如果该项是一个文件，则链接数为1；如果该项是一个目录，则一般为<strong>该目录下子文件夹数+2</strong>。为什么呢？因为当前目录（该项的父目录）有一条指向该项的链接，而对文件夹来说，除了父目录的链接之外，它本身还有一条 <code>.</code> 链接指向自身，并且它的子目录都有一条 <code>..</code> 链接指向它；</li>
<li>field6 是<strong>拥有者的名字</strong>；</li>
<li>field7 是<strong>拥有者所在的用户组</strong>；</li>
<li>field8 是<strong>该项的大小</strong>（多少bytes）；</li>
<li>field9 是<strong>最后修改该项的日期和时间</strong>；</li>
<li>field10 是<strong>该项的名字</strong>。</li>
</ul>
<p>我们注意到，除了每一项的详细信息之外，最前面还有一行输出 <code>total 344</code>，这个344是什么呢？它指的是当前目录所有文件和文件夹所使用的块（block）的数目，块是一个操作系统的概念，这里不详细展开。如果我们想知道当前目录下每一项所使用的块的数目，可以使用 <code>ls -s</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-173-69-ubuntu:~/HumanFaceRecognitionWithNN$ ls -s</div><div class="line">total 344</div><div class="line"> 12 face_recognition.py    4 test  328 yaleB_face_dataset.mat</div></pre></td></tr></table></figure>
<p>加起来总数正是 <code>344</code>。</p>
<p>以上内容参考了以下几个链接：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/7401704/what-is-that-total-in-the-very-first-line-after-ls-l" target="_blank" rel="external">What is that “total” in the very first line after ls -l?</a></li>
<li><a href="http://go2linux.garron.me/command-ls-file-permissions/" target="_blank" rel="external">command ls -l output explained</a></li>
<li><a href="http://unix.stackexchange.com/questions/103114/what-do-the-fields-in-ls-al-output-mean" target="_blank" rel="external">What do the fields in ls -al output mean?</a></li>
<li><a href="http://askubuntu.com/questions/710905/what-does-each-part-of-the-ls-la-output-mean" target="_blank" rel="external">What does each part of the <code>ls -la</code> output mean?</a></li>
</ul>
<p>题目要求实现Python版的 <code>ls -l</code>，理论上应该是可行的，但上面的内容只涉及到 <code>os</code> 和 <code>os.path</code> 模块中很少的函数，其他的还有待发掘。我暂时没有时间去琢磨，所以先略过这一题。</p>
<h4 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h4><blockquote>
<p>编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(s, path=os.getcwd<span class="params">()</span>)</span>:</span></div><div class="line">    filelst = [x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(path)]</div><div class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filelst:</div><div class="line">        filepath = os.path.join(path, filename)</div><div class="line">        <span class="comment"># print('Searching: ', path, '\nWith: ', filepath)</span></div><div class="line">        <span class="keyword">if</span> os.path.isfile(filepath):</div><div class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> filename:</div><div class="line">                print(os.path.relpath(filepath))</div><div class="line">        <span class="keyword">elif</span> os.path.isdir(filepath):</div><div class="line">            search(s, filepath)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = input(<span class="string">'Enter the string: '</span>)</div><div class="line">    search(s)</div></pre></td></tr></table></figure>
<p>这题还是挺有意思的，用户自己定义搜索的字符串，我们不仅要找出当前目录下包含该字符串的文件，还要搜索所有的子目录。我们可以把搜索一个目录的过程封装为 <code>search</code> 函数，并采用递归的方式来实现其子目录的搜索。思路如下：</p>
<ol>
<li><p>获取当前目录的所有文件&amp;目录名，使用 <code>os.listdir()</code> 函数可以实现，把这些名称放在一个列表里保存；</p>
</li>
<li><p>接下来逐个遍历并判断列表中的元素是文件还是目录，可以使用 <code>os.path.isfile()</code> 和 <code>os.path.isdir()</code> 函数；</p>
<ul>
<li>如果当前遍历到的元素是文件，则使用 <code>os.path.relpath()</code> 函数输出文件的相对路径；</li>
<li>如果当前遍历到的元素是目录，则将该目录的路径传入 <code>search</code> 函数。</li>
</ul>
</li>
</ol>
<p>特别地，我们要注意这些函数应该输入什么和会输出什么。<code>os.path.relpath()</code> 函数接收一条完整的绝对路径，并输出<strong>相对于当前工作路径（在命令行中执行该Python文件时所处的路径）的相对路径</strong>，所以我们要先构造出正确的绝对路径，才能获取正确的相对路径。</p>
<p><code>os.path.isdir()</code> 可以接收相对路径也可以接收绝对路径，因为我们使用 <code>os.listdir()</code> 只能获得文件或目录的名称，在搜索子目录时，这些名称并不是相对于当前工作路径的相对路径，所以不能直接传入 <code>os.listdir()</code> 中，必须先构造绝对路径，然后再判断。</p>
<p>为什么不使用 <code>os.path.abspath()</code> 函数来生成绝对路径呢？因为<strong>传入 <code>os.path.abspath()</code> 函数的必须是一条正确的相对路径，才会得到正确的相对路径</strong>。举个例子，当前工作路径是 <code>C:\Users\Administrator\Desktop</code>，其子目录 <code>test1</code> 中有一个文件 <code>test2.py</code>，如果我们使用 <code>os.path.abspath(&#39;test2.py&#39;)</code>，那么得到的绝对路径就变成了 <code>C:\Users\Administrator\Desktop\test2.py</code>，显然是不对的。</p>
<hr>
<p><br></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>在程序运行的过程中，所有的变量都保存在内存中，而一旦程序结束，变量所占用的内存就会被操作系统全部回收。但是，有时候，我们希望通过程序修改了某个变量的值之后，能够让另一个程序能调用这个变量。比方说在程序1中定义了一个 <code>list</code>，并且经过某些高开销的操作修改了这个 <code>list</code> 的值。如果我们想在程序2中使用程序1中修改后的 <code>list</code>，按之前的做法就只能把程序1作为一个模块，在程序2中执行程序1的代码，这样一来，就必须重复执行高开销的操作了。有没有解决这个问题的方法呢？有的，答案就是<strong>序列化</strong>。</p>
<p>我们把<strong>将变量从内存中保存的格式变成可存储或可传输的格式这个过程称之为序列化</strong>，在Python中叫 <code>pickling</code>，在其他语言中也被称之为 <code>serialization</code>，<code>marshalling</code>，<code>flattening</code> 等等，都是一个意思。经过序列化之后，内存中的变量就由原来的格式（某种数据结构/类型）转换为特定的格式，从而可以被存储或传输，这样另一个程序需要用到时就可以直接读取，而不必重复计算了。</p>
<p>反过来，把<strong>将变量内容从序列化的对象重新读到内存里还原为原来的格式这一过程称之为反序列化</strong>，即 <code>unpickling</code>。</p>
<hr>
<h3 id="序列化（pickle）"><a href="#序列化（pickle）" class="headerlink" title="序列化（pickle）"></a>序列化（pickle）</h3><p>在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/01Python%E5%9F%BA%E7%A1%80.md" target="_blank" rel="external">01Python基础</a>中，我们就知道<strong>传输和存储都是以字节（bytes）为单位的</strong>，所以这节首先介绍一种将变量序列化为 <code>bytes</code> 对象的方法，Python提供了 <code>pickle</code> 模块来实现这一功能。</p>
<p>以 <code>dict</code> 为例，将一个 <code>dict</code> 类型的对象序列化并写入文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(d)</div><div class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'</span></div></pre></td></tr></table></figure>
<p><code>pickle.dumps()</code> 函数可以把任意变量序列化为一个 <code>bytes</code> 对象。我们可以把这个 <code>bytes</code> 对象写入文件。此外，我们也可以用 <code>pickle.dump()</code> 函数直接把对象序列化后<strong>写入一个 <code>file-like Object</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure>
<p>打开 <code>dump.txt</code> 文件，我们会看到一堆乱七八糟无法阅读的内容，这些都是Python保存的对象信息。</p>
<p>当我们需要还原变量，也即把对象从磁盘读到内存时，可以先把内容读入到一个 <code>bytes</code> 对象中，然后用 <code>pickle.loads()</code> 方法反序列化出对象，也可以直接用 <code>pickle.load()</code> 方法从一个 <code>file-like Object</code> 中直接反序列化出对象。打开另一个Python命令行，试试反序列化刚才保存的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'rb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们成功地还原了这个 <code>dict</code> 类型的对象。</p>
<p>有了 <code>Pickle</code> 之后，我们可以方便地在Python中进行序列化和反序列化。但是，和所有其他编程语言的序列化问题一样，<code>Pickle</code> 是一种Python特有的序列化解决方案，它只能用于Python，甚至不同版本的Python彼此都可能不兼容。如果我们使用Python写程序，而别人使用其他语言，比如Java，C++等，它们没有 <code>Pickle</code> 模块也就没办法进行反序列化了。</p>
<hr>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>如果我们要<strong>在不同的编程语言之间传递对象</strong>，就必须把对象序列化为通用的<strong>标准格式</strong>，比如序列化<strong>XML（Extensible Markup Language，可扩展标记语言）</strong>。但更好的方法是序列化为<strong>JSON（JavaScript Object Notation，JavaScript对象表示法）</strong>。因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，还可以直接在Web页面中读取，非常方便。</p>
<p>比较一下Python内置的数据类型和JSON中的表示方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Python类型</th>
<th style="text-align:center">JSON表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">dict</td>
<td style="text-align:center">{}</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">[]</td>
</tr>
<tr>
<td style="text-align:center">str</td>
<td style="text-align:center">“string”</td>
</tr>
<tr>
<td style="text-align:center">int, float</td>
<td style="text-align:center">10, 1234.56</td>
</tr>
<tr>
<td style="text-align:center">True/False</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">None</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
</div>
<p>Python内置的 <code>json</code> 模块提供了非常完善的Python对象到JSON格式的转换方法。同样对一个 <code>dict</code> 进行序列化，方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</div><div class="line"><span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></div></pre></td></tr></table></figure>
<p><code>dumps()</code> 方法<strong>返回一个 <code>str</code></strong>，内容就是标准的JSON。类似的，<code>dump()</code> 方法可以直接把JSON写入一个 <code>file-like Object</code>。</p>
<p>要把JSON反序列化为Python对象，用 <code>loads()</code> 或者对应的 <code>load()</code>方法，前者把JSON的字符串反序列化，后者从 <code>file-like Object</code> 中读取字符串并反序列化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</div></pre></td></tr></table></figure>
<p>由于JSON标准规定<strong>JSON编码是UTF-8</strong>，所以我们总是能正确地在Python的 <code>str</code> 与JSON之间的转换。</p>
<hr>
<h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的 <code>dict</code> 对象可以直接序列化为JSON的 <code>{}</code>，不过很多时候，Python自带的数据结构并不足以实现我们的需求，此时我们会<strong>使用自定义的类来表示对象</strong>。比如定义一个Student类，并尝试序列化该类的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, score)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">        self.score = score</div><div class="line"></div><div class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">20</span>, <span class="number">88</span>)</div><div class="line">print(json.dumps(s))</div></pre></td></tr></table></figure>
<p>运行代码，毫不留情地得到一个 <code>TypeError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">TypeError: &lt;__main__.Student object at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</div></pre></td></tr></table></figure>
<p>错误的原因是Student对象<strong>不是一个可序列化为JSON的对象</strong>。</p>
<p>这样看来还是不够实用呀，别急，我们再仔细看看 <code>dumps()</code> 方法的参数列表，可以发现，除了第一个必须的 <code>obj</code> 参数外，<code>dumps()</code> 方法还提供了一大堆的可选参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>help(json.dumps)</div><div class="line">Help on function dumps <span class="keyword">in</span> module json:</div><div class="line"></div><div class="line">dumps(obj, skipkeys=<span class="keyword">False</span>, ensure_ascii=<span class="keyword">True</span>, check_circular=<span class="keyword">True</span>, allow_nan=<span class="keyword">True</span>, cls=<span class="keyword">None</span>,</div><div class="line"> indent=<span class="keyword">None</span>, separators=<span class="keyword">None</span>, default=<span class="keyword">None</span>, sort_keys=<span class="keyword">False</span>, **kw)</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这些可选参数就是允许我们对JSON序列化进行定制的。前面的代码之所以无法把Student类实例序列化为JSON，是因为默认情况下，<code>dumps()</code> 方法不知道如何将Student实例变为一个JSON的 <code>{}</code> 对象。</p>
<p>可选参数 <code>default</code> 允许我们传入一个可以把传入对象变得可序列化的函数，我们只需要为Student专门写一个转换函数，再把函数传进去即可，例如定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span><span class="params">(std)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'name'</span>: std.name,</div><div class="line">        <span class="string">'age'</span>: std.age,</div><div class="line">        <span class="string">'score'</span>: std.score</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样，Student实例首先被 <code>student2dict()</code> 函数转换成 <code>dict</code>，然后再被序列化为JSON：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(s, default=student2dict))</div><div class="line">&#123;<span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"score"</span>: <span class="number">88</span>&#125;</div></pre></td></tr></table></figure>
<p>不过，下次如果遇到一个Teacher类的实例，我们还是无法把Teacher类的实例序列化为JSON。有没有更方便的做法呢？有的，我们可以偷个懒，利用 <code>__dict__</code> 属性即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</div></pre></td></tr></table></figure>
<p>通常类的实例都有一个 <code>__dict__</code> 属性，它就是一个 <code>dict</code>。但也有少数例外，比如定义了 <code>__slots__</code> 的类（这样的类没有 <code>__dict__</code> 属性）。</p>
<p>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，<code>loads()</code>方法会首先转换出一个 <code>dict</code> 对象，然后，参数 <code>object_hook</code> 则允许我们传入一个函数，负责把 <code>dict</code> 转换为Student实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2student</span><span class="params">(d)</span>:</span></div><div class="line">    <span class="keyword">return</span> Student(d[<span class="string">'name'</span>], d[<span class="string">'age'</span>], d[<span class="string">'score'</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(json_str, object_hook=dict2student))</div><div class="line">&lt;__main__.Student object at <span class="number">0x10cd3c190</span>&gt;</div></pre></td></tr></table></figure>
<p>打印出的是反序列化后的Student实例对象。</p>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Python语言特定的序列化模块是 <code>pickle</code>，但如果想把序列化做得更通用、更符合Web标准，可以使用 <code>json</code> 模块。</p>
<p><code>json</code> 模块的 <code>dumps()</code> 和 <code>loads()</code> 函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-08错误、调试与测试]]></title>
      <url>http://2wildkids.com/2016/12/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#简述">简述</a></li>
<li><a href="#错误处理">错误处理</a><ul>
<li><a href="#错误码">错误码</a></li>
<li><a href="#tryexceptfinally">try…except…finally</a></li>
<li><a href="#错误的调用链">错误的调用链</a></li>
<li><a href="#记录错误">记录错误</a></li>
<li><a href="#抛出错误">抛出错误</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#调试">调试</a><ul>
<li><a href="#直接打印">直接打印</a></li>
<li><a href="#断言">断言</a></li>
<li><a href="#logging">logging</a></li>
<li><a href="#pdb">pdb</a></li>
<li><a href="#pdbsettrace">pdb.set_trace</a></li>
<li><a href="#ide">IDE</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#单元测试">单元测试</a><ul>
<li><a href="#什么是单元测试">什么是单元测试</a></li>
<li><a href="#编写一个单元测试">编写一个单元测试</a></li>
<li><a href="#补充说明">补充说明</a></li>
<li><a href="#运行单元测试">运行单元测试</a></li>
<li><a href="#setup与teardown">setUp与tearDown</a></li>
<li><a href="#小结-2">小结</a></li>
</ul>
</li>
<li><a href="#文档测试">文档测试</a><ul>
<li><a href="#使用文档测试">使用文档测试</a></li>
<li><a href="#练习">练习</a></li>
<li><a href="#小结-3">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在程序运行过程中我们总会遇到各种各样的<strong>错误</strong>。有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为<strong>bug</strong>，bug是必须修复的；有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理；还有一类错误是完全无法预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为<strong>异常</strong>，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。Python内置了一套异常处理机制，可以帮助我们处理这些错误。</p>
<p>此外，在编写代码时，我们可能会需要跟踪程序的执行，查看变量的值是否正确，然后再进行调整或者下一步操作，这个过程称为<strong>调试</strong>。Python的<strong>pdb</strong>可以让我们以<strong>单步方式</strong>执行代码，从而方便地调试程序。</p>
<p>最后，编写<strong>测试</strong>也很重要。编写好测试文件，这样当我们改动了代码或者实现了新的功能时，只需再运行一遍测试，就能知道原来的功能有没有出错，程序是否依然能输出我们期望的结果了。</p>
<hr>
<p><br></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>在程序运行的过程中，如果发生了错误，可以<strong>返回一个事先约定的错误代码</strong>，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数 <code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回-1。</p>
<p>用错误码来表示是否出错十分不便，因为<strong>函数本身既可能返回正常结果又可能返回错误码</strong>，所以调用者不得不用大量的代码来判断属于哪一种情况。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    r = some_function()</div><div class="line">    <span class="keyword">if</span> r==(<span class="number">-1</span>):</div><div class="line">        <span class="keyword">return</span> (<span class="number">-1</span>)</div><div class="line">    <span class="comment"># do something</span></div><div class="line">    <span class="keyword">return</span> r</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">    r = foo()</div><div class="line">    <span class="keyword">if</span> r==(<span class="number">-1</span>):</div><div class="line">        print(<span class="string">'Error'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>函数 <code>foo</code> 既可能返回正常结果又可能返回错误码，因此调用 <code>foo</code> 的函数 <code>bar</code> 就不得不先进行判断，检查返回的是正常结果还是错误码。这种情况在有多种错误码时显得更为麻烦。</p>
<p>还有一个很大的缺点是，使用错误码时，一旦出错，就必须把这个错误码一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。假如上面例子中 <code>bar</code> 函数无法处理错误，就必须继续返回错误码给调用 <code>bar</code> 的上级函数，以此类推。并且在返回的过程中，我们在每个中间函数中都要对错误码进行判断，这样写出来的程序有“半壁江山”都被处理错误的逻辑占据了，着实可怕。。。</p>
<p>有没有可以替代错误码又能处理错误的方案呢？有的！基本上，所有高级语言都内置了一套 <code>try...except...finally...</code> 的错误处理机制，Python也不例外，在下一小节中将介绍这种错误处理机制。</p>
<hr>
<h3 id="try…except…finally"><a href="#try…except…finally" class="headerlink" title="try…except…finally"></a>try…except…finally</h3><p><code>try...except...finally...</code> 机制的工作方式是这样的：</p>
<ul>
<li>当我们认为某段代码可能会出错时，可以用 <code>try</code> 来运行这段代码，如果运行出错，则这段代码会<strong>终止在错误出现的地方</strong>；</li>
<li>如果后续代码中 <code>except</code> 语句成功捕获到错误，程序就会执行 <code>except</code> 语句块内的代码处理错误。如果没有捕获到，则错误没有得到处理，程序就会停止运行；</li>
<li>最后，<strong>无论是否出错，无论是否成功捕获到错误</strong>，<code>finally</code> 语句块内的代码都会被执行。</li>
</ul>
<p><code>try...except...finally...</code> 机制中，我们<strong>可以不使用 <code>finally</code> 语句块，但 <code>try</code> 和 <code>except</code> 是一定要同时出现的</strong>，<code>except</code> 不一定能成功捕获 <code>try</code> 语句块内的错误，如果捕获不成功，程序就会终止运行。</p>
<p>接下来看一个使用 <code>try...except...finally...</code> 机制处理错误的具体案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    print(<span class="string">'try...'</span>)</div><div class="line">    r = <span class="number">10</span> / <span class="number">0</span></div><div class="line">    print(<span class="string">'result:'</span>, r)</div><div class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'except:'</span>, e)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    print(<span class="string">'finally...'</span>)</div><div class="line">print(<span class="string">'END'</span>)</div></pre></td></tr></table></figure>
<p>上面的代码在计算 <code>10 / 0</code> 时会产生一个除零错误，得到输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...</div><div class="line"><span class="keyword">except</span>: division by zero</div><div class="line"><span class="keyword">finally</span>...</div><div class="line">END</div></pre></td></tr></table></figure>
<p>从输出可以看到，当错误发生时，后续语句 <code>print(&#39;result:&#39;, r)</code> 不会被执行，由于 <code>except</code> 语句捕获到这个 <code>ZeroDivisionError</code> 错误，因此 <code>except</code> 语句块里的代码会被执行。最后，<code>finally</code> 语句块里的代码也会被执行。<strong>又因为错误得到了处理，所以之后程序会继续运行后续代码，输出 <code>END</code></strong>。</p>
<p>如果把除数0改成2，则执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...</div><div class="line">result: <span class="number">5</span></div><div class="line"><span class="keyword">finally</span>...</div><div class="line">END</div></pre></td></tr></table></figure>
<p>由于<strong>没有错误发生</strong>，所以 <strong><code>except</code> 语句块不会被执行</strong>，但是 <code>finally</code> 语句块只要存在，就一定会被执行。</p>
<p>除了上面出现的 <code>ZeroDivisionError</code> 错误，在实际运行中，还有可能出现各种不同类型的错误。<strong>不同类型的错误应该由不同的 <code>except</code> 语句块进行处理</strong>。我们可以使用多个 <code>except</code> 语句来捕获不同类型的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    print(<span class="string">'try...'</span>)</div><div class="line">    r = <span class="number">10</span> / int(<span class="string">'a'</span>)</div><div class="line">    print(<span class="string">'result:'</span>, r)</div><div class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'ValueError:'</span>, e)</div><div class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'ZeroDivisionError:'</span>, e)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    print(<span class="string">'finally...'</span>)</div><div class="line">print(<span class="string">'END'</span>)</div></pre></td></tr></table></figure>
<p>因为当 <code>int()</code> 函数无法把参数转换为 <code>int</code> 类型时会抛出 <code>ValueError</code> 错误，我们用一个 <code>except</code> 来捕获和处理 <code>ValueError</code>，用另一个 <code>except</code> 来捕获并处理做除法可能产生的 <code>ZeroDivisionError</code>。</p>
<p>特别地，我们还<strong>可以在 <code>except</code> 语句块后面加一个 <code>else</code> 语句块</strong>。当错误没有发生时，就会执行 <code>else</code> 语句内的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    print(<span class="string">'try...'</span>)</div><div class="line">    r = <span class="number">10</span> / int(<span class="string">'2'</span>)</div><div class="line">    print(<span class="string">'result:'</span>, r)</div><div class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'ValueError:'</span>, e)</div><div class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'ZeroDivisionError:'</span>, e)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'no error!'</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    print(<span class="string">'finally...'</span>)</div><div class="line">print(<span class="string">'END'</span>)</div></pre></td></tr></table></figure>
<p>我们常说，在Python中一切皆对象。其实呀，Python中的错误也是采用面向对象实现的，<strong>每一种错误都是一个类，<code>BaseException</code> 类是所有错误类型最顶级的父类</strong>。在使用 <code>except</code> 时需要注意，它<strong>不但会捕获所指定类型的错误，还把属于该类型子类的错误一并捕获</strong>。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    foo()</div><div class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'ValueError'</span>)</div><div class="line"><span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:</div><div class="line">    print(<span class="string">'UnicodeError'</span>)</div></pre></td></tr></table></figure>
<p>这里的第二个 <code>except</code> 永远也不会捕获到 <code>UnicodeError</code>，因为 <code>UnicodeError</code> 是 <code>ValueError</code> 的子类，如果出现了 <code>UnicodeError</code> 就一定会被第一个 <code>except</code> 语句捕获。</p>
<p>常见的错误类型和继承关系看这里：</p>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="external">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p>
<p>在上一小节中，我们说到了使用错误码处理错误有两大缺点，一是<strong>函数既可能返回正常结果也可能返回错误码</strong>，二是<strong>一旦发生错误必须层层上报</strong>。那么使用 <code>try...except...finally...</code> 机制是否能克服这两个缺点呢？答案是肯定的！举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        bar(<span class="string">'0'</span>)</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        print(<span class="string">'Error:'</span>, e)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        print(<span class="string">'finally...'</span>)</div></pre></td></tr></table></figure>
<p>这里我们在 <code>main</code> 函数中调用 <code>bar</code> 函数，在 <code>bar</code> 函数中调用 <code>foo</code> 函数。我们使用 <code>try</code> 模块来运行调用代码，当 <code>foo</code> 函数发生错误时，我们不需要返回错误码，也不需要一级级上报，程序会自动寻找对应的 <code>except</code> 语句进行错误处理。也即是说，<strong>不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了</strong>。这样一来，我们就能使用非常简洁的方式来处理程序运行中可能出现的错误了。</p>
<hr>
<h3 id="错误的调用链"><a href="#错误的调用链" class="headerlink" title="错误的调用链"></a>错误的调用链</h3><p>如果错误没有被捕获，就会一直往上抛，最后<strong>被Python解释器捕获</strong>，打印出错误信息，然后程序终止运行。</p>
<p>编写一个包含如下代码的 <code>err.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># err.py:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    bar(<span class="string">'0'</span>)</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure>
<p>执行该文件，结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ python3 err.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"err.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    main()</div><div class="line">  File <span class="string">"err.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> main</div><div class="line">    bar(<span class="string">'0'</span>)</div><div class="line">  File <span class="string">"err.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar</div><div class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></div><div class="line">  File <span class="string">"err.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</div><div class="line">ZeroDivisionError: division by zero</div></pre></td></tr></table></figure>
<p>出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们<strong>从上往下可以看到整个错误的函数调用链</strong>：</p>
<p>错误信息的第1行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div></pre></td></tr></table></figure>
<p>这句话告诉我们下面是错误的跟踪信息。</p>
<p>错误信息的第2~3行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File <span class="string">"err.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  main()</div></pre></td></tr></table></figure>
<p>告诉我们调用 <code>main()</code> 出错了，具体是在代码文件 <code>err.py</code> 的第11行代码。</p>
<p>错误信息的第4~5行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File <span class="string">"err.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> main</div><div class="line">  bar(<span class="string">'0'</span>)</div></pre></td></tr></table></figure>
<p>告诉我们调用 <code>bar(&#39;0&#39;)</code> 出错了，具体是在代码文件 <code>err.py</code> 的第9行代码。</p>
<p>错误信息的第6~7行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File <span class="string">"err.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar</div><div class="line">  <span class="keyword">return</span> foo(s) * <span class="number">2</span></div></pre></td></tr></table></figure>
<p>告诉我们调用 <code>foo(s)</code> 出错了，具体是在代码文件 <code>err.py</code> 的第6行代码。</p>
<p>错误信息的第8~9行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File <span class="string">"err.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</div><div class="line">  <span class="keyword">return</span> <span class="number">10</span> / int(s)</div></pre></td></tr></table></figure>
<p>告诉我们语句 <code>return 10 / int(s)</code> 出错了，具体是在代码文件 <code>err.py</code> 的第3行代码。这是错误的源头，因为下面打印了具体的错误原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</div></pre></td></tr></table></figure>
<p>根据错误类型 <code>ZeroDivisionError</code>，我们可以判断 <code>int(s)</code> 本身并没有出错，但是 <code>int(s)</code>返回了0，在计算 <code>10 / 0</code> 时程序出错了。这和我们使用 <code>except</code> 来捕获错误信息时打印出的内容是一样的。</p>
<hr>
<h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>上一小节讲到，如果不在代码中进行错误处理，Python解释器最终会捕获错误并打印出错误调用链，但同时程序也会终止运行。那么，有没有<strong>既能打印出错误调用链，帮助我们分析出错的原因和源头，同时又能让程序继续运行</strong>的方法呢？有的，Python内置的 <code>logging</code> 模块可以帮助我们非常容易地记录错误信息。</p>
<p>这里举一个简单的例子，首先编写 <code>err_logging.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        bar(<span class="string">'0'</span>)</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        logging.exception(e) <span class="comment"># 使用logging模块的exception方法打印错误信息</span></div><div class="line"></div><div class="line">main()</div><div class="line">print(<span class="string">'END'</span>)</div></pre></td></tr></table></figure>
<p>同样是打印出错误调用链，但程序打印完错误信息后会继续运行，并正常结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ python3 err_logging.py</div><div class="line">ERROR:root:division by zero</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"err_logging.py"</span>, line <span class="number">13</span>, <span class="keyword">in</span> main</div><div class="line">    bar(<span class="string">'0'</span>)</div><div class="line">  File <span class="string">"err_logging.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> bar</div><div class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></div><div class="line">  File <span class="string">"err_logging.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> foo</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / int(s)</div><div class="line">ZeroDivisionError: division by zero</div><div class="line">END</div></pre></td></tr></table></figure>
<p>此外，我们还可以借助 <code>logging</code> 模块把错误信息记录到日志文件里，方便事后排查，这里不作举例了。</p>
<hr>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>前面我们说到，在Python中错误都是通过类来实现的，捕获一个错误就是捕获到该类的一个实例。<strong>错误并不是凭空产生的，而是有意地创建并抛出的</strong>。Python的内置函数会抛出很多不同类型的错误，我们自己编写函数时也可以这样做。</p>
<p>举一个简单的例子，首先编写 <code>err_raise.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooError</span><span class="params">(ValueError)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    n = int(s)</div><div class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">        <span class="keyword">raise</span> FooError(<span class="string">'invalid value: %s'</span> % s)</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</div><div class="line"></div><div class="line">foo(<span class="string">'0'</span>)</div></pre></td></tr></table></figure>
<p>这里我们自定义了一个错误类型 <code>FooError</code>，继承自 <code>ValueError</code>。<strong>使用 <code>raise</code> 语句抛出一个错误的实例</strong>。执行 <code>err_raise.py</code>，最终可以跟踪到我们自定义的错误类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python3 err_raise.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"err_throw.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    foo(<span class="string">'0'</span>)</div><div class="line">  File <span class="string">"err_throw.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> foo</div><div class="line">    <span class="keyword">raise</span> FooError(<span class="string">'invalid value: %s'</span> % s)</div><div class="line">__main__.FooError: invalid value: <span class="number">0</span></div></pre></td></tr></table></figure>
<p><strong>只有在必要的时候才自定义错误类型</strong>。如果可以使用Python内置的错误类型（比如ValueError，TypeError等等），就应尽量使用Python内置的错误类型。</p>
<p>最后，我们来看另一种错误处理的方式，首先编写 <code>err_reraise.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    n = int(s)</div><div class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'invalid value: %s'</span> % s)</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        foo(<span class="string">'0'</span>)</div><div class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">        print(<span class="string">'ValueError!'</span>)</div><div class="line">        <span class="keyword">raise</span></div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure>
<p>在 <code>bar()</code> 函数中，我们明明已经捕获了错误，但是，打印一个 <code>ValueError</code> 之后，又把错误通过 <code>raise</code> 语句再次抛出去了，为什么呢？</p>
<p>其实这种错误处理方式并没有错，而且相当常见。有时候，捕获错误的目的只是记录一下，便于后续追踪。如果当前函数没有处理该错误的逻辑，最恰当的方式就是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终抛给CEO去处理。</p>
<p>特别地，当 <code>raise</code> 语句不带参数时，会把当前错误原样抛出。但既然我们可以在 <code>except</code> 语句块中使用 <code>raise</code> 语句，那就可以轻易地抛出一个别的错误，从而<strong>把一种错误类型转换成另一种错误类型</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="number">10</span> / <span class="number">0</span></div><div class="line"><span class="keyword">except</span> ZeroDivisionError:</div><div class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'input error!'</span>)</div></pre></td></tr></table></figure>
<p>当然，我们不能滥用这样的功能，只有在有必要进行转换时才进行合理的转换。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用Python内置的 <code>try...except...finally</code> 机制可以十分方便地处理错误。但出错时，会分析错误信息并定位错误发生的位置才是最关键的。</p>
<p>我们编写模块时可以在代码中主动抛出错误，让调用者来处理相应的错误。但是，我们应当在模块的文档中写清楚可能会抛出哪些错误，以及错误产生的原因。</p>
<hr>
<p><br></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>程序运行总会有各种各样的bug，有的bug很简单，看看错误信息就知道；但有的bug很复杂，我们不但需要知道错误类型和出错的地方，还需要知道一些变量的值才能做出准确的推断。<strong>跟踪程序的执行，查看变量的值</strong>这个过程就称为调试，这一节会介绍各种调试程序的手段。</p>
<h3 id="直接打印"><a href="#直接打印" class="headerlink" title="直接打印"></a>直接打印</h3><p>直接打印是一种直接粗暴但十分有效的方法，简单来说就是使用 <code>print()</code> 把可能有问题的变量打印出来看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    n = int(s)</div><div class="line">    print(<span class="string">'n = %d'</span> % n)</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    foo(<span class="string">'0'</span>)</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure>
<p>执行后在输出中查找打印的变量值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python3 err.py</div><div class="line">n = <span class="number">0</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</div></pre></td></tr></table></figure>
<p>这样我们就知道除零错误是因为变量 <code>n</code> 的值不合理而产生的了。</p>
<p>但是使用直接打印来调试有一个很大的缺点，在完成调试后，我们还得删掉代码里用于输出变量值的 <code>pinrt()</code>，如果我们要观察很多变量的值，那么代码里就会到处都是 <code>print()</code>，运行结果也会包含很多垃圾信息，删除的时候就会很麻烦。</p>
<hr>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>我们可以用<strong>断言（assert）</strong>来替代 <code>print()</code>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></div><div class="line">    n = int(s)</div><div class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">'n is zero!'</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    foo(<span class="string">'0'</span>)</div></pre></td></tr></table></figure>
<p>我们看到，使用 <code>assert</code> 的方法是在它后面接一个表达式以及一个字符串，如果表达式不为 <code>True</code>，则断言失败，此时会抛出 <code>AssertionError</code> 错误，并输出自定义的错误信息（跟在表达式后面的字符串）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python3 err.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">AssertionError: n <span class="keyword">is</span> zero!</div></pre></td></tr></table></figure>
<p>程序中如果到处充斥着 <code>assert</code> 语句，似乎和使用 <code>print()</code> 相比也没有什么不同。但是，我们可以<strong>在启动Python解释器时可以用 <code>-O</code> 参数来关闭 <code>assert</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python3 -O err.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ZeroDivisionError: division by zero</div></pre></td></tr></table></figure>
<p>关闭后，可以把所有的 <code>assert</code> 语句当成 <code>pass</code> 来看，此时断言就不会发挥作用了。</p>
<hr>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>我们还可以把 <code>print()</code> 替换为 <code>logging</code>。和 <code>assert</code> 相比，使用 <code>logging</code> 不会抛出错误，而且不但能打印信息还能方便地保存到日志中。这里简单举个例子，首先编写 <code>err.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line">s = <span class="string">'0'</span></div><div class="line">n = int(s)</div><div class="line">logging.info(<span class="string">'n = %d'</span> % n)</div><div class="line">print(<span class="number">10</span> / n)</div></pre></td></tr></table></figure>
<p><code>logging.info()</code> 可以输出一段文本。但运行上述代码，发现除了抛出 <code>ZeroDivisionError</code> 错误之外，没有任何信息。怎么回事呢？</p>
<p>别急，在 <code>import logging</code> 之后添加一行配置再试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line">logging.basicConfig(level=logging.INFO)</div></pre></td></tr></table></figure>
<p>再次运行，此时能看到输出了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ python3 err.py</div><div class="line">INFO:root:n = <span class="number">0</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"err.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(<span class="number">10</span> / n)</div><div class="line">ZeroDivisionError: division by zero</div></pre></td></tr></table></figure>
<p>这就是使用 <code>logging</code> 的好处了，它允许开发者<strong>指定记录信息的级别</strong>，按程度由低到高有 <code>debug</code>, <code>info</code>, <code>waring</code>, <code>error</code> 几个级别。当我们指定 <code>level=INFO</code> 时，<code>logging.debug</code> 就不起作用了。同理，指定 <code>level=WARNING</code> 后，<code>debug</code> 和 <code>info</code> 就不起作用了。这样一来，我们可以很方便地统一控制输出哪个级别的信息，而不用担心调试完还要删除的问题了。</p>
<p>使用 <code>logging</code> 还有另一个好处就是可以通过很简单的配置，把一条语句同时输出到不同的地方，比如命令行和文件。</p>
<hr>
<h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>前面几种方式都需要插入额外的代码，有没有不需要插入代码的调试方式呢？有的！我们可以启动<strong>Python自带的pdb调试器</strong>，让程序<strong>以单步方式运行</strong>，可以随时查看运行到某一步时各个变量的值。首先编写好 <code>err.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># err.py</span></div><div class="line">s = <span class="string">'0'</span></div><div class="line">n = int(s)</div><div class="line">print(<span class="number">10</span> / n)</div></pre></td></tr></table></figure>
<p>以参数 <code>-m pdb</code> 来启动pdb调试环境：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python -m pdb err.py</div><div class="line">&gt; c:\users\administrator\desktop\err.py(2)&lt;module&gt;()</div><div class="line">-&gt; s = '0'</div></pre></td></tr></table></figure>
<p>此时输出有两行，第一行表示下一步执行的代码属于哪一个代码文件的哪一行（这里是 <code>err.py</code> 的第2行）；第二行则是下一步执行的代码。我们可以输入命令 <code>l</code> 来查看这行代码的上下文：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(Pdb) l</div><div class="line">  1     # err.py</div><div class="line">  2  -&gt; s = '0'</div><div class="line">  3     n = int(s)</div><div class="line">  4     print(10 / n)</div><div class="line">[EOF]</div></pre></td></tr></table></figure>
<p>输入命令 <code>n</code> 可以单步执行该行代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(Pdb) n</div><div class="line">&gt; c:\users\administrator\desktop\err.py(3)&lt;module&gt;()</div><div class="line">-&gt; n = int(s)</div><div class="line">(Pdb) n</div><div class="line">&gt; c:\users\administrator\desktop\err.py(4)&lt;module&gt;()</div><div class="line">-&gt; print(10 / n)</div></pre></td></tr></table></figure>
<p>执行后pdb会自动指向下一行代码。特别地，任何时候我们都可以通过输入命令 <code>p 变量名</code> 来查看一个变量的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(Pdb) p s</div><div class="line"><span class="string">'0'</span></div><div class="line">(Pdb) p n</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>继续执行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(Pdb) n</div><div class="line">ZeroDivisionError: division by zero</div><div class="line">&gt; c:\users\administrator\desktop\err.py(4)&lt;module&gt;()</div><div class="line">-&gt; print(10 / n)</div></pre></td></tr></table></figure>
<p>此时执行到了出错代码，pdb会报错并停止在这一行，我们可以看到它指向的地方没有发生变化。</p>
<p>输入命令 <code>q</code> 可以结束调试，退出pdb：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(Pdb) q</div><div class="line"></div><div class="line">C:\Users\Administrator\Desktop&gt;</div></pre></td></tr></table></figure>
<p>这种通过pdb在命令行调试的方法在理论上是万能的，但实在是太麻烦了，打个比方，如果代码文件中有1000行代码，要运行到第999行就得敲999次命令 <code>n</code>，这样还不如执行在代码文件插入代码呢。</p>
<hr>
<h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace"></a>pdb.set_trace</h3><p>有没有可以直接调到我们需要检查的地方再进行单步调试的调试方式呢？有的！同样是基于pdb，这次我们在代码文件中 <code>import pdb</code>，然后，在可能出错的地方插入一句 <code>pdb.set_trace()</code>，这就设置了一个断点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># err.py</span></div><div class="line"><span class="keyword">import</span> pdb</div><div class="line"></div><div class="line">s = <span class="string">'0'</span></div><div class="line">n = int(s)</div><div class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></div><div class="line">print(<span class="number">10</span> / n)</div></pre></td></tr></table></figure>
<p>直接运行代码，这时程序会自动<strong>在 <code>pdb.set_trace()</code> 暂停并进入pdb调试环境</strong>，可以用命令 <code>p</code> 查看变量，用命令 <code>n</code> 单步执行，或者用命令 <code>c</code> 继续运行（<strong>如果有下一个断点就会停在下一个断点，否则直接运行到程序结束</strong>）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python err.py</div><div class="line">&gt; c:\users\administrator\desktop\err.py(7)&lt;module&gt;()</div><div class="line">-&gt; print(10 / n)</div><div class="line">(Pdb) p n</div><div class="line">0</div><div class="line">(Pdb) c</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "err.py", line 7, in &lt;module&gt;</div><div class="line">    print(10 / n)</div><div class="line">ZeroDivisionError: division by zero</div><div class="line"></div><div class="line">C:\Users\Administrator\Desktop&gt;</div></pre></td></tr></table></figure>
<p>这种方式的效率要比直接启动pdb进行单步调试更高。</p>
<hr>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>除了上面介绍到的方式之外，使用IDE附带的调试功能也是很常见的。通常IDE会自带一些快捷键，允许我们方便地设置断点、单步执行、查看变量值等等。<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm</a>是一个不错的选择。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。</p>
<p>虽然用IDE调试起来比较方便，但是最后你会发现，<code>logging</code> 才是终极武器。</p>
<hr>
<p><br></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h3><p>如果你听说过<strong>测试驱动开发（TDD：Test-Driven Development）</strong>，单元测试就不陌生。</p>
<p>单元测试是用来<strong>对一个模块、一个函数或者一个类来进行正确性检验的测试工作</strong>。</p>
<p>比如我们实现了一个求绝对值的函数 <code>abs()</code>，则测试用例需要包含以下这些情况：</p>
<ul>
<li>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</li>
<li>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</li>
<li>输入0，期待返回0；</li>
<li>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</li>
</ul>
<p>把上面的测试用例<strong>放到一个测试模块里</strong>，就得到了一个完整的单元测试。</p>
<p>如果单元测试通过，说明我们测试的代码能够正常工作。如果单元测试不通过，要么代码有bug，要么单元测试没有编写好，总之，需要修复代码使单元测试能够通过。</p>
<p>单元测试通过后有什么意义呢？如果我们对 <code>abs()</code> 函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对 <code>abs()</code> 函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，此时我们要么修改代码，要么修改测试。</p>
<p>这种以测试为驱动的开发模式最大的好处就是<strong>确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</strong></p>
<hr>
<h3 id="编写一个单元测试"><a href="#编写一个单元测试" class="headerlink" title="编写一个单元测试"></a>编写一个单元测试</h3><p>假设我们要编写一个 <code>Dict</code> 类，这个类的行为和 <code>dict</code> 一致，但是可以通过属性来访问，可以像下面这样使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dict(a=<span class="number">1</span>, b=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'a'</span>]</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.a</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>把类定义写在 <code>mydict.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></div><div class="line">        super().__init__(**kw)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Dict' object has no attribute '%s'"</span> % key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self[key] = value</div></pre></td></tr></table></figure>
<p>为了编写单元测试，我们需要引入Python自带的 <code>unittest</code> 模块，把单元测试写在 <code>mydict_test.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unittest         <span class="comment"># 导入Python自带的单元测试模块unittest</span></div><div class="line"><span class="keyword">from</span> mydict <span class="keyword">import</span> Dict <span class="comment"># 导入我们要进行单元测试的模块/类/函数等等</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDict</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_init</span><span class="params">(self)</span>:</span></div><div class="line">        d = Dict(a=<span class="number">1</span>, b=<span class="string">'test'</span>)</div><div class="line">        self.assertEqual(d.a, <span class="number">1</span>)</div><div class="line">        self.assertEqual(d.b, <span class="string">'test'</span>)</div><div class="line">        self.assertTrue(isinstance(d, dict))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_key</span><span class="params">(self)</span>:</span></div><div class="line">        d = Dict()</div><div class="line">        d[<span class="string">'key'</span>] = <span class="string">'value'</span></div><div class="line">        self.assertEqual(d.key, <span class="string">'value'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_attr</span><span class="params">(self)</span>:</span></div><div class="line">        d = Dict()</div><div class="line">        d.key = <span class="string">'value'</span></div><div class="line">        self.assertTrue(<span class="string">'key'</span> <span class="keyword">in</span> d)</div><div class="line">        self.assertEqual(d[<span class="string">'key'</span>], <span class="string">'value'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_keyerror</span><span class="params">(self)</span>:</span></div><div class="line">        d = Dict()</div><div class="line">        <span class="keyword">with</span> self.assertRaises(KeyError):</div><div class="line">            value = d[<span class="string">'empty'</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_attrerror</span><span class="params">(self)</span>:</span></div><div class="line">        d = Dict()</div><div class="line">        <span class="keyword">with</span> self.assertRaises(AttributeError):</div><div class="line">            value = d.empty</div></pre></td></tr></table></figure>
<p>我们使用一个测试类来实现单元测试，把所有类型的测试用例都封装为该类的方法。测试类继承自 <code>unittest</code> 模块的 <code>TestCase</code> 类。注意，<strong>所有测试方法都必须以 <code>test</code> 开头</strong>，不以 <code>test</code> 开头的方法不被认为是测试方法，测试的时候不会被执行。</p>
<p>每一类测试样例都需要编写一个 <code>test_xxx()</code> 方法。由于 <code>unittest.TestCase</code> 提供了很多内置的条件判断方法，我们只需要调用这些方法就可以断言输出是否符合我们的期望。最常用的断言就是 <code>assertEqual()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.assertEqual(abs(<span class="number">-1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></div></pre></td></tr></table></figure>
<p>另一种重要的断言就是期待抛出指定类型的Error，比如通过 <code>d[&#39;empty&#39;]</code> 访问不存在的 <code>key</code> 时，断言会抛出 <code>KeyError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> self.assertRaises(KeyError):</div><div class="line">    value = d[<span class="string">'empty'</span>]</div></pre></td></tr></table></figure>
<p>而通过 <code>d.empty</code> 访问不存在的 <code>key</code> 时，我们期待抛出 <code>AttributeError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> self.assertRaises(AttributeError):</div><div class="line">    value = d.empty</div></pre></td></tr></table></figure>
<p>当这些断言输出是否符合我们的期望时，测试用例通过，否则测试用例失败。这一小节知识说明怎样编写单元测试，具体怎么进行测试会在后续的小结中详细说明。</p>
<hr>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>这里补充一下 <code>with</code> 语法和 <code>assertRaises</code> 方法的说明。</p>
<h4 id="使用with的语法"><a href="#使用with的语法" class="headerlink" title="使用with的语法"></a>使用with的语法</h4><p>关于 <code>with</code> 语句的相关概念可以看看<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="external">浅谈 Python 的 with 语句</a>这篇文章。使用 <code>with</code> 的语法一般如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> ContextExpression [<span class="keyword">as</span> alias]:</div><div class="line">    <span class="keyword">with</span>-body</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        print(line)</div><div class="line">        <span class="comment"># ...more code</span></div></pre></td></tr></table></figure>
<p>跟在 <code>with</code> 关键字后的表达式称为<strong>上下文表达式</strong>，它必须能返回一个<strong>上下文管理器（Context Manager）</strong>对象。<code>with</code> 语句包裹起来的代码块则称为 <code>with</code>-语句体（with-body）。如果我们在语句体中不需要用到上下文管理器对象，就不需要为这个对象取别名（alias），也即方括号 <code>[]</code> 内的是可忽略的。比方说前面编写测试类的时候就不需要，而上面例子中由于我们需要使用文件对象中，所以取了别名 <code>f</code>。</p>
<p>上下文管理器对象都实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 这两个特殊方法。执行 <code>__enter__()</code> 方法会进行<strong>运行时上下文（runtime context）</strong>，执行 <code>__exit__()</code> 方法则会退出。我们可以直接调用这两个方法来管理运行时上下文，也可以<strong>使用 <code>with</code> 语句进行管理</strong>。在执行 <code>with</code>-语句体的代码之前，<code>__enter__()</code> 方法会被自动调用，而执行完 <code>with</code>-语句体的代码之后，<code>__exit__()</code> 方法会被调用来退出运行时上下文。</p>
<h4 id="assertRaises方法"><a href="#assertRaises方法" class="headerlink" title="assertRaises方法"></a>assertRaises方法</h4><p>接下来说说 <code>assertRaises</code> 方法，它有两种使用方法：</p>
<ol>
<li><code>assertRaises(exception, callable, *args, **kwds)</code></li>
<li><code>assertRaises(exception, msg=None)</code></li>
</ol>
<p>方法1测试我们使用参数 <code>*args</code> 和 <code>**kwds</code> 调用 <code>callable</code> 对象（可能是某个函数/方法）时，是否会出现 <code>exception</code> 异常，如果是则测试用例通过，否则测试失败。</p>
<p>方法2同样是测试一个异常是否出现，但当我们只传入异常时，<code>assertRaises</code> 方法会返回一个上下文管理器对象，所以我们可以用 <code>with</code> 来管理，从而实现判断运行某一段代码（放在 <code>with</code>-语句体中）时，是否出现某种异常的测试用例。</p>
<p>特别地，这些<strong> <code>TestCase</code> 类提供的断言方法都支持传入一个关键字参数 <code>msg</code></strong>，我们可以使用它自定义断言失败时提示的错误信息。</p>
<p>没指定 <code>msg</code> 参数时断言失败的报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AssertionError: KeyError <span class="keyword">not</span> raised</div></pre></td></tr></table></figure>
<p>指定了 <code>msg</code> 参数（假设指定 <code>msg = &#39;1234&#39;</code>）时断言失败的报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AssertionError: KeyError <span class="keyword">not</span> raised : <span class="number">1234</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p>一旦编写好单元测试，我们就可以运行单元测试，具体有两种实现方法。</p>
<p>第一次方法是直接在单元测试文件 <code>mydict_test.py</code> 的最后加上两行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<p>这样只要把 <code>mydict_test.py</code> 当成普通Python脚本来运行就可以了，运行时就会直接跑单元测试了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python mydict_test.py</div><div class="line">.....</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>第二种方法是在命令行通过参数 <code>-m unittest</code> 来运行单元测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python3 -m unittest mydict_test</div><div class="line">.....</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>第二种方法更为推荐，因为这样可以一次批量运行多个单元测试，比方说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python -m unittest mydict_test.py mydict_test.py</div><div class="line">..........</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">10</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>此外，还有很多工具可以自动来运行这些单元测试。</p>
<p>前面都是举单元测试运行通过的例子，接下来补充一个运行不通过的例子，看看有测试用例不通过时，运行单元测试会返回什么。比方说把 <code>test_keyerror(self)</code> 方法中的 <code>value = d[&#39;empty&#39;]</code> 语句换为 <code>pass</code>，这样语句体就不会返回 <code>KeyError</code> 了，断言会失败。看看此时运行单元测试的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python -m unittest mydict_test.py</div><div class="line">....F</div><div class="line">======================================================================</div><div class="line">FAIL: test_keyerror (mydict_test.TestDict)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"C:\Users\Administrator\Desktop\mydict_test.py"</span>, line <span class="number">27</span>, <span class="keyword">in</span> test_keyerror</div><div class="line">    <span class="keyword">pass</span></div><div class="line">AssertionError: KeyError <span class="keyword">not</span> raised</div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">FAILED (failures=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>可以看到这里汇报了失败的源头是 <code>test_keyerror</code> 这个测试方法，原因是这个方法的 <code>pass</code> 语句没有引起 <code>KeyError</code>，使得断言失败。最后还汇报了运行了5个测试、总共运行的时间、单元测试失败、失败的测试数为1。</p>
<h3 id="setUp与tearDown"><a href="#setUp与tearDown" class="headerlink" title="setUp与tearDown"></a>setUp与tearDown</h3><p>在测试类中除了定义 <code>test_xxx()</code> 这样的测试方法，我们还可以编写两个特殊的 <code>setUp()</code> 和 <code>tearDown()</code> 方法。这两个方法分别<strong>在每次调用一个测试方法的前后被执行</strong>。</p>
<p>那么这两个方法有什么实际意义呢？假设测试时需要启动一个数据库，如果我们在 <code>setUp()</code> 方法中编写连接数据库的代码，在 <code>tearDown()</code> 方法中编写关闭数据库，这样我们就不必在每个测试方法中重复编写相同的代码了，也即把功能封装起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDict</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'setUp'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'tearDown'</span>)</div></pre></td></tr></table></figure>
<p>再次运行单元测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python -m unittest mydict_test.py</div><div class="line">setUp</div><div class="line">tearDown</div><div class="line">.setUp</div><div class="line">tearDown</div><div class="line">.setUp</div><div class="line">tearDown</div><div class="line">.setUp</div><div class="line">tearDown</div><div class="line">.setUp</div><div class="line">tearDown</div><div class="line">.</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.016</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>这里看到多出了一些句号 <code>.</code>，它们是每个测试方法通过之后会打印的。</p>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>
</li>
<li><p>单元测试的测试用例要覆盖常用的<strong>输入组合、边界条件和异常</strong>。</p>
</li>
<li><p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p>
</li>
<li><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p>
</li>
<li><p>除了Python自带的 <code>unittest</code> 模块，不妨再了解一下 <a href="https://nose.readthedocs.io/en/latest/" target="_blank" rel="external">Nose</a> 和 <a href="http://docs.pytest.org/en/latest/" target="_blank" rel="external">PyTest</a> 这两个第三方模块。</p>
</li>
</ul>
<hr>
<p><br></p>
<h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><h3 id="使用文档测试"><a href="#使用文档测试" class="headerlink" title="使用文档测试"></a>使用文档测试</h3><p>如果你经常阅读Python的官方文档，可以看到很多官方文档都带有示例代码。比如 <a href="https://docs.python.org/2/library/re.html" target="_blank" rel="external"><code>re</code> 模块</a>的官方文档就带了很多示例代码，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">'(?&lt;=abc)def'</span>, <span class="string">'abcdef'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</div><div class="line"><span class="string">'def'</span></div></pre></td></tr></table></figure>
<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明<strong>可以写在注释中，然后，由一些工具来自动生成文档</strong>。既然这些代码本身就可以复制出来直接运行，那么，<strong>可不可以自动执行写在注释中的代码</strong>呢？</p>
<p>答案是肯定的，Python内置的 <strong>“文档测试”（<code>doctest</code>）模块</strong> 可以提取出注释中的代码并执行测试。</p>
<p>当我们编写注释时，如果写上这样的注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Function to get absolute value of number.</div><div class="line"></div><div class="line">    Example:</div><div class="line"></div><div class="line">    &gt;&gt;&gt; abs(1)</div><div class="line">    1</div><div class="line">    &gt;&gt;&gt; abs(-1)</div><div class="line">    1</div><div class="line">    &gt;&gt;&gt; abs(0)</div><div class="line">    0</div><div class="line">    '''</div><div class="line">    <span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</div></pre></td></tr></table></figure>
<p>无疑更明确地向函数的调用者说明了该函数的期望输入和输出。</p>
<p><code>doctest</code> <strong>严格按照Python交互式命令行的输入和输出来判断测试结果是否正确</strong>。只有<strong>测试异常的时候，可以用 <code>...</code> 来代替发生异常时Traceback的部分</strong>（毕竟实在是太长了..）。</p>
<p>不妨用文档测试 <code>doctest</code> 来重新实现上一节中为 <code>Dict</code> 类编写的单元测试，编写 <code>mydict.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mydict2.py</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Simple dict but also support access as x.y style.</div><div class="line">    # 以下为文档注释中的代码部分</div><div class="line">    &gt;&gt;&gt; d1 = Dict()</div><div class="line">    &gt;&gt;&gt; d1['x'] = 100</div><div class="line">    &gt;&gt;&gt; d1.x</div><div class="line">    100</div><div class="line">    &gt;&gt;&gt; d1.y = 200</div><div class="line">    &gt;&gt;&gt; d1['y']</div><div class="line">    200</div><div class="line">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3')</div><div class="line">    &gt;&gt;&gt; d2.c</div><div class="line">    '3'</div><div class="line">    &gt;&gt;&gt; d2['empty'] # 注意这里我们使用省略号...来替换了Traceback的细节</div><div class="line">    Traceback (most recent call last):</div><div class="line">        ...</div><div class="line">    KeyError: 'empty'</div><div class="line">    &gt;&gt;&gt; d2.empty</div><div class="line">    Traceback (most recent call last):</div><div class="line">        ...</div><div class="line">    AttributeError: 'Dict' object has no attribute 'empty'</div><div class="line">    '''</div><div class="line">    <span class="comment"># 以下为该类的方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></div><div class="line">        super(Dict, self).__init__(**kw)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Dict' object has no attribute '%s'"</span> % key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self[key] = value</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">import</span> doctest</div><div class="line">    doctest.testmod() <span class="comment"># 使用doctest模块的testmod函数来进行文档测试</span></div></pre></td></tr></table></figure>
<p>注意前面我们说的是<strong>注释</strong>，但这个注释并非使用 <code>#</code> 号标识的那种注释，而是文档注释，也即文档字符串。按<a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="external">PEP257</a>的定义：</p>
<blockquote>
<p>A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the <strong>doc</strong> special attribute of that object.</p>
</blockquote>
<p>所以这里 <code>Dict</code> 类的第一个字符串就是 <code>Dict</code> 类的文档注释，我们把用于文档测试的示例代码按照Python交互式命令行的输入和输出的标准来书写即可（只有测试异常时可以用 <code>...</code> 替换掉Traceback的部分）。</p>
<p>运行 <code>mydict.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python mydict.py</div></pre></td></tr></table></figure>
<p><strong>文档测试通过时，程序不会有任何输出</strong>。接下来我们试试把 <code>__getattr__()</code> 方法注释掉（这样就不能通过把字典的key作为属性来访问了），此时再运行 <code>mydict.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python mydict.py</div><div class="line">**********************************************************************</div><div class="line">File <span class="string">"mydict.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> __main__.Dict</div><div class="line">Failed example:</div><div class="line">    d1.x</div><div class="line">Exception raised:</div><div class="line">    Traceback (most recent call last):</div><div class="line">      File <span class="string">"F:\Anaconda3\lib\doctest.py"</span>, line <span class="number">1320</span>, <span class="keyword">in</span> __run</div><div class="line">        compileflags, <span class="number">1</span>), test.globs)</div><div class="line">      File <span class="string">"&lt;doctest __main__.Dict[2]&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">        d1.x</div><div class="line">    AttributeError: <span class="string">'Dict'</span> object has no attribute <span class="string">'x'</span></div><div class="line">**********************************************************************</div><div class="line">File <span class="string">"mydict.py"</span>, line <span class="number">13</span>, <span class="keyword">in</span> __main__.Dict</div><div class="line">Failed example:</div><div class="line">    d2.c</div><div class="line">Exception raised:</div><div class="line">    Traceback (most recent call last):</div><div class="line">      File <span class="string">"F:\Anaconda3\lib\doctest.py"</span>, line <span class="number">1320</span>, <span class="keyword">in</span> __run</div><div class="line">        compileflags, <span class="number">1</span>), test.globs)</div><div class="line">      File <span class="string">"&lt;doctest __main__.Dict[6]&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">        d2.c</div><div class="line">    AttributeError: <span class="string">'Dict'</span> object has no attribute <span class="string">'c'</span></div><div class="line">**********************************************************************</div><div class="line"><span class="number">1</span> items had failures:</div><div class="line">   <span class="number">2</span> of   <span class="number">9</span> <span class="keyword">in</span> __main__.Dict</div><div class="line">***Test Failed*** <span class="number">2</span> failures.</div></pre></td></tr></table></figure>
<p>可以看到因为没有实现把key作为属性访问的功能，此时文档注释中的两个example（即 <code>d1.x</code> 和 <code>d2.c</code> 这两行输入）出错了，而文档注释中总共包含9对输入输出example。</p>
<p>注意到，我们只在 <code>if __name__==&#39;__main__&#39;:</code> 代码块内写了执行文档测试的逻辑，也即只有在命令行中直接运行（<code>python mydict.py</code>）时会进行文档测试。而使用者使用这个类，在别的模块中导入该类（<code>from mydict import Dict</code>）时，文档测试是不会被执行的。因此，我们不必担心文档测试会在非测试环境下被执行，编写文档测试并不会影响到使用者使用该模块。</p>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>对函数 <code>fact(n)</code> 编写文档测试并执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    &gt;&gt;&gt; fact(1)</div><div class="line">    1</div><div class="line">    &gt;&gt;&gt; fact(5)</div><div class="line">    120</div><div class="line">    &gt;&gt;&gt; fact(0)</div><div class="line">    Traceback (most recent call last):</div><div class="line">        ...</div><div class="line">    ValueError</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">raise</span> ValueError()</div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">import</span> doctest</div><div class="line">    doctest.testmod()</div></pre></td></tr></table></figure>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>文档测试非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含文档测试的注释提取出来。用户看文档的时候，同时也能看到文档测试中。</p>
<hr>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-07面向对象高级编程]]></title>
      <url>http://2wildkids.com/2016/12/05/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#使用-\\slots\\">使用 __slots__</a><ul>
<li><a href="#动态绑定属性">动态绑定属性</a></li>
<li><a href="#动态绑定方法">动态绑定方法</a></li>
<li><a href="#限制可绑定的属性方法">限制可绑定的属性/方法</a></li>
</ul>
</li>
<li><a href="#使用property">使用@property</a><ul>
<li><a href="#为何需要property">为何需要@property</a></li>
<li><a href="#如何实现property">如何实现@property</a></li>
<li><a href="#练习">练习</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#多重继承">多重继承</a><ul>
<li><a href="#为何需要多重继承">为何需要多重继承</a></li>
<li><a href="#使用多重继承">使用多重继承</a></li>
<li><a href="#mixin">MixIn</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#定制类">定制类</a><ul>
<li><a href="#\\str\\">__str__</a></li>
<li><a href="#\\iter\\">__iter__</a></li>
<li><a href="#\\getitem\\">__getitem__</a></li>
<li><a href="#\\getattr\\">__getattr__</a></li>
<li><a href="#\\call\\">__call__</a></li>
<li><a href="#小结-2">小结</a></li>
</ul>
</li>
<li><a href="#使用枚举类">使用枚举类</a><ul>
<li><a href="#为何需要枚举类">为何需要枚举类</a></li>
<li><a href="#如何使用枚举类">如何使用枚举类</a></li>
<li><a href="#自定义枚举类">自定义枚举类</a></li>
<li><a href="#小结-3">小结</a></li>
</ul>
</li>
<li><a href="#使用元类">使用元类</a><ul>
<li><a href="#type函数">type函数</a></li>
<li><a href="#什么是元类">什么是元类</a></li>
<li><a href="#怎样使用元类">怎样使用元类</a></li>
<li><a href="#编写orm框架">编写ORM框架</a></li>
<li><a href="#小结-4">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>前面一章介绍了OOP最基础的数据封装、继承和多态3个概念，还有一些类和实例的操作。而在Python中，OOP还有很多更高级的特性，这一章会讨论多重继承、定制类、元类等概念。</p>
<h2 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用 __slots__"></a>使用 __slots__</h2><h3 id="动态绑定属性"><a href="#动态绑定属性" class="headerlink" title="动态绑定属性"></a>动态绑定属性</h3><p>正常情况下，当我们定义了一个类，创建了一个类的实例后，我们可以给这个实例绑定任何属性和方法，这就是动态语言的灵活性。先定义类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>然后，创建实例并给这个实例绑定一个属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 动态给实例绑定一个属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)</div><div class="line">Michael</div></pre></td></tr></table></figure>
<hr>
<h3 id="动态绑定方法"><a href="#动态绑定方法" class="headerlink" title="动态绑定方法"></a>动态绑定方法</h3><p>还可以尝试给实例绑定一个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span> <span class="comment"># 定义一个函数</span></div><div class="line"><span class="meta">... </span>    self.age = age</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 把函数绑定到实例上，变为实例的方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>注意到这里<strong>使用types模块的 <code>MethodType()</code> 函数来给实例绑定方法</strong>，为什么要用 <code>MethodType()</code> 而不是直接用 <code>s.set_age = set_age</code> 直接绑定呢？这是因为我们采用后者绑定时，只是绑定了一个外部函数，它与实例本身没有任何关联，<strong>没法使用self变量</strong>，而使用 <code>MethodType()</code> 就会真正地为实例绑定一个方法，也因此绑定的函数的<strong>第一个参数要设置为self变量</strong>。做个对比：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = set_age <span class="comment"># 直接绑定</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>)       <span class="comment"># 无法调用self变量</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: set_age() missing <span class="number">1</span> required positional argument: <span class="string">'age'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(s,<span class="number">25</span>)     <span class="comment"># 必须显式地传入实例s自身</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age</div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 使用MethodType绑定</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">30</span>)                      <span class="comment"># 可以调用self变量，只需传入一个参数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age</div><div class="line"><span class="number">30</span></div></pre></td></tr></table></figure>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Student() <span class="comment"># 创建新的实例</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_age(<span class="number">25</span>) <span class="comment"># 尝试调用方法</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'set_age'</span></div></pre></td></tr></table></figure>
<p>为了给所有实例都绑定方法，可以直接给类绑定方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></div><div class="line"><span class="meta">... </span>    self.score = score</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure>
<p><strong>给类绑定方法不需要使用 <code>MethodType()</code> 函数</strong>，并且所有实例均可调用绑定在类上的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">100</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_score(<span class="number">99</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.score</div><div class="line"><span class="number">99</span></div></pre></td></tr></table></figure>
<p>通常情况下，上面的 <code>set_score</code> 定义在类中，但<strong>动态绑定允许我们在程序运行的过程中动态给类加上功能</strong>，这在静态语言中很难实现。</p>
<hr>
<h3 id="限制可绑定的属性-方法"><a href="#限制可绑定的属性-方法" class="headerlink" title="限制可绑定的属性/方法"></a>限制可绑定的属性/方法</h3><p>上面两个小节介绍了怎样绑定属性和方法，但是如果我们想要<strong>限制可以绑定到实例的属性/方法</strong>怎么办呢？比方说，只允许对Student类的实例绑定 <code>name</code> 和 <code>age</code> 属性。</p>
<p>为了达到限制的目的，Python允许在定义类的时候，定义一个特殊的 <code>__slots__</code> 变量，来限制该类实例能添加的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    `__slots__`  = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure>
<p>然后，我们试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()      <span class="comment"># 创建新的实例</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 绑定属性'name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span>         <span class="comment"># 绑定属性'age'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span>       <span class="comment"># 绑定属性'score'</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></div></pre></td></tr></table></figure>
<p>由于属性 <code>score</code> 没有被放到 <code>__slots__</code> 变量中，所以实例不能绑定 <code>score</code> 属性，试图绑定 <code>score</code> 将得到 <code>AttributeError</code> 错误。</p>
<p>使用 <code>__slots__</code> 要注意，<strong><code>__slots__</code> 变量的属性限制仅对当前类的实例起作用，对继承的子类是不起作用的</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">GraduateStudent</span><span class="params">(Student)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = GraduateStudent()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.score = <span class="number">9999</span> <span class="comment"># 可以绑定任何属性</span></div></pre></td></tr></table></figure>
<p>但是！<strong>如果在子类中也定义 <code>__slots__</code> ，则子类实例允许定义的属性就既包括自身的 <code>__slots__</code> 也包括父类的 <code>__slots__</code> </strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">GraduateStudent</span><span class="params">(Student)</span>:</span></div><div class="line"><span class="meta">... </span>    __slots__ = (<span class="string">'score'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = GraduateStudent()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.name = <span class="string">'Angela'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.age = <span class="number">17</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.score = <span class="number">99</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2.sex = <span class="string">'Female'</span> <span class="comment"># 无法绑定父类__slots__和当前类__slots__都没有的属性</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'GraduateStudent'</span> object has no attribute <span class="string">'sex'</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><h3 id="为何需要-property"><a href="#为何需要-property" class="headerlink" title="为何需要@property"></a>为何需要@property</h3><p>在绑定属性时，如果我们直接把属性暴露出去供使用者修改，虽然写起来很简单，但是<strong>没办法检查设置的属性值是否合理</strong>，可以把成绩随便改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = Student()</div><div class="line">s.score = <span class="number">9999</span> <span class="comment"># 直接通过属性修改</span></div></pre></td></tr></table></figure>
<p>这显然不合逻辑。为了限制 <code>score</code> 的范围，可以通过一个 <code>set_score()</code> 方法来设置成绩，再通过一个 <code>get_score()</code> 来获取成绩，这样，在 <code>set_score()</code> 方法里，就可以检查参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></div><div class="line">         <span class="keyword">return</span> self._score</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</div><div class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</div><div class="line">        self._score = value</div></pre></td></tr></table></figure>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># 通过类的方法修改</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</div><div class="line"><span class="number">60</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</div></pre></td></tr></table></figure>
<p>但是，通过类的方法修改，调用者使用时比较麻烦，没有直接使用属性进行修改简单，而且对调用者是否自觉也有要求，如果调用者依然直接使用属性修改，就没法检查属性值了。</p>
<p>有没有<strong>既能检查属性值，又可以直接使用属性修改的办法呢</strong>？答案是有的！</p>
<hr>
<h3 id="如何实现-property"><a href="#如何实现-property" class="headerlink" title="如何实现@property"></a>如何实现@property</h3><p>在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md" target="_blank" rel="external">第四章-函数式编程</a>中，我们学习到了<strong>装饰器（decorator）</strong>，它可以给函数动态添加功能。事实上，不仅是对函数，<strong>装饰器对类的方法一样起作用</strong>。Python内置的 <code>@property</code> 装饰器就可以帮助我们实现前面的需求，把一个方法变成属性调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span>        <span class="comment"># 对应getter方法，也即前面例子的get_score(self)</span></div><div class="line">        <span class="keyword">return</span> self._score</div><div class="line"><span class="meta">    @score.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span> <span class="comment"># 对应setter方法，也即前面例子的set_score(self, value)</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</div><div class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</div><div class="line">        self._score = value</div></pre></td></tr></table></figure>
<p><code>@property</code> 的实现比较复杂。准确地说，把一个getter方法变成属性，只需要加上 <code>@property</code> 装饰器就可以了，而把一个setter方法变成属性赋值，这要加上一个 <code>@score.setter</code> 装饰器，也即 <code>@属性名.setter</code>。注意！<strong>属性名和方法名一定要区分开</strong>，否则会出错！这里我们把 <code>score</code> 属性改为 <code>_score</code> 属性，所以<strong>对内部来说 <code>_score</code> 是属性，<code>score</code> 是方法</strong>，<strong>对外部来说 <code>score</code> 是属性，<code>_score</code> 被封装起来了</strong>（因为我们使用了装饰器进行转换）。看看实际效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># 实际转化为s.score(60)</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score      <span class="comment"># 实际转化为s.score()</span></div><div class="line"><span class="number">60</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span> <span class="comment"># 对外部来说可以直接使用属性赋值，同时也能检查属性值</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</div></pre></td></tr></table></figure>
<p>还可以定义只读属性，<strong>只定义getter方法，不定义setter方法就是一个只读属性</strong>，只读属性只能获取属性值，无法设置属性值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._birth</div><div class="line"><span class="meta">    @birth.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._birth = value</div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span> <span class="comment"># 只读属性age，根据birth进行计算</span></div><div class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</div></pre></td></tr></table></figure>
<p>上面的birth是可读写属性，而age就是一个只读属性：。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.birth = <span class="number">2000</span> <span class="comment"># 可读写属性birth可以进行赋值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.birth</div><div class="line"><span class="number">2000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">17</span>     <span class="comment"># 只读属性age无法进行赋值</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: can<span class="string">'t set attribute</span></div></pre></td></tr></table></figure>
<p>注意必须先对属性 <code>birth</code> 进行赋值，然后才可以访问 <code>birth</code> 和 <code>age</code>，否则就会出现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.birth</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> birth</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'_birth'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">10</span>, <span class="keyword">in</span> age</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'_birth'</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>请利用 <code>@property</code> 给一个 <code>Screen</code> 对象加上 <code>width</code> 和 <code>height</code> 属性，以及一个只读属性 <code>resolution</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._width</div><div class="line"><span class="meta">    @width.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._width = value</div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._height</div><div class="line"><span class="meta">    @height.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._height = value</div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolution</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._width * self._height</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Screen()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.width = <span class="number">1024</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.height = <span class="number">768</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.resolution)</div><div class="line"><span class="number">786432</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> s.resolution == <span class="number">786432</span>, <span class="string">'1024 * 768 = %d ?'</span> % s.resolution</div></pre></td></tr></table></figure>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>@property</code> 广泛应用在类的定义中，可以让调用者写出简短的代码，同时又保证了对属性值进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<hr>
<p><br></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="为何需要多重继承"><a href="#为何需要多重继承" class="headerlink" title="为何需要多重继承"></a>为何需要多重继承</h3><p>在<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.md" target="_blank" rel="external">第六章-面向对象编程</a>中，我们学习了面向对象编程的一个重要性质——继承。<strong>通过继承，子类可以获得父类的所有功能并进行进一步扩展</strong>。</p>
<p>假设我们设计了一个 <code>Animal</code> 类，并要为以下4种动物设计四个新的类：</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。</li>
</ul>
<p>如果把这些动物按照哺乳动物和鸟类分类，我们可以设计出这样的类的层次：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_MixIn1.png" alt="MixIn1"></p>
<p>但是如果按照能跑的和能飞的来分类，则设计出这样的类的层次就变为：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_MixIn2.png" alt="MixIn2"></p>
<p>但是，如果要把上面的两种分类方法都包含进来，我们就得<strong>设计更多的层次</strong>了。哺乳类要分为能跑的哺乳类和能飞的哺乳类，鸟类也要能跑的鸟类，能飞的鸟类。这么一来，类的层次变得很复杂了：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_MixIn3.png" alt="MixIn3"></p>
<p>如果<strong>再增加更多的分类方式</strong>（例如：宠物和非宠物），那么<strong>类的数量会呈指数增长</strong>，这样设计就显得很不实用了。</p>
<hr>
<h3 id="使用多重继承"><a href="#使用多重继承" class="headerlink" title="使用多重继承"></a>使用多重继承</h3><p>分析一下前面的设计方法，其实之所以会造成类的数量呈指数增长，是因为<strong>每个类只能继承一个类</strong>，这就造成了很多不必要的重复实现。解决方法是采用<strong>多重继承</strong>。比方说设计为：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_MixIn4.png" alt="MixIn4"></p>
<p>因为能跑和能飞这两个类不受限于动物类，它们是独立的。我们单独实现这两个类，即使要再实现其他非动物的类，比如汽车和飞机，也能很轻松地继承它们的功能，而不需要再重复构造功能类似的新的类。而动物分类方面，假设我们加入宠物非宠物的分类，也不需再构造哺乳的能飞的宠物、鸟类的能飞的宠物等等类别，通过多重继承免去了很多麻烦。先进行动物分类的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 大类:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mammal</span><span class="params">(Animal)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>接下来定义好 <code>Runnable</code> 和 <code>Flyable</code> 的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Running...'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Flying...'</span>)</div></pre></td></tr></table></figure>
<p>对于需要 <code>Runnable</code> 功能的动物，只需要多继承一个 <code>Runnable</code>，例如 <code>Dog</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>对于需要 <code>Flyable</code> 功能的动物，只需要多继承一个 <code>Flyable</code>，例如 <code>Bat</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span><span class="params">(Mammal, Flyable)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><strong>通过多重继承，一个子类可以同时获得多个父类的所有功能</strong>。</p>
<h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p>在设计类的继承关系时，<strong>通常主线都是单一继承下来的</strong>，例如，<code>Ostrich</code> 继承自 <code>Bird</code>。但是，如果需要<strong>混入额外的功能</strong>，通过多重继承就可以实现，比如，让 <code>Ostrich</code> 除了继承自 <code>Bird</code> 外，再同时继承 <code>Runnable</code>。种<strong>（利用多重继承混入额外的功能）这种设计方式通常称之为MixIn</strong>。</p>
<p>为了更好地看出继承关系，我们<strong>通常把用于添加额外功能的类命名带上一个后缀MixIn</strong>，例如把 <code>Runnable</code> 和 <code>Flyable</code> 改为 <code>RunnableMixIn</code> 和 <code>FlyableMixIn</code>n 和 植食动物 <code>HerbivoresMixIn</code>，让某个动物同时拥有好几个MixIn：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><strong>MixIn的目的就是给一个类增加多个功能</strong>，这样，在设计类的时候，我们可以<strong>优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系</strong>。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了 <code>TCPServer</code> 和 <code>UDPServer</code> 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 <code>ForkingMixIn</code> 和 <code>ThreadingMixIn</code> 提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, ForkingMixIn)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>编写一个多线程模式的UDP服务，定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUDPServer</span><span class="params">(UDPServer, ThreadingMixIn)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>如果你打算搞一个更先进的协程模型，可以编写一个 <code>CoroutineMixIn</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, CoroutineMixIn)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>这样一来，我们<strong>不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类</strong>。</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>由于<strong>Python允许使用多重继承</strong>，因此，MixIn就是一种常见的设计。</p>
</li>
<li><p><strong>只允许单一继承的语言</strong>（如Java）不能使用MixIn的设计。</p>
</li>
</ul>
<hr>
<p><br></p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>在前面的章节中，我们知道了可以用 <code>__slots__</code> 变量限制可绑定的属性，我们也知道了在构造类的时候，只要定义了 <code>__len__()</code> 方法，用户就能使用Python内置的 <code>len()</code> 函数获取该类实例的长度。我们知道<strong>形如 <code>__xxx__</code> 的变量/方法都是有特殊用途的</strong>，那么<strong>Python中还有哪些特殊的变量/方法可以帮助我们更好地定制类</strong>呢？</p>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>我们先定义一个 <code>Student</code> 类，然后打印一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"><span class="meta">... </span>        self.name = name</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</div><div class="line">&lt;__main__.Student object at <span class="number">0x109afb190</span>&gt;</div></pre></td></tr></table></figure>
<p>但是这样打印实例，我们只能知道它属于什么类以及在内存的位置，它的其他信息全都无法了解，所以对使用者来说并不友好。怎么才能<strong>定制打印的信息，使得打印实例时可以看到更多有用的信息</strong>呢？只需要定义好 <code>__str__()</code> 方法就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"><span class="meta">... </span>        self.name = name</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</div><div class="line">Student object (name: Michael)</div></pre></td></tr></table></figure>
<p>这样打印实例就不但能知道实例所属的类，也能获得这个实例的属性信息了。</p>
<p>但是细心的朋友会发现<strong>直接敲变量不用 <code>print</code> 函数</strong>，打印出的实例依然是原来的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&lt;__main__.Student object at <span class="number">0x109afb310</span>&gt;</div></pre></td></tr></table></figure>
<p>这是因为<strong>直接显示变量调用的不是 <code>__str__()</code> 方法，而是 <code>__repr__()</code> 方法</strong>，两者的区别是 <code>__str__()</code> 方法返回<strong>用户看到的字符串</strong>，而 <code>__repr__()</code> 返回<strong>程序开发者看到的字符串</strong>，也就是说，<strong><code>__repr__()</code> 是为调试服务的</strong>。</p>
<p>解决办法是再定义一个 <code>__repr__()</code> 方法。但是通常 <code>__str__()</code> 和 <code>__repr__()</code>代码都是一样的（当然，要写不同的也行），所以，有个偷懒的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</div><div class="line">    __repr__ = __str__ <span class="comment"># 直接令__repr__等于__str__</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h3><p>如果我们希望用 <code>for ... in</code> 循环来遍历一个类的实例，像遍历 <code>list</code> 或 <code>tuple</code> 那样，就必须实现一个 <code>__iter__()</code> 方法，该方法返回一个迭代对象，然后，Python的 <code>for</code> 循环就会不断调用该迭代对象的 <code>__next__()</code> 方法拿到循环的下一个值，直到遇到 <code>StopIteration</code> 错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个 <code>Fib</code> 类，可以作用于 <code>for</code> 循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，返回自己即可</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></div><div class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></div><div class="line">            <span class="keyword">raise</span> StopIteration();</div><div class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></div></pre></td></tr></table></figure>
<p>现在，试试把Fib类的实例作用于 <code>for</code> 循环，就能遍历斐波拉契数列了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line">...</div><div class="line"><span class="number">46368</span></div><div class="line"><span class="number">75025</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p><code>Fib</code> 类的实例虽然能作用于 <code>for</code> 循环，看起来和 <code>list</code> 有点像了，但是<strong>没有办法使用下标访问</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'Fib'</span> object does <span class="keyword">not</span> support indexing</div></pre></td></tr></table></figure>
<p>要能像 <code>list</code> 那样按照下标访问元素，需要实现 <code>__getitem__()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></div><div class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</div><div class="line">            a, b = b, a + b</div><div class="line">        <span class="keyword">return</span> a</div></pre></td></tr></table></figure>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]</div><div class="line"><span class="number">89</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</div><div class="line"><span class="number">573147844013817084101</span></div></pre></td></tr></table></figure>
<p>但是 <code>list</code> 有个神奇的<strong>切片</strong>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">100</span>))[<span class="number">5</span>:<span class="number">10</span>]</div><div class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>对于 <code>Fib</code> 却报错。原因是 <strong><code>__getitem__()</code> 传入的参数可能是一个 <code>int</code>，也可能是一个 <code>slice</code>（切片对象）</strong>，所以要<strong>做判断</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></div><div class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</div><div class="line">                a, b = b, a + b</div><div class="line">            <span class="keyword">return</span> a</div><div class="line">        <span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></div><div class="line">            start = n.start</div><div class="line">            stop = n.stop</div><div class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                start = <span class="number">0</span></div><div class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></div><div class="line">            L = []</div><div class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</div><div class="line">                <span class="keyword">if</span> x &gt;= start:</div><div class="line">                    L.append(a)</div><div class="line">                a, b = b, a + b</div><div class="line">            <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<p>现在再试试对 <code>Fib</code> 类的实例使用切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</div></pre></td></tr></table></figure>
<p>但是<strong>没有对 <code>step</code>（步长）参数作处理</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</div></pre></td></tr></table></figure>
<p><strong>也没有对负数作处理</strong>，所以，要正确实现一个完整的 <code>__getitem__()</code> 还是有很多工作要做的。</p>
<p>此外，如果把对象看成 <code>dict</code>，那么 <code>__getitem__()</code> 的参数也可能是一个可以作key的object，例如 <code>str</code>。</p>
<p>与 <code>__getitem__()</code> 方法对应的是 <code>__setitem__()</code> 方法，把对象视作 <code>list</code> 或 <code>dict</code> 来对一个/多个位置进行赋值。除此之外，还有 <code>__delitem__()</code> 方法，用于删除某个位置的元素。</p>
<p>总之，通过实现上面的方法，可以让我们自己定义的类表现得和Python自带的 <code>list</code>、<code>tuple</code>、<code>dict</code> 没什么区别，这完全归功于<strong>动态语言的“鸭子类型”特点</strong>，<strong>不需要强制继承某个接口就能实现该接口的部分功能</strong>。</p>
<hr>
<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.name = <span class="string">'Michael'</span></div></pre></td></tr></table></figure>
<p>调用name属性，没问题，但是，调用不存在的score属性，就有问题了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)</div><div class="line">Michael</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.score)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></div></pre></td></tr></table></figure>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>
<p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个 <code>__getattr__()</code> 方法，<strong>动态返回一个属性</strong>。修改如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.name = <span class="string">'Michael'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">if</span> attr==<span class="string">'score'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">99</span></div></pre></td></tr></table></figure>
<p><strong>当调用不存在的属性时，Python解释器会试图调用 <code>__getattr__(self, &#39;属性名&#39;)</code>来尝试获得属性</strong>，依然用 <code>score</code> 属性做例子，进行上述定义后，再次执行就变成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</div><div class="line"><span class="string">'Michael'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</div><div class="line"><span class="number">99</span></div></pre></td></tr></table></figure>
<p><strong>动态返回函数</strong>也是完全可以的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">if</span> attr==<span class="string">'age'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></div></pre></td></tr></table></figure>
<p>只是调用方式要变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age()</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>注意，<strong>只有在没有找到属性的情况下，才调用 <code>__getattr__</code></strong>，已有的属性，比如 <code>name</code>，不会在 <code>__getattr__</code> 中查找。</p>
<p>此外，注意到此时调用其他任意属性，如 <code>s.abc</code>，返回的是 <code>None</code>，这是因为在 <code>__getattr__</code> 中我们没有为这些属性定义返回值，那么<strong>默认返回就是 <code>None</code></strong>。要让类只响应特定的几个属性，我们可以<strong>默认抛出 <code>AttributeError</code> 错误</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">if</span> attr==<span class="string">'age'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></div><div class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</div></pre></td></tr></table></figure>
<p>这样就相当于<strong>把一个类的属性和方法调用都进行动态化处理</strong>了，不需要其他特殊手段。</p>
<p>这种<strong>完全动态调用的特性有什么实际作用呢</strong>？作用就是，可以针对完全动态的情况作调用。举个例子，现在很多网站都搞 REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://api.server/user/friends</div><div class="line">http://api.server/user/timeline/list</div></pre></td></tr></table></figure>
<p>如果要写SDK，为每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p>借助完全动态的 <code>__getattr__</code> 方法，我们可以非常方便地实现<strong>链式调用</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path=<span class="string">''</span>)</span>:</span></div><div class="line">        self._path = path</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, path)</span>:</span></div><div class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, path))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._path</div><div class="line">    __repr__ = __str__</div></pre></td></tr></table></figure>
<p>试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>chain = Chain(<span class="string">'http://api.server'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>API1 = chain.user.friends</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(API1)</div><div class="line">http://api.server/user/friends</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>API2 = chain.user.timeline.list</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(API2)</div><div class="line">http://api.server/user/timeline/list</div></pre></td></tr></table></figure>
<p>由于 <code>__getattr__</code> 返回的也是一个 <code>Chain</code> 类的实例，所以后面继续接着使用点符访问属性也是可以的，这就是<strong>链式调用</strong>的本质。这样，<strong>无论想调用什么API，SDK都可以根据不同的URL进行完全动态的调用，不需要随API的增加而改变</strong>！相当方便！！</p>
<p>还有一些REST API会<strong>把参数放在URL中</strong>，比如GitHub的API：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /users/:user/repos</div></pre></td></tr></table></figure>
<p>调用时，需要把 <code>:user</code> 替换为实际用户名。这时我们希望可以用这样的链式调用来获取API：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chain().users(<span class="string">'michael'</span>).repos</div></pre></td></tr></table></figure>
<p>尝试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path=<span class="string">''</span>)</span>:</span></div><div class="line">        self._path = path</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, path)</span>:</span></div><div class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, path))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">users</span><span class="params">(self, username)</span>:</span></div><div class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, username))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._path</div><div class="line">    __repr__ = __str__</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>chain = Chain(<span class="string">'/users'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chain.users(<span class="string">'michael'</span>).repos</div><div class="line">/users/michael/repos</div></pre></td></tr></table></figure>
<p>当然，除了实现一个 <code>users</code> 方法之外，直接在 <code>getattr</code> 方法里面使用正则也是可以的。</p>
<hr>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用 <code>实例名.方法名()</code> 的方式来调用。能不能<strong>直接把实例本身当作一个方法调用</strong>呢？在Python中，答案是肯定的。</p>
<p>对任何类来说，<strong>只需要实现 <code>__call__()</code> 方法，就可以直接对该类的实例进行调用</strong>。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</div></pre></td></tr></table></figure>
<p>调用方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># 调用实例本身，self参数不需要传入</span></div><div class="line">My name <span class="keyword">is</span> Michael.</div></pre></td></tr></table></figure>
<p>和普通的函数和方法一样，我们还可以为 <code>__call__()</code> 方法定义其他参数。但有一点很特别，我们注意到<strong>类的实例都是运行期间动态创建出来的</strong>，而一般来说可调用对象（函数/方法）都是预先定义的，所以说当我们把实例本身变成可调用的方法时，实际上我们是<strong>动态创建了可调用对象</strong>。</p>
<p><strong>能被调用的对象就是一个 <code>Callable</code> 对象</strong>，要判断一个对象是否可调用可以使用Python内置的 <code>callable</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(max)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="keyword">None</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Python中的类允许定义许多定制方法，可以让我们非常方便地生成特定的类。</p>
<p>本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="external">Python的官方文档</a>。</p>
<hr>
<p><br></p>
<h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><h3 id="为何需要枚举类"><a href="#为何需要枚举类" class="headerlink" title="为何需要枚举类"></a>为何需要枚举类</h3><p>当我们需要<strong>定义常量/枚举值</strong>时，一个比较常见的办法是用大写变量通过整数来定义，例如月份：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JAN = <span class="number">1</span></div><div class="line">FEB = <span class="number">2</span></div><div class="line">MAR = <span class="number">3</span></div><div class="line">...</div><div class="line">NOV = <span class="number">11</span></div><div class="line">DEC = <span class="number">12</span></div></pre></td></tr></table></figure>
<p>这样做的好处是简单，缺点是把数据类型变为了 <code>int</code> 型，并且在Python中仍然是变量，因此<strong>可能会在使用者无法意识到的情况下被错误的操作改变值</strong>。</p>
<hr>
<h3 id="如何使用枚举类"><a href="#如何使用枚举类" class="headerlink" title="如何使用枚举类"></a>如何使用枚举类</h3><p>更好的方法是使用Python提供的枚举类 <code>Enum</code>，<strong>把每一个枚举对象作为枚举类的一个属性</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</div><div class="line"></div><div class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>)) <span class="comment"># 创建一个枚举类的实例</span></div></pre></td></tr></table></figure>
<p>这样我们就获得了一个<strong>类型为 <code>Month</code></strong> 的枚举类，可以直接使用 <code>Month.Jan</code> 来引用一个常量，或者枚举它的所有成员：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</div><div class="line"><span class="meta">... </span>    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</div><div class="line">...</div><div class="line">Jan =&gt; Month.Jan , <span class="number">1</span></div><div class="line">Feb =&gt; Month.Feb , <span class="number">2</span></div><div class="line">Mar =&gt; Month.Mar , <span class="number">3</span></div><div class="line">Apr =&gt; Month.Apr , <span class="number">4</span></div><div class="line">May =&gt; Month.May , <span class="number">5</span></div><div class="line">Jun =&gt; Month.Jun , <span class="number">6</span></div><div class="line">Jul =&gt; Month.Jul , <span class="number">7</span></div><div class="line">Aug =&gt; Month.Aug , <span class="number">8</span></div><div class="line">Sep =&gt; Month.Sep , <span class="number">9</span></div><div class="line">Oct =&gt; Month.Oct , <span class="number">10</span></div><div class="line">Nov =&gt; Month.Nov , <span class="number">11</span></div><div class="line">Dec =&gt; Month.Dec , <span class="number">12</span></div></pre></td></tr></table></figure>
<p>特别地，枚举类中的每个成员会被分配一个 <code>int</code> 型的 <code>value</code> 属性，默认<strong>按初始化顺序从1开始计数</strong>。</p>
<hr>
<h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><p>如果需要<strong>更精确地控制枚举类型</strong>，可以继承 <code>Enum</code> 类然后进行自定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</div><div class="line"></div><div class="line"><span class="meta">@unique</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></div><div class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></div><div class="line">    Mon = <span class="number">1</span></div><div class="line">    Tue = <span class="number">2</span></div><div class="line">    Wed = <span class="number">3</span></div><div class="line">    Thu = <span class="number">4</span></div><div class="line">    Fri = <span class="number">5</span></div><div class="line">    Sat = <span class="number">6</span></div></pre></td></tr></table></figure>
<p><code>@unique</code> 装饰器可以帮助我们<strong>检查枚举值是否存在重复</strong>，注意属性名字重复也会报错，但是与 <code>@unique</code> 装饰器无关。</p>
<p>自定义的枚举类使用方法和使用 <code>Enum</code> 构造的类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon         <span class="comment"># 按属性访问</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1)                <span class="comment"># 打印枚举变量</span></div><div class="line">Weekday.Mon</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>day1                       <span class="comment"># 直接显示枚举变量</span></div><div class="line">&lt;Weekday.Mon: <span class="number">1</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>day1.name                  <span class="comment"># 获得枚举变量的名称</span></div><div class="line"><span class="string">'Mon'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>day1.value                 <span class="comment"># 获得枚举变量的值</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday[<span class="string">'Tue'</span>])      <span class="comment"># 使用属性名作下标访问</span></div><div class="line">Weekday.Tue</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Mon) <span class="comment"># 属性之间可以直接进行比较</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Tue)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday(<span class="number">1</span>))           <span class="comment"># 把类作为一个方法调用，传入枚举值</span></div><div class="line">Weekday.Mon</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday(<span class="number">1</span>))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)                  <span class="comment"># 找不到该枚举值对应的属性</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items(): <span class="comment"># 遍历枚举类</span></div><div class="line"><span class="meta">... </span>    print(name, <span class="string">'=&gt;'</span>, member)</div><div class="line">...</div><div class="line">Sun =&gt; Weekday.Sun</div><div class="line">Mon =&gt; Weekday.Mon</div><div class="line">Tue =&gt; Weekday.Tue</div><div class="line">Wed =&gt; Weekday.Wed</div><div class="line">Thu =&gt; Weekday.Thu</div><div class="line">Fri =&gt; Weekday.Fri</div><div class="line">Sat =&gt; Weekday.Sat</div></pre></td></tr></table></figure>
<hr>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>使用枚举类可以把一组相关常量定义在一个类中，转化为该类的不同属性，该类不可变（属性都是只读的）且属性可以直接进行比较。</p>
<hr>
<p><br></p>
<h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><h3 id="type函数"><a href="#type函数" class="headerlink" title="type函数"></a>type函数</h3><p>动态语言和静态语言最大的不同，就是在动态语言中，<strong>函数和类的定义，不是编译时定义的，而是运行时动态创建的</strong>。</p>
<p>比方说我们要定义一个 <code>Hello</code> 类，首先编写一个 <code>hello.py</code> 模块，里面的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span></div><div class="line">        print(<span class="string">'Hello, %s.'</span> % name)</div></pre></td></tr></table></figure>
<p>当Python解释器<strong>导入 <code>hello</code> 模块时</strong>，就会依次执行该模块的所有语句（与我们在交互环境下逐个语句输入来定义类一样），从而<strong>动态创建出一个类对象</strong>（注意这里说的是类对象而不是实例对象），测试如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from hello import Hello # 这个语句创建了一个名为Hello的类对象</div><div class="line">&gt;&gt;&gt; h = Hello()             # 创建一个Hello类的实例h</div><div class="line">&gt;&gt;&gt; h.hello()</div><div class="line">Hello, world.</div><div class="line">&gt;&gt;&gt; print(type(Hello))      # Hello对象的类型为type</div><div class="line">&lt;class 'type'&gt;</div><div class="line">&gt;&gt;&gt; print(type(h))          # 而Hello类实例的类型为hello.Hello</div><div class="line">&lt;class 'hello.Hello'&gt;</div><div class="line">&gt;&gt;&gt; type(str)               # str是一个类型</div><div class="line">&lt;class 'type'&gt;</div><div class="line">&gt;&gt;&gt; type(int)               # int也是一个类型</div><div class="line">&lt;class 'type'&gt;</div></pre></td></tr></table></figure>
<p><code>type()</code> 函数可以用来<strong>查看一个变量的类型</strong>，<code>Hello</code> 是一个类，它的类型就是 <code>type</code>，而 <code>h</code> 是一个实例，它的类型就是它所属的类。</p>
<p>前面说到，<strong>在Python中，类的定义是运行时动态创建的</strong>。而<strong>动态创建类使用的其实是 <code>type()</code>函数</strong>。<code>type()</code> 函数<strong>既可以返回一个变量的类型，又可以创建出新的类型</strong>。依然举 <code>Hello</code> 类为例子，但我们这次使用 <code>type()</code> 函数来创建 <code>Hello</code> 类而不使用显式的 <code>class Hello</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数</div><div class="line">...     print('Hello, %s.' % name)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class</div><div class="line">&gt;&gt;&gt; h = Hello()</div><div class="line">&gt;&gt;&gt; h.hello()</div><div class="line">Hello, world.</div><div class="line">&gt;&gt;&gt; print(type(Hello))</div><div class="line">&lt;class 'type'&gt;</div><div class="line">&gt;&gt;&gt; print(type(h))</div><div class="line">&lt;class '__main__.Hello'&gt;</div></pre></td></tr></table></figure>
<p>使用 <code>type()</code> 函数创建一个类对象，需要依次传入以下3个参数：</p>
<ul>
<li><strong>类名</strong></li>
<li><strong>继承的父类集合</strong>：Python支持多重继承，所以这里用一个 <code>tuple</code> 来囊括继承的所有父类。注意只有一个父类时，要采用 <code>tuple</code> 的单元素写法，不要漏掉逗号。</li>
<li><strong>类的方法名与函数的绑定</strong>：在上面的例子中，我们把函数 <code>fn</code> 绑定到方法名 <code>hello</code> 上。也即类 <code>Hello</code> 的方法 <code>hello</code> 就是函数 <code>fn</code>，注意<strong>这和这章开头所说的动态绑定方法是不同的</strong>。</li>
</ul>
<p>通过 <code>type()</code> 函数创建的类和直接写类是完全一样的。事实上，<strong>Python解释器遇到类定义时，在扫描类定义的语法之后，就是调用 <code>type()</code> 函数来创建类的</strong>。</p>
<p>正常情况下，我们都用 <code>class 类名(父类1, 父类2, ...)</code> 的方式来定义类，但是，<code>type()</code> 函数也允许我们动态创建类。</p>
<p>动态语言能够支持运行期间动态创建类，这和静态语言有非常大的不同。关于这两者的区别，感兴趣的话可以再查找其他资料。</p>
<hr>
<h3 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h3><p>除了使用 <code>type()</code> 函数动态创建类以外，<strong>要控制类的创建行为，还可以使用元类（metaclass）。</strong></p>
<p>怎么理解什么是元类呢？简单地解释一下：</p>
<ul>
<li>当我们定义了类以后，以类为模版就可以创建出实例了。</li>
<li>但如果我们要创建类呢？那就必须先定义元类，有了元类之后，以元类为模版就可以创建出类了。</li>
<li>连起来就是：<strong>以元类为模版创建类，以类为模版创建该类的实例</strong>。</li>
</ul>
<p>也就是说，<strong>可以把类看成是元类创建出来的“实例”</strong>。</p>
<p><img src="https://i.stack.imgur.com/QQ0OK.png" alt="metaclass"></p>
<p>图片来源：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">What is a metaclass in Python?</a></p>
<p>在上一个小节中，我们了解到可以使用 <code>type()</code> 函数创建类，但 <code>type</code> 的本质是什么呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; help(type)</div><div class="line">Help on class type in module builtins:</div><div class="line"></div><div class="line">class type(object)</div><div class="line"> |  type(object_or_name, bases, dict)</div><div class="line"> |  type(object) -&gt; the object's type</div><div class="line"> |  type(name, bases, dict) -&gt; a new type</div><div class="line"> |</div><div class="line"> |  Methods defined here:</div><div class="line"> |</div><div class="line"> |  __call__(self, /, *args, **kwargs)</div><div class="line"> |      Call self as a function.</div><div class="line"> ...</div></pre></td></tr></table></figure>
<p>其实呀， <code>type</code> 本身就是一个类，调用 <code>type()</code> 创建类得到的其实就是 <code>type</code> 类的实例。所以所有类对象的类型都是 <code>type</code>。不难分析出，<strong><code>type</code> 是一个元类</strong>，并且<strong>类都是默认以元类 <code>type</code> 为模版创建的</strong>。</p>
<hr>
<h3 id="怎样使用元类"><a href="#怎样使用元类" class="headerlink" title="怎样使用元类"></a>怎样使用元类</h3><p>如果我们想要创建一个元类，并且想以这个元类为模版创建类，那么定义元类的时候，就应当让这个元类<strong>继承自 <code>type</code> 类</strong>。</p>
<p>按照习惯，<strong>元类的类名应总是以Metaclass结尾</strong>，以便清楚地表示这是一个元类。下面举一个例子，定义元类 <code>ListMetaclass</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMetaclass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        attrs[<span class="string">'add'</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div></pre></td></tr></table></figure>
<p>元类的 <code>__new__()</code> 方法用于创建一个类对象，它接收四个参数，依次是：</p>
<ul>
<li>准备创建的类对象；</li>
<li>准备创建的类的名字；</li>
<li>准备创建的类继承的父类集合；</li>
<li>准备创建的类的方法集合。</li>
</ul>
<p>我们在 <code>ListMetaclass</code> 的 <code>__new__()</code> 方法中加入了一句 <code>attrs[&#39;add&#39;] = lambda self, value: self.append(value)</code>，然后调用元类 <code>type</code> 的 <code>__new__()</code> 方法创建类对象。这多出来的一句，实际上我们是给要创建的类提供了一个 <code>add</code> 方法，这个 <code>add</code> 方法接收实例本身和一个变量，并把这个变量拼接到实例的尾部。其实就是一个 <code>append</code> 方法。</p>
<p>定义好元类 <code>ListMetaclass</code> 之后，我们以它为模版创建类，注意<strong>传入关键字参数 <code>metaclass</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list, metaclass=ListMetaclass)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>传入关键字参数 <code>metaclass</code> 后，Python解释器会在创建 <code>MyList</code> 类时，通过元类 <code>ListMetaclass</code> 的 <code>__new__()</code> 方法来创建。因此虽然我们在类定义时没有为 <code>MyList</code> 类定义任何方法，但因为它是以元类 <code>ListMetaclass</code> 为模版创建的，所以拥有了 <code>add</code> 方法。另外，因为它继承了 <code>list</code> 类，所以我们相当于创建了一个拥有 <code>add</code> 方法的新的 <code>list</code> 类，测试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = MyList()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.add(<span class="number">1</span>) <span class="comment"># 使用add方法在列表尾部添加元素</span></div><div class="line">&gt;&gt; L</div><div class="line">[<span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.add(<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>普通的 <code>list</code> 是没有 <code>add()</code> 方法的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = list()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2.add(<span class="number">1</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'list'</span> object has no attribute <span class="string">'add'</span></div></pre></td></tr></table></figure>
<p>但是，直接在 <code>MyList</code> 类的定义中写上 <code>add()</code> 方法不是更简单吗？是的，<strong>正常情况下我们应该直接在类定义中编写方法，而不是通过元类</strong>。</p>
<p>但是，也有需要<strong>通过元类动态修改类定义</strong>的情况，ORM就是一个典型的例子。</p>
<hr>
<h3 id="编写ORM框架"><a href="#编写ORM框架" class="headerlink" title="编写ORM框架"></a>编写ORM框架</h3><p>ORM 全称 <strong>Object Relational Mapping（对象-关系映射）</strong>，简单来说就是<strong>把关系型数据库中表格的每一行都映射为一个对象，而每一个表就是一个类</strong>。这样写代码更简单，不用直接操作SQL语句。</p>
<p>要编写一个 ORM 框架供不同的使用者使用，框架中的所有类都应该能动态定义，因为每位使用者的需求不同，需要根据具体的表结构来定义出不同的类。</p>
<p>举个例子，假如使用者想使用这个 ORM 框架定义一个 <code>User</code> 类来操作数据库中的表格 <code>User</code>，我们期望使用者可以写出这样简洁的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></div><div class="line">    <span class="comment"># 定义类的属性到表格中列的映射：</span></div><div class="line">    id = IntegerField(<span class="string">'id'</span>)</div><div class="line">    name = StringField(<span class="string">'username'</span>)</div><div class="line">    email = StringField(<span class="string">'email'</span>)</div><div class="line">    password = StringField(<span class="string">'password'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个实例：</span></div><div class="line">u = User(id=<span class="number">12345</span>, name=<span class="string">'Michael'</span>, email=<span class="string">'test@orm.org'</span>, password=<span class="string">'my-pwd'</span>)</div><div class="line"><span class="comment"># 插入到表格中：</span></div><div class="line">u.insert()</div></pre></td></tr></table></figure>
<p>也即，用户在使用这个 ORM 框架时，每个表格对应一个类，类定义只需要指定表格每列的字段类型即可，每一行数据都是该类的一个实例。而父类 <code>Model</code> 和数据类型 <code>StringField</code>、<code>IntegerField</code> 等都由 ORM 框架负责提供。<code>save()</code> 之类的方法则全部由元类自动完成。<strong>虽然这样元类的编写会比较复杂，但 ORM 的使用者用起来却可以异常简单</strong>。</p>
<p>想好了希望实现怎样的效果后，我们可以开始编写调用接口。</p>
<p>首先定义 <code>Field</code> 类，它是最底层的类，负责保存字段名（列名）和对应的字段类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.column_type = column_type</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s:%s&gt;'</span> % (self.__class__.__name__, self.name)</div><div class="line">    __repr__ = __str__</div></pre></td></tr></table></figure>
<p>在 <code>Field</code> 的基础上，我们可以进一步定义各种类型的 <code>Field</code>，比如 <code>StringField</code>，<code>IntegerField</code> 等等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        super(StringField, self).__init__(name, <span class="string">'varchar(100)'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        super(IntegerField, self).__init__(name, <span class="string">'bigint'</span>)</div></pre></td></tr></table></figure>
<p>注意这里使用了 <code>super</code> 函数来获取父类的方法，并进行绑定，先看一看官方的解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">super(type[, object-<span class="keyword">or</span>-type])</div><div class="line">  Return the superclass of type. If the second argument <span class="keyword">is</span> omitted the super object</div><div class="line">  returned <span class="keyword">is</span> unbound. If the second argument <span class="keyword">is</span> an object, isinstance(obj, type)</div><div class="line">  must be true. If the second argument <span class="keyword">is</span> a type, issubclass(type2, type) must be</div><div class="line">  true. super() only works <span class="keyword">for</span> new-style classes.</div><div class="line">  A typical use <span class="keyword">for</span> calling a cooperative superclass method <span class="keyword">is</span>:</div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></div><div class="line">       <span class="function"><span class="keyword">def</span> <span class="title">meth</span><span class="params">(self, arg)</span>:</span></div><div class="line">           super(C, self).meth(arg)</div><div class="line">  New <span class="keyword">in</span> version <span class="number">2.2</span>.</div></pre></td></tr></table></figure>
<p>所以这里实际上我们实例化 <code>StringField</code> 和 <code>IntegerField</code> 时，是调用它们的父类，也即 <code>Field</code> 类的 <code>__init__</code> 方法进行的，这两个类封装了 <code>Field</code> 的功能，<strong>使用者只需要传入字段名就可以了，不需要关心在数据库中类型的名字</strong>。上面的实现比较简单，不需要使用元类。</p>
<p>接下来先理一理整体的实现思路，我们编写 ORM 框架来实现底层的功能，用户使用该框架时，只需要根据自己的需求来为表格定义对应的类，比方说上面举的例子中定义 <code>User</code> 类那样。这个类的实例对应表格中的一行，定义一个新实例 <code>u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)</code>，我们希望得到这个实例后可以通过 <code>print(u[&#39;name&#39;])</code> 的方式读取字段值，通过 <code>u[&#39;id&#39;]=23456</code> 的方式来修改字段值，这就类似于Python中的 <code>dict</code> 的功能，所以我们实际上最底层的父类采用 <code>dict</code> 即可。</p>
<p>但是，我们除了 <code>dict</code> 的功能之外，肯定还需要实现一些其他功能，比如把新实例插入到数据库的表格中。这些功能我们可以在 <code>Model</code> 类中实现，<code>Model</code> 类继承 <code>dict</code> 类，这样我们就可以像前面说的那样进行读取和修改了。使用者为表格编写类时继承 <code>Model</code> 类即可，这样所有表格都能得到 <code>Model</code> 类中实现的操作表格的功能了。</p>
<p>但是，我们还注意到一点，我们希望用户定义类的时候，写法尽可能简单，只需要关注有哪些字段，然后<strong>每个字段作为一个属性</strong>，用 <code>id = IntegerField(&#39;id&#39;)</code> 的方式来定义，也即 <code>属性名 = 字段类型（&#39;字段名&#39;）</code>，字段类型的实现前面已经说过了。</p>
<p>这里我们需要关注另外一个很重要的点，在实例化得到表格的一行以后，我们希望使用者可以采用 <code>实例名.属性名 = 值</code> 的方式来修改这一行某个字段的值。但事实上，使用者定义类的时候，类属性表示的是<strong>以某个字段名为名的某字段类型的实例</strong>，属性的类型是 <code>StringField</code> 或者 <code>IntegerField</code>。而在读取或修改一个实例的属性值时，我们希望实例属性表示的是<strong>这一行数据在这个字段的值</strong>，属性的类型是 <code>str</code> 或者 <code>int</code>。这里说得比较绕，简单归纳来说就是<strong>用户定义类的方式和使用该类实例的方式不相符</strong>。</p>
<p>我们希望使用者定义类的方式尽可能简单，同时也能用简单的方式修改字段值（实例的属性值），但由于<strong>类属性和实例属性同名时，对实例属性赋值会覆盖类属性</strong>，所以我们必须进行一些修改去避免这个问题。怎么实现呢？这时候我们就要用到元类了，虽然作为框架的编写者，我们要做的工作比较多，但这样使用者用起来就很方便了，他们依然可以很简单地定义类，但<strong>运行时类定义会被元类动态修改</strong>，我们可以把类属性该为其他名字，这样类定义中的类属性信息就可以保留下来了，而且不会被实例属性的赋值所覆盖。</p>
<p>另外，由于使用者不一定明白元类这么复杂的概念，所以我们把元类封装在 <code>Model</code> 类的定义中，指定 <code>Model</code> 类使用 <code>ModelMetaclass</code> 为模版。把前面所说的更换类属性名的操作封装在 <code>ModelMetaclass</code> 中，使用者为表格编写类的时候只需要继承 <code>Model</code> 类，那么运行时就会自动以 <code>ModelMetaclass</code> 为模版，得到 <code>ModelMetaclass</code> 的所有功能。但是要注意，<code>Model</code> 类本身不需要更换类属性名，所以在 <code>ModelMetaclass</code> 中我们要排除掉 <code>Model</code> 类。</p>
<p>接下来，直接上代码。元类 <code>ModelMetaclass</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="comment"># 四个参数，依次为：准备创建的类对象，类的名字，继承的父类集合，属性&amp;方法集合</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="comment"># Model类不需额外操作，先排除掉</span></div><div class="line">        <span class="keyword">if</span> name==<span class="string">'Model'</span>:</div><div class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div><div class="line">        <span class="comment"># 其他类（对应具体的表格）则把类属性使用dict存好，绑定到__mappings__属性上</span></div><div class="line">        <span class="comment"># 然后删除掉这些类属性</span></div><div class="line">        <span class="comment"># 这里还动态地要创建的类添加了一个表名属性__table__，直接令表名等于类名</span></div><div class="line">        <span class="comment"># 当然也可以作一些其他修改</span></div><div class="line">        print(<span class="string">'Found model: %s'</span> % name)</div><div class="line">        mappings = dict()</div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items(): <span class="comment"># 取出每个类属性</span></div><div class="line">            <span class="comment"># 因为除了用户定义的类属性之外，还有一些继承自父类的属性等等</span></div><div class="line">            <span class="comment"># 所以这里要先判断一下，属于字段类型的属性才需要考虑</span></div><div class="line">            <span class="keyword">if</span> isinstance(v, Field):</div><div class="line">                print(<span class="string">'Found mapping: %s ==&gt; %s'</span> % (k, v))</div><div class="line">                mappings[k] = v <span class="comment"># 使用一个dict保存 类属性名-字段类型实例 的映射</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</div><div class="line">            attrs.pop(k)</div><div class="line">        attrs[<span class="string">'__mappings__'</span>] = mappings <span class="comment"># 把映射绑定到__mappings__属性上</span></div><div class="line">        attrs[<span class="string">'__table__'</span>] = name        <span class="comment"># 把表名绑定到__table__属性上</span></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div></pre></td></tr></table></figure>
<p>父类 <code>Model</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></div><div class="line">        super(Model, self).__init__(**kw) <span class="comment"># 创建一个dict</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span> <span class="comment"># 可以采用点符访问实例属性（字段值）</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute '%s'"</span> % key)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span> <span class="comment"># 可以采用点符修改实例属性（字段值）</span></div><div class="line">        self[key] = value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self)</span>:</span>  <span class="comment"># 将实例插入到数据库的对应表格中</span></div><div class="line">        fields = []</div><div class="line">        values = []</div><div class="line">        <span class="comment"># 取得这一行数据的字段名及对应字段值</span></div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</div><div class="line">            fields.append(v.name)</div><div class="line">            values.append(str(getattr(self, k, <span class="keyword">None</span>)))</div><div class="line">        <span class="comment"># 格式化SQL语句（MySQL语法）</span></div><div class="line">        sql = <span class="string">'INSERT INTO %s (%s) values (%s)'</span> % (self.__table__, <span class="string">','</span>.join(fields), <span class="string">','</span>.join(values))</div><div class="line">        print(<span class="string">'SQL: %s'</span> % sql) <span class="comment"># 输出SQL语句，这里我们没有写真的插入数据库的操作，只是举例子</span></div></pre></td></tr></table></figure>
<p>当用户为 <code>User</code> 表定义 <code>User</code> 类时，Python解释器首先在当前类 <code>User</code> 的定义中查找是否有metaclass关键字，如果没有找到，就继续在父类 <code>Model</code> 中查找metaclass关键字，因为父类 <code>Model</code> 定义了以元类 <code>ModelMetaclass</code> 为模版来创建，所以 <code>User</code> 类也会以元类 <code>ModelMetaclass</code> 为模版来创建。借助元类，我们可以<strong>在运行时动态地修改子类的定义，但使用者定义子类时却不需要显式地声明</strong>。</p>
<p>使用者定义 <code>User</code> 类之后，会输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Found model: User</div><div class="line">Found mapping: password ==&gt; &lt;StringField:password&gt;</div><div class="line">Found mapping: name ==&gt; &lt;StringField:username&gt;</div><div class="line">Found mapping: email ==&gt; &lt;StringField:email&gt;</div><div class="line">Found mapping: id ==&gt; &lt;IntegerField:id&gt;</div></pre></td></tr></table></figure>
<p>运行时，类定义被元类动态地修改了，使用者定义的四个类属性被集成到 <code>__mappings__</code> 属性中，因此不会被实例属性覆盖，也就不会丢失字段名信息了。</p>
<p>创建实例，然后把这个实例（一行数据）插入到数据库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 创建一个实例：</span></div><div class="line"><span class="meta">... </span>u = User(id=<span class="number">12345</span>, name=<span class="string">'Michael'</span>, email=<span class="string">'test@orm.org'</span>, password=<span class="string">'my-pwd'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 插入到表格中：</span></div><div class="line"><span class="meta">... </span>u.insert()</div><div class="line">SQL: INSERT INTO User (email,username,password,id) values (test@orm.org,Michael,my-pwd,<span class="number">12345</span>)</div></pre></td></tr></table></figure>
<p>我们也可以看看 <code>__mappings__</code> 属性怎么样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>User.__mappings__</div><div class="line">&#123;<span class="string">'email'</span>: &lt;StringField:email&gt;, <span class="string">'name'</span>: &lt;StringField:username&gt;, <span class="string">'password'</span>: &lt;StringField:password&gt;, <span class="string">'id'</span>: &lt;IntegerField:id&gt;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u.__mappings__</div><div class="line">&#123;<span class="string">'email'</span>: &lt;StringField:email&gt;, <span class="string">'name'</span>: &lt;StringField:username&gt;, <span class="string">'password'</span>: &lt;StringField:password&gt;, <span class="string">'id'</span>: &lt;IntegerField:id&gt;&#125;</div></pre></td></tr></table></figure>
<p>正如我们定义那样，它是一个 <code>dict</code>，里面保存着各个字段的名字和它们的数据类型。</p>
<p>虽然我们没有真的实现插入数据库，但可以看到打印出的SQL语句是正确的，要实现完整的功能，只要再使用数据库模块的接口就可以了。通过这样短短不到100行的代码，我们就借助元类实现了一个精简的 ORM 框架。</p>
<hr>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>元类是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-06面向对象编程]]></title>
      <url>http://2wildkids.com/2016/11/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#基本概念">基本概念</a><ul>
<li><a href="#对比面向过程与面向对象">对比面向过程与面向对象</a></li>
<li><a href="#五种编程范式的区分">五种编程范式的区分</a></li>
<li><a href="#面向对象编程的三大特点">面向对象编程的三大特点</a></li>
</ul>
</li>
<li><a href="#类和实例">类和实例</a><ul>
<li><a href="#数据封装">数据封装</a></li>
<li><a href="#访问限制">访问限制</a></li>
<li><a href="#获取和修改限制访问的属性">获取和修改限制访问的属性</a></li>
</ul>
</li>
<li><a href="#继承和多态">继承和多态</a><ul>
<li><a href="#基本概念-1">基本概念</a></li>
<li><a href="#实例的数据类型">实例的数据类型</a></li>
<li><a href="#多态的好处">多态的好处</a></li>
<li><a href="#开闭原则">开闭原则</a></li>
<li><a href="#静态语言-vs-动态语言">静态语言 VS 动态语言</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#获取对象信息">获取对象信息</a><ul>
<li><a href="#type函数">type函数</a></li>
<li><a href="#isinstance函数">isinstance函数</a></li>
<li><a href="#dir函数">dir函数</a></li>
<li><a href="#hasattr函数、setattr函数、getattr函数">hasattr函数、setattr函数、getattr函数</a></li>
</ul>
</li>
<li><a href="#实例属性和类属性">实例属性和类属性</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>面向对象编程 —— Object Oriented Programming，简称OOP，是一种编程思想。OOP把对象作为程序的基本单元，<strong>一个对象不仅包含数据还包含操作数据的函数</strong>。</p>
<h3 id="对比面向过程与面向对象"><a href="#对比面向过程与面向对象" class="headerlink" title="对比面向过程与面向对象"></a>对比面向过程与面向对象</h3><ul>
<li><p><strong>面向过程编程（Procedural programming）</strong>：把计算机程序视为<strong>一系列子程序的集合</strong>。为了简化程序设计，面向过程把子程序继续切分为更小的子程序，也即把大的功能分为若干小的功能进行实现，从而降低系统的复杂度，这种做法也称为<strong>模块化（Modularity）</strong>。</p>
</li>
<li><p><strong>面向对象编程（Object-oriented programming）</strong>：把计算机程序视为<strong>一组对象的集合</strong>，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
</li>
</ul>
<p>下面以保存和打印学生成绩表为例，分别展示面向过程编程和面向对象编程的不同：</p>
<p><strong>面向过程编程</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_score</span><span class="params">(name, score)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'name'</span>:name, <span class="string">'score'</span>:score&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(std)</span>:</span></div><div class="line">    print(<span class="string">'%s: %s'</span> % (std[<span class="string">'name'</span>], std[<span class="string">'score'</span>]))</div><div class="line"></div><div class="line">bart = save_score(<span class="string">'Michael'</span>, <span class="number">98</span>)</div><div class="line">lisa = save_score(<span class="string">'Bob'</span>, <span class="number">81</span>)</div><div class="line"></div><div class="line">print_score(bart)</div><div class="line">print_score(lisa)</div></pre></td></tr></table></figure>
<p>面向过程编程其实就是细分功能并逐步实现，这里分出了保存成绩和打印成绩两个细的功能，并分别封装成子程序（或者说函数），然后通过调用各个子程序来实现程序的最终目标（保存并打印成绩）。</p>
<p><strong>面向对象编程</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.score = score</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'%s: %s'</span> % (self.name, self.score))</div><div class="line"></div><div class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</div><div class="line">lisa = Student(<span class="string">'Lisa Simpson'</span>, <span class="number">87</span>)</div><div class="line">bart.print_score()</div><div class="line">lisa.print_score()</div></pre></td></tr></table></figure>
<p>面向对象编程强调程序的主体是对象，这里我们把学生抽象成一个<strong>类（class）</strong>，这个类的对象拥有 <code>name</code> 和 <code>score</code> 这两个<strong>属性（Property）</strong>，那么保存成绩就是把学生类实例化为<strong>对象（object）</strong>，打印成绩就是给每个学生对象发送一个 <code>print_score</code> 的<strong>消息（message）</strong>，让对象自己打印自己的属性。这个发送消息的过程又称为调用对象的<strong>方法（method）</strong>，注意区分函数和方法。</p>
<hr>
<h3 id="五种编程范式的区分"><a href="#五种编程范式的区分" class="headerlink" title="五种编程范式的区分"></a>五种编程范式的区分</h3><p>这一小节是额外加上的，因为之前第4章<a href="https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md" target="_blank" rel="external">函数式编程</a>也讲了一种编程范式，这章又引入了面向过程编程和面向对象编程的概念，所以就在这里整理一下。也可以直接查看维基词条：<a href="https://en.wikipedia.org/wiki/Procedural_programming#Comparison_with_imperative_programming" target="_blank" rel="external">Wikipedia - Procedural programming</a> 以及引用的文章，讲得比较细致和清晰。更详细的可以查找专门讲编程范式的书籍来浏览。</p>
<h4 id="面向过程编程（Procedural-programming）"><a href="#面向过程编程（Procedural-programming）" class="headerlink" title="面向过程编程（Procedural programming）"></a>面向过程编程（Procedural programming）</h4><p>面向过程就是拆分和逐步实现，前一小节已经说过了，这里不再累述。</p>
<h4 id="命令式编程（Imperative-programming）"><a href="#命令式编程（Imperative-programming）" class="headerlink" title="命令式编程（Imperative programming）"></a>命令式编程（Imperative programming）</h4><p>有时候面向过程编程又称为命令式编程，两者经常混用，但它们之间还是有一点差别的。面向过程编程依赖于<strong>块</strong>和<strong>域</strong>，比方说有 <code>while</code>，<code>for</code> 等保留字；而命令式编程则没有这样的特征，一般采用 <code>goto</code> 或者分支来实现。</p>
<h4 id="面向对象编程（Object-oriented-programming）"><a href="#面向对象编程（Object-oriented-programming）" class="headerlink" title="面向对象编程（Object-oriented programming）"></a>面向对象编程（Object-oriented programming）</h4><p>面向对象也在上一小节简单介绍过了，它比面向过程编程抽象程度更高，面向过程将一个编程任务划分为若干变量、数据结构和子程序的组合，而面向对象则是划分为对象，对象的行为（方法）、使用对象的数据（成员/属性）的接口。面向过程编程使用子程序去操作数据，而面向对象则把这两者结合为对象，每一个对象的方法作用在自身上。</p>
<h4 id="函数式编程（Functional-programming）"><a href="#函数式编程（Functional-programming）" class="headerlink" title="函数式编程（Functional programming）"></a>函数式编程（Functional programming）</h4><p>在模块化和代码复用上，函数式编程和面向过程编程是很像的。但函数式编程中不再强调指令（赋值语句）。面向过程编写出的程序是一组指令的集合，这些指令可能会隐式地修改了一些公用的状态，而函数式编程则规避了这一点，<strong>每一个语句都是一个表达式，只依赖于自己而不依赖外部状态</strong>，因为我们现在所用的计算机都是基于指令运作的，所以函数式编程的效率会稍低一些，但是函数式编程一个很大的好处就是，既然每个语句都是独立的，那么就<strong>很容易实现并行化</strong>了。</p>
<h4 id="逻辑编程（Logic-programming）"><a href="#逻辑编程（Logic-programming）" class="headerlink" title="逻辑编程（Logic programming）"></a>逻辑编程（Logic programming）</h4><p>逻辑编程是一种我们现在比较少接触的变成范式，它关注于表达问题是什么是不是怎样解决问题。感兴趣的话可以了解一下Prolog语言。</p>
<hr>
<h3 id="面向对象编程的三大特点"><a href="#面向对象编程的三大特点" class="headerlink" title="面向对象编程的三大特点"></a>面向对象编程的三大特点</h3><ol>
<li><strong>数据封装</strong></li>
<li><strong>继承</strong></li>
<li><strong>多态</strong></li>
</ol>
<hr>
<p><br></p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>在Python中定义类是通过 <code>class</code> 关键字完成的，像前面例子一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>定义类的格式是 <code>class 类名(继承的类名)</code> 。 <strong>类名一般用大写字母开头</strong>，关于继承的知识会留在后续的章节里详述，<strong>object类是所有类的父类</strong>，在Python3中不写也行（既可以写作 <code>class Student:</code> 或 <code>class Student():</code>），会自动继承，详情可以看<a href="http://stackoverflow.com/questions/4015417/python-class-inherits-object" target="_blank" rel="external">python class inherits object</a>。</p>
<p>定义类以后，即使没有定义构造函数和属性，我们也可以实例化对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart</div><div class="line">&lt;__main__.Student object at <span class="number">0x10a67a590</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Student</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到变量bart指向的就是一个Student类的实例，<strong>每个实例的地址是不一样的</strong>。</p>
<p>与静态语言不同，Python作为动态语言，我们可以自由地给一个实例变量绑定属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name = <span class="string">'Bart Simpson'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</div><div class="line"><span class="string">'Bart Simpson'</span></div></pre></td></tr></table></figure>
<p><strong>绑定的属性在定义类时无须给出</strong>，随时都可以给一个实例绑定新属性。 但是！<strong>这样绑定的新属性仅仅绑定在这个实例上</strong>，别的实例是没有的！ 也就是说，<strong>同一个类的多个实例例拥有的属性可能不同</strong>！</p>
<p>对于我们认为<strong>必须绑定的属性</strong>，可以通过定义特殊的 <code>__init__</code> 方法进行初始化，在创建实例时就进行绑定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">    self.name = name</div><div class="line">    self.score = score</div></pre></td></tr></table></figure>
<p>使用 <code>__init__</code> 方法要注意：</p>
<ol>
<li>第一个参数永远是 <code>self</code>，<strong>指向创建出的实例本身</strong>。</li>
<li><strong>有了 <code>__init__</code> 方法，创建实例时就不能传入空的参数，必须传入与 <code>__init__</code> 方法匹配的参数</strong>，参数self不用传，Python解释器会自动传入。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</div><div class="line"><span class="string">'Bart Simpson'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</div><div class="line"><span class="number">59</span></div></pre></td></tr></table></figure>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>数据封装是面向对象编程特点之一，对于类的每个实例而言，属性访问可以通过函数来实现。 既然<strong>实例本身拥有属性数据</strong>，那么访问实例的数据就不需要通过外面的函数实现，可以<strong>直接在类的内部定义访问数据的函数</strong>。</p>
<p><strong>利用内部定义的函数，就把数据封装起来了</strong>，这些函数和类本身是关联的，称为<strong>类的方法</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.score = score</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'%s: %s'</span> % (self.name, self.score))</div></pre></td></tr></table></figure>
<p>依然是前面的例子，可以看到在类中定义方法和外面定义的函数<strong>唯一区别就是方法的第一个参数永远是实例变量 <code>self</code></strong>。其他一致，仍然可以用默认参数，可变参数，关键字参数和命名关键字参数等参数形式。和创建实例一样，调用方法时不需传入self。</p>
<p>对于外部，<strong>类的方法实现细节不用了解</strong>，只需要知道怎样调用，能返回什么就可以了。</p>
<hr>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>尽管前一节中我们把数据用方法进行了封装，但事实上，实例化对象后，我们依然可以直接通过属性名来访问一个实例的属性值，并且自由地修改属性值。要让实例的内部属性不被外部访问，只需要在属性的名称前加上两个下划线 <code>__</code> 就可以了，此时属性就转换成了<strong>私有属性</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line"><span class="meta">... </span>        self.__name = name   <span class="comment"># 绑定私有属性__name</span></div><div class="line"><span class="meta">... </span>        self.__score = score <span class="comment"># 绑定私有属性__score</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span>   <span class="comment"># 通过方法访问私有属性</span></div><div class="line"><span class="meta">... </span>        print(self.__name, self.__score)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart'</span>, <span class="number">98</span>) <span class="comment"># 创建一个Student类的实例bart</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name                <span class="comment"># 由于访问限制的保护，对外部而言，实例bart是没有__name这个属性的</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'__name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__score                <span class="comment"># 由于访问限制的保护，对外部而言，实例bart是没有__score这个属性的</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'__score'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()          <span class="comment"># 但是通过print_score方法可以访问该实例的__name属性和__score属性</span></div><div class="line">Bart <span class="number">98</span></div></pre></td></tr></table></figure>
<p>这是怎么实现的呢？其实呀，不能访问的实质是Python解释器<strong>对外给私有变量添加了前缀</strong> <code>_类名</code>，比如把 <code>__name</code> 会被改成 <code>_Student__name</code> 。所以我们在外部（即不是通过类的方法）访问时，<code>__name</code> 属性是不存在的，但访问 <code>_Student__name</code> 属性就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name</div><div class="line"><span class="string">'Bart'</span></div></pre></td></tr></table></figure>
<p>所以说，<strong>即使有访问限制，外部依然可以访问和修改内部属性</strong>，Python没有任何机制预防这一点，只有靠使用者自己注意了。</p>
<p>还有一点必须明白。<strong>使用访问限制跟绑定属性是不冲突的</strong>，所以虽然对内而言存在 <code>__name</code> 属性，但对外而言这个属性不存在，我们依然可以给实例绑定一个 <code>__name</code> 属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">'Alice'</span> <span class="comment"># 外部绑定__name属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name           <span class="comment"># 现在外部可以访问__name属性了</span></div><div class="line"><span class="string">'Alice'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()    <span class="comment"># 但对内部方法来说，__name属性依然是原来的</span></div><div class="line">Bart <span class="number">98</span></div></pre></td></tr></table></figure>
<p>Python同样<strong>没有任何机制防止我们给实例绑定一个和私有属性同名的属性</strong>，从外部是可以访问这样绑定的属性的，但对内部方法而言，这种<strong>绑定的赋值不会覆盖私有属性原来的值</strong>，所以极容易出错，只有靠使用者自己注意了。</p>
<p>通过 <code>dir(bart)</code> 可以查看实例包含的所有变量（属性和方法）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(bart)</div><div class="line">[<span class="string">'_Student__name'</span>, <span class="string">'_Student__score'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>,</div><div class="line"><span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>,</div><div class="line"><span class="string">'__name'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>,</div><div class="line"><span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'print_score'</span>]</div></pre></td></tr></table></figure>
<p>在Python中，变量名类似 <code>__xxx__</code> 的，也就是<strong>以双下划线开头，并且以双下划线结尾</strong>的，是<strong>特殊变量</strong>，特殊变量允许直接访问，<strong>注意私有变量不要这样取名</strong>。有时会看到以<strong>一个下划线开头</strong>的变量名，比如 <code>_name</code>，这样的变量外部是可以访问的，不属于访问限制，但是按照约定，这样的变量我们应<strong>视为私有变量，不应在外部直接访问</strong>。</p>
<hr>
<h3 id="获取和修改限制访问的属性"><a href="#获取和修改限制访问的属性" class="headerlink" title="获取和修改限制访问的属性"></a>获取和修改限制访问的属性</h3><p>对于限制访问的属性，外部代码还是需要进行访问和修改的，我们可以在类中定义对应的get方法和set方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line"><span class="meta">... </span>        self.__name = name   <span class="comment"># 绑定私有属性__name</span></div><div class="line"><span class="meta">... </span>        self.__score = score <span class="comment"># 绑定私有属性__score</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span>   <span class="comment"># 通过方法访问私有属性</span></div><div class="line"><span class="meta">... </span>        print(self.__name, self.__score)</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.__name</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.__score</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</div><div class="line"><span class="meta">... </span>        self.__score = score</div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>        <span class="keyword">raise</span> ValueError(<span class="string">'bad score'</span>)</div></pre></td></tr></table></figure>
<p>通过类的set方法修改属性值，而不直接在外部修改有一个明显的好处，我们<strong>可以在类的方法中对参数做检查，避免传入无效的参数</strong>。 比如这里可以限制修改成绩时成绩的范围必须是0~100，超出就报错。</p>
<hr>
<p><br></p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>在OOP程序设计中，当我们定义一个类的时候，可以从某个现有的类继承，新的类称为<strong>子类（Subclass）</strong>，被继承的类则称为<strong>基类/父类/超类（Base class/Super class）</strong>。比方说我们创建一个Animal类，该类有一个run方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">            print(<span class="string">'Animal is running...'</span>)</div></pre></td></tr></table></figure>
<p>定义一个Dog类继承Animal类，尽管我们没有为它编写任何方法，但它却可以<strong>获得父类的全部功能</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line">       <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog=Dog()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog.run()</div><div class="line">Animal <span class="keyword">is</span> running...</div></pre></td></tr></table></figure>
<p>我们也可以为子类增加新的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>       print(<span class="string">'Dog is running...'</span>)</div><div class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>       print(<span class="string">'Eating meat...'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog.run()</div><div class="line">Dog <span class="keyword">is</span> running</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog.eat()</div><div class="line">Eating meat</div></pre></td></tr></table></figure>
<p>这里我们除了定义一个新的 <code>eat</code> 方法之外，还定义了一个和父类方法同名的 <code>run</code> 方法，它会覆盖父类的方法，当调用子类实例的 <code>run</code> 方法时调用的就会是子类定义的 <code>run</code> 方法而不是父类的 <code>run</code> 方法了，这个特点称作<strong>多态</strong>。总结一下，<strong>如果子类也定义一个和父类相同的方法，则执行时总是调用子类的方法</strong>。</p>
<hr>
<h3 id="实例的数据类型"><a href="#实例的数据类型" class="headerlink" title="实例的数据类型"></a>实例的数据类型</h3><p>我们<strong>定义一个类，实际就是定义了一种数据类型</strong>，和 <code>list</code>，<code>str</code> 等没有什么区别，要判断一个变量是否属于某种数据类型可以使用 <code>isinstance()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(dog,Animal)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(dog,Dog)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>实例化子类的对象<strong>既属于子类数据类型也属于父类数据类型</strong>！但是反过来就不可以，实例化父类的对象不属于子类数据类型。</p>
<hr>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><p>比方说在外部编写一个函数，接收含有 <code>run</code> 方法的变量作参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span></div><div class="line">    animal.run()</div><div class="line">    animal.run()</div></pre></td></tr></table></figure>
<p>当传入Animal类的实例时就执行Animal类的 <code>run</code> 方法，当传入Dog类的实例时也能执行Dog类的 <code>run</code> 方法，非常方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())</div><div class="line">Animal <span class="keyword">is</span> running...</div><div class="line">Animal <span class="keyword">is</span> running...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Dog())</div><div class="line">Dog <span class="keyword">is</span> running...</div><div class="line">Dog <span class="keyword">is</span> running...</div></pre></td></tr></table></figure>
<p>有了多态的特性：</p>
<ol>
<li>实现同样的功能时，不需要为每个子类都在外部重写一个函数</li>
<li>只要一个外部函数能<strong>接收父类实例作参数，则任何子类实例都能直接使用这个外部函数</strong></li>
<li>传入的任意子类实例在调用方法时，调用的都是子类中定义的方法（如果子类没有定义的话就调用父类的）</li>
</ol>
<hr>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>所谓开闭原则，指的是<strong>对扩展开放</strong>：允许新增 <code>Animal</code> 类的子类；<strong>对修改封闭</strong>：父类 <code>Animal</code> 可以调用的外部函数其子类也能直接调用，不需要对外部函数进行修改。</p>
<p>多态真正的威力：<strong>调用方只需要关注调用函数的对象，不需要关注所调用的函数内部的细节</strong>。当我们新增一种Animal的子类时，只要确保子类的 <code>run()</code> 方法编写正确即可，无须修改要调用的函数。对任意一个对象，我们<strong>只需要知道它属于父类类型，无需确切知道它的子类类型具体是什么</strong>，就可以放心地调用外部函数，而函数内部调用的方法是属于Animal类、Dog类、还是Cat类，<strong>由运行时该对象的确切类型决定</strong>。</p>
<hr>
<h3 id="静态语言-VS-动态语言"><a href="#静态语言-VS-动态语言" class="headerlink" title="静态语言 VS 动态语言"></a>静态语言 VS 动态语言</h3><p>对于静态语言(如：Java)，如果函数需要传入 <code>Animal</code> 类型，则传入的参数必须是 <code>Animal</code> 类型或者它的子类类型，否则无法调用 <code>run()</code> 方法。</p>
<p>对于动态语言而言，则不一定要传入Animal类型。<strong>只要保证传入的对象有 <code>run()</code> 方法就可以了</strong>。 这个特性又称”<strong>鸭子类型</strong>“，即一个对象只需要 “看起来像鸭子，能像鸭子那样走” 就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Start...'</span>)</div></pre></td></tr></table></figure>
<p>比方说这里的Timer类既不属于Animal类型也不继承自Animal类，但它的实例依然可以传入 <code>run_twice()</code> 函数并且执行自己的 <code>run()</code> 方法。</p>
<p>Python的 <code>file-like object</code> 就是一种鸭子类型。真正的文件对象有一个 <code>read()</code> 方法，能返回其内容。 但是只要一个类中定义有 <code>read()</code> 方法，它的实例就可以被视为 <code>file-like object</code>。许多函数接收的参数都是 <code>file-like object</code>，不一定要传入真正的文件对象，传入任何实现了 <code>read()</code> 方法的对象都可以。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>继承可以把父类的所有功能都赋予子类，这样编写子类就<strong>不必从零做起</strong>，子类只需要<strong>新增自己特有的方法，把父类不合适的方法覆盖重写</strong>就可以了。</p>
</li>
<li><p>动态语言的<strong>鸭子类型</strong>特点决定了<strong>继承不像静态语言那样是必须的</strong>。</p>
</li>
</ul>
<hr>
<p><br></p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>这一小节主要介绍给定一个对象，如何了解对象的类型以及有哪些方法。</p>
<h3 id="type函数"><a href="#type函数" class="headerlink" title="type函数"></a>type函数</h3><p>使用type函数获得各种变量的类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type('str')</div><div class="line">&lt;class 'str'&gt;</div><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;type(None) 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; type(abs)</div><div class="line">&lt;class 'builtin_function_or_method'&gt;</div><div class="line">&gt;&gt;&gt; animal = Animal()</div><div class="line">&gt;&gt;&gt; type(animal)</div><div class="line">&lt;class '__main__.Animal'&gt;</div><div class="line">&gt;&gt;&gt; dog =  Dog()</div><div class="line">&gt;&gt;&gt; type(dog)</div><div class="line">&lt;class '__main__.Dog'&gt;</div></pre></td></tr></table></figure>
<p><code>type()</code> 函数返回值是参数所属的类型，而这个返回值本身则属于type类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(type(<span class="string">'123'</span>))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>可以用来进行类型判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'123'</span>)==str</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'123'</span>) == type(<span class="number">123</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>导入内建的 <code>types</code> 模块还可以做更多更强大的类型判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn)==types.FunctionType         <span class="comment"># 判断变量是否函数</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType <span class="comment"># 判断变量是否内建函数</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x: x)==types.LambdaType  <span class="comment"># 判断变量是否匿名函数</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType <span class="comment"># 判断变量是否生成器</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="isinstance函数"><a href="#isinstance函数" class="headerlink" title="isinstance函数"></a>isinstance函数</h3><p>判断类型除了使用 <code>type()</code> 函数之外，使用 <code>isinstance()</code> 函数也能达到一样的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'a'</span>, str)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">b'a'</span>, bytes)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>并且 <code>isinstance()</code> 函数的参数二还可以是一个tuple，此时 <code>isinstance()</code> 函数将<strong>判断参数一是否属于参数二tuple中所有类型中的其中一种，只要符合其中一种则返回 <code>True</code></strong>。</p>
<p>对于类的继承关系来说，<code>type()</code> 函数不太合适，因为我们没办法知道一个子类是否属于继承自某个类，使用 <code>isinstance()</code> 函数就可以解决这个问题了。<strong>子类的实例也是父类的实例</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>animal = Animal()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog =  Dog()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(animal, Animal)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(animal, Dog) <span class="comment"># 父类实例不是子类实例</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(dog, Animal) <span class="comment"># 子类实例同时也是父类的实例</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(dog, Dog)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="dir函数"><a href="#dir函数" class="headerlink" title="dir函数"></a>dir函数</h3><p><code>dir()</code> 函数<strong>返回一个对象的所有属性和方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</div><div class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>,</div><div class="line"><span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>,</div><div class="line"><span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>,</div><div class="line"><span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>,</div><div class="line"><span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>, <span class="string">'center'</span>, <span class="string">'count'</span>, <span class="string">'encode'</span>, <span class="string">'endswith'</span>, <span class="string">'expandtabs'</span>,</div><div class="line"><span class="string">'find'</span>, <span class="string">'format'</span>, <span class="string">'format_map'</span>, <span class="string">'index'</span>, <span class="string">'isalnum'</span>, <span class="string">'isalpha'</span>, <span class="string">'isdecimal'</span>, <span class="string">'isdigit'</span>, <span class="string">'isidentifier'</span>,</div><div class="line"><span class="string">'islower'</span>, <span class="string">'isnumeric'</span>, <span class="string">'isprintable'</span>, <span class="string">'isspace'</span>, <span class="string">'istitle'</span>, <span class="string">'isupper'</span>, <span class="string">'join'</span>, <span class="string">'ljust'</span>, <span class="string">'lower'</span>,</div><div class="line"><span class="string">'lstrip'</span>, <span class="string">'maketrans'</span>, <span class="string">'partition'</span>, <span class="string">'replace'</span>, <span class="string">'rfind'</span>, <span class="string">'rindex'</span>, <span class="string">'rjust'</span>, <span class="string">'rpartition'</span>, <span class="string">'rsplit'</span>,</div><div class="line"><span class="string">'rstrip'</span>, <span class="string">'split'</span>, <span class="string">'splitlines'</span>, <span class="string">'startswith'</span>, <span class="string">'strip'</span>, <span class="string">'swapcase'</span>, <span class="string">'title'</span>, <span class="string">'translate'</span>, <span class="string">'upper'</span>,</div><div class="line"><span class="string">'zfill'</span>]</div></pre></td></tr></table></figure>
<p>形如 <code>__xxx__</code> 的属性和方法都是有特殊用途的，比如 <code>__len__</code> 方法会返回对象长度，不过我们一般直接调用内建函数 <code>len()</code> 获取一个对象的长度。而事实上，<code>len()</code> 函数内部就是通过调用对象的 <code>__len__()</code> 方法来获取长度的。两种写法都可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.__len__()</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>如果自己写的类希望能用 <code>len()</code> 函数获取对象的长度，可以在定义类时实现一个 <code>__len__()</code> 方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyDog</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">100</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dog = MyDog()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(dog)</div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="hasattr函数、setattr函数、getattr函数"><a href="#hasattr函数、setattr函数、getattr函数" class="headerlink" title="hasattr函数、setattr函数、getattr函数"></a>hasattr函数、setattr函数、getattr函数</h3><p>首先定义一个类，并创建一个该类的实例 <code>obj</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        self.x = <span class="number">9</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.x * self.x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure>
<p>利用 <code>hasattr()</code> 函数、<code>setattr()</code> 函数、<code>getattr()</code> 函数可以分别实现<strong>判断属性/方法是否存在</strong>，<strong>绑定/赋值属性/方法</strong>，以及<strong>获取属性值/方法</strong>的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>)     <span class="comment"># 有属性x吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x                 <span class="comment"># 直接访问属性x</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'x'</span>, <span class="number">10</span>) <span class="comment"># 为属性x设置新的值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x                 <span class="comment"># 直接访问属性x</span></div><div class="line"><span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>)     <span class="comment"># 有属性y吗？</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 绑定一个新属性y</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>)     <span class="comment"># 有属性y吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y                 <span class="comment"># 直接访问属性y</span></div><div class="line"><span class="number">19</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>)     <span class="comment"># 获取属性y</span></div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure>
<p>如果试图获取不存在的属性，会抛出 <code>AttributeError</code> 的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.z             <span class="comment"># 直接访问属性z</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'z'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>) <span class="comment"># 获取属性z</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'z'</span></div></pre></td></tr></table></figure>
<p>特别地，我们可以<strong>为 <code>getattr()</code> 函数传入一个额外参数表示默认值</strong>，这样<strong>当属性不存在时就会返回默认值</strong>，而不是抛出错误了，但要注意，<strong>getattr()` 并不会把这个默认值绑定到对象</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性z，如果不存在，返回默认值404</span></div><div class="line"><span class="number">404</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.z                  <span class="comment"># 没有进行绑定，所以obj仍然没有属性z</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'z'</span></div></pre></td></tr></table></figure>
<p><code>getattr()</code> 函数除了可以获取属性之外，也可以用来获取方法并且赋值到变量，然后再通过变量使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取方法 power() 并赋值给变量fn</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn                         <span class="comment"># fn指向obj.power</span></div><div class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn()                       <span class="comment"># 调用fn</span></div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.power()                <span class="comment"># 结果和调用obj.power是一样的</span></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure>
<p>看到这里也许有一些疑问，为什么我们明明可以通过 <code>obj.x = 10</code> 的方式设置属性值，还要用 <code>setattr(obj, &#39;x&#39;, 10)</code> 呢？ 为什么我们明明可以通过 <code>obj.y</code> 直接访问属性值，还要用 <code>getattr(obj, &#39;x&#39;)</code> 呢？显然后者的写法要繁琐得多。确实，前面举得例子中，我们都没有任何必要这样写，也不应该这样写。<code>setattr()</code> 函数和 <code>getattr()</code> 函数是为了一些更特别的情况而创造的，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>attrname = <span class="string">'x'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, attrname)</div><div class="line"><span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.attrname</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'attrname'</span></div></pre></td></tr></table></figure>
<p>当<strong>属性名绑定在一个变量上</strong>时，显然直接访问就没有办法使用了，但 <code>getattr()</code> 函数则不存在这方面的问题。并且前面也提到了 <code>getattr()</code> 函数允许我们<strong>设置默认返回值</strong>，这时直接访问无法做到的。又例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>attr = &#123;<span class="string">'x'</span>:<span class="number">9</span>, <span class="string">'y'</span>:<span class="number">19</span>, <span class="string">'z'</span>:<span class="number">29</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>attr.items()</div><div class="line">dict_items([(<span class="string">'y'</span>, <span class="number">19</span>), (<span class="string">'z'</span>, <span class="number">29</span>), (<span class="string">'x'</span>, <span class="number">9</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k,v <span class="keyword">in</span> attr.items():</div><div class="line"><span class="meta">... </span>    setattr(obj, k, v)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> attr.keys():</div><div class="line"><span class="meta">... </span>    getattr(obj, k)</div><div class="line">...</div><div class="line"><span class="number">19</span></div><div class="line"><span class="number">29</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>我们可以非常方便地把属性名和属性值存储在一个dict里面，然后利用循环进行赋值，而无需显式地写出 <code>obj.x = 9</code>，<code>obj.y = 19</code>，和 <code>obj.z = 29</code>，当我们需要批量赋值大量属性时，好处就体现出来了。同样地，我们也可以利用循环来读取需要的每个属性的值，而无需显式地逐个属性进行访问。</p>
<p>当然，如果可以直接写 <code>sum = obj.x + obj.y</code> 就不要写： <code>sum = getattr(obj, &#39;x&#39;) + getattr(obj, &#39;y&#39;)</code>，属性少的时候完全没有必要给自己添麻烦，对编写和阅读代码都不友好。</p>
<p>最后举个使用 <code>hasattr()</code> 函数的例子，比方说读取对象fp，我们可以首先判断fp是否有 <code>read()</code> 方法，有则进行读取，无则直接返回空值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readSomething</span><span class="params">(fp)</span>:</span></div><div class="line">    <span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</div><div class="line">        <span class="keyword">return</span> readData(fp)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p>
<p>要给实例绑定属性除了通过实例变量之外，也可以通过self变量来完成绑定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name <span class="comment"># 通过self变量绑定属性</span></div><div class="line"></div><div class="line">s = Student(<span class="string">'Bob'</span>)</div><div class="line">s.score = <span class="number">90</span>             <span class="comment"># 通过实例变量绑定属性</span></div></pre></td></tr></table></figure>
<p>但是，如果Student类本身需要绑定一个属性呢？可以直接在类中定义属性，这种属性是<strong>类属性</strong>，归Student类所有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    name = <span class="string">'Student'</span></div></pre></td></tr></table></figure>
<p>当我们定义了一个类属性后，这个<strong>类属性虽然归类所有，但类的所有实例都可以访问到</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    name = <span class="string">'Student'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()       <span class="comment"># 创建实例s</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)       <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 打印类的name属性</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span>  <span class="comment"># 给实例绑定name属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)       <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class="line">Michael</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name          <span class="comment"># 删除实例的name属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)       <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class="line">Student</div></pre></td></tr></table></figure>
<p>从上面的例子可以看出，在编写程序的时候，千万不要给实例属性和类属性设置相同的名字，因为<strong>相同名称的实例属性将屏蔽掉类属性</strong>。但是删除实例属性后，再使用相同的名称进行访问，返回的就会变回类属性了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-05模块]]></title>
      <url>http://2wildkids.com/2016/11/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#使用模块的几个好处">使用模块的几个好处</a></li>
<li><a href="#模块名和包名">模块名和包名</a></li>
<li><a href="#使用模块">使用模块</a><ul>
<li><a href="#例子解析">例子解析</a></li>
<li><a href="#命名规范和作用域">命名规范和作用域</a></li>
</ul>
</li>
<li><a href="#安装第三方库">安装第三方库</a></li>
<li><a href="#模块搜索路径">模块搜索路径</a></li>
<li><a href="#文件搜索路径">文件搜索路径</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>在开发过程中，一个文件里代码越长就越不容易维护。</p>
<p>为了编写易于维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。</p>
<p>在Python中，<strong>一个.py文件就称之为一个模块（Module）</strong>。</p>
<h2 id="使用模块的几个好处"><a href="#使用模块的几个好处" class="headerlink" title="使用模块的几个好处"></a>使用模块的几个好处</h2><ul>
<li>大大提高了代码的可维护性。</li>
<li>编写代码不必从零开始。当一个模块编写完毕，就可以被其他模块引用。</li>
<li>避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。 但还是要注意<strong>变量名尽量不要与BIF（built-in functions，内建函数）名字冲突</strong>。</li>
</ul>
<hr>
<p><br></p>
<h2 id="模块名和包名"><a href="#模块名和包名" class="headerlink" title="模块名和包名"></a>模块名和包名</h2><p>由于不同的人编写的模块名可能会相同，为了<strong>避免模块名冲突</strong>，Python又引入了<strong>按目录来组织模块</strong>的方法，称为<strong>包（Package）</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_Module0.png" alt="图片"></p>
<p>假设图中abc和xyz两个模块的名字和外面其他模块名字冲突了，我们可以通过包来组织模块，避免冲突。 只要<strong>顶层包名(也即这里的mycompany文件夹)不同即可</strong>。</p>
<p>此时abc的<strong>模块名</strong>变为 <code>mycompany.abc</code>, xyz的<strong>模块名</strong>变为 <code>mycompany.xyz</code>。</p>
<p><strong>Notice</strong>：</p>
<ul>
<li><p><strong>注意区分模块和模块名</strong>！两者不一定相同！（比如上面的模块 <code>abc</code> 和它的模块名 <code>mycompany.abc</code>）</p>
</li>
<li><p><strong>每个包目录下都必须有一个 <code>__init__.py</code> 文件</strong>，否则Python就不会把这个文件夹当作一个包。  <code>__init__.py</code>可以是空文件，也可以有Python代码，它本身就是一个模块，并且<strong>它的模块名就是包名</strong>(这里是 <code>mycompany</code>)。</p>
</li>
</ul>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_Module1.png" alt="图片"></p>
<p><strong>包结构可以是多级的</strong>。比方说这里www.py的<strong>模块名</strong>就是 <code>mycompany.web.www</code> 。 两个utils.py的模块名分别是 <code>mycompany.utils</code> 和 <code>mycompany.web.utils</code>，它们不会冲突 。 <code>mycompany.web</code> 这个模块名对应的就是web目录下的 <code>__init__.py</code> 模块。</p>
<p><strong>Notice</strong>:</p>
<p>自己创建的模块的模块名<strong>不要和Python自带的模块的模块名冲突</strong>！ 比如系统自带sys模块，自己的模块就不要命名sys.py，否则无法会无法正确import自带的sys模块。</p>
<hr>
<p><br></p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身就内置了很多模块可以直接import使用。 下面我们自己编写一个Hello模块作为例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">'This is the docstring(document comment) of this module '</span></div><div class="line"></div><div class="line">__author__ = <span class="string">'Lincoln Deng'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    args = sys.argv</div><div class="line">    <span class="keyword">if</span> len(args)==<span class="number">1</span>:</div><div class="line">        print(<span class="string">'No argument is passed.'</span>)</div><div class="line">    <span class="keyword">elif</span> len(args)==<span class="number">2</span>:</div><div class="line">        print(<span class="string">'Hello, %s!'</span> % args[<span class="number">1</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Too many arguments!'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    test()</div></pre></td></tr></table></figure>
<h3 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h3><h4 id="Python模块的标准文件模板"><a href="#Python模块的标准文件模板" class="headerlink" title="Python模块的标准文件模板"></a>Python模块的标准文件模板</h4><p>文件的第1行和第2行是<strong>标准注释</strong>：</p>
<ul>
<li><p>第1行注释是用于<strong>声明使用什么程序来执行这个脚本</strong>，它可以<strong>使得这个脚本能在Unix/Linux/Mac上直接运行</strong>（也即<strong>可以使用 <code>./Hello.py</code> 的形式执行</strong>而不是 <code>python Hello.py</code> 的形式）。如果系统装了多个版本的python，<code>#!/usr/bin/env python3</code> 会保证调用环境变量 <code>$PATH</code> 中的第一个叫python3的程序来执行脚本。又因为在一些系统中python能被重定向到python3，也即默认使用python3，所以直接用 <code>#!/usr/bin/env python</code> 也是可以的。还有一种写法是 <code>#!/usr/bin/python</code>，这样写就是指定一个路径，兼容性不如使用env的写法好。注意，如果我们使用 <code>python Hello.py</code> 或者 <code>python3 Hello.py</code> 的方式<strong>直接指定解释器来执行的话，这句注释就没用了</strong>。另外，在Windows下<strong>这句注释也是被忽略的</strong>，但<strong>为了代码的兼容性最好还是写上</strong>。</p>
</li>
<li><p>第2行注释表示（解释器和编辑器）<strong>应使用UTF-8编码来读取这个.py脚本文件中的代码文本</strong>。<strong>在Python2中，默认源代码编码方式为ASCII</strong>，要用到中文就得采用很别扭的escape写法，直接写中文会出错。后来有了<a href="https://www.python.org/dev/peps/pep-0263/" target="_blank" rel="external">PEP 0263标准</a>，规定了<strong>显式声明代码文本编码</strong>的方法。一般有三种格式，包括：能被大部分编辑器识别的 <code># -*- coding: utf-8 -*-</code>，最简单的 <code># coding=utf-8</code> 以及vim的 <code># vim: set fileencoding=utf-8</code> （其实还可以写成别的方式，主要看编辑器怎样正则匹配这一行）。当然这里的utf-8可以换为其他编码。注意<strong>编码声明必须放在代码文件的第一行或第二行</strong>。另外，这里只是<strong>声明读取时采用的编码方式，保存代码时用什么方式要自己设置编辑器</strong>。实测由于<strong>Python3默认用utf-8编码</strong>，所以只要我们正确使用utf-8编码保存代码文件，那么读取时不声明也没关系。当然，<strong>为了代码的兼容性最好还是写上</strong>。</p>
</li>
</ul>
<p>文件的第4行是一个字符串，表示模块的文档注释，<strong>任何模块的第一个字符串都被视为模块的文档注释；</strong></p>
<p>文件的第6行使用 <code>__author__</code> 变量记录模块作者的名字。</p>
<p>以上就是<strong>Python模块的标准文件模板</strong>，在Windows下使用Python3时，其实不写也没关系，但养成良好的书写习惯更好。</p>
<h4 id="正式代码部分"><a href="#正式代码部分" class="headerlink" title="正式代码部分"></a>正式代码部分</h4><p>1) <strong>导入sys模块</strong></p>
<p>如果想使用Python内置的sys模块，就要先导入该模块： <code>import sys</code>。 导入之后，相当于<strong>创建了一个变量<code>sys</code>，该变量指向sys模块，通过这个变量可以访问sys模块的全部功能</strong>。</p>
<p>2) <strong>使用argv变量获取参数列表</strong></p>
<p><strong>sys模块有一个 <code>argv</code> 变量</strong>，这个变量属于list类型，存储着<strong>命令行的所有参数</strong>（即我们在命令行执行该脚本时使用的参数）。<code>argv</code> 列表中至少包含一个元素，因为<strong>第一个参数永远是该脚本文件的名称</strong>，例如：</p>
<p>在命令行执行 <code>python3 Hello.py</code> 获得的 <code>sys.argv</code> 就是 <code>[&#39;Hello.py&#39;]</code>；</p>
<p>在命令行执行 <code>python3 Hello.py Michael</code> 获得的 <code>sys.argv</code> 就是 <code>[&#39;Hello.py&#39;, &#39;Michael]</code>。 要获取字符串 <code>&#39;Michael&#39;</code> 只需要调用 <code>sys.argv[1]</code>。</p>
<p>3) <strong>条件判断</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    test()</div></pre></td></tr></table></figure>
<p>在Hello模块中我们定义了一个test函数，这个条件判断的意思就是，如果程序执行到这里，<code>__name__</code> 变量的值是 <code>&#39;__main__&#39;</code> 的话就执行 <code>test</code> 函数。</p>
<p>其中 <code>__name__</code> 变量是个特殊变量，当我们<strong>在命令行执行</strong>Hello.py时，Python解释器就会把 <code>__name__</code> 变量赋值为 <code>__main__</code>。</p>
<p>但<strong>如果在别的文件中导入模块，<code>__name__</code> 的值就是模块的名字</strong>而非 <code>__main__</code>，此时if判断结果为 <code>False</code>。 借助这个特性，我们可以<strong>在if判断中编写一些额外的代码</strong>，用于测试模块的功能，而在使用（导入）模块时，if判断里的代码不会被执行。</p>
<h4 id="在命令行下执行"><a href="#在命令行下执行" class="headerlink" title="在命令行下执行"></a>在命令行下执行</h4><p>保存代码文件后，打开命令行，先把路径切换到保存 <code>Hello.py</code> 的目录，然后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python Hello.py</div><div class="line">No argument is passed.</div><div class="line"></div><div class="line">C:\Users\Administrator\Desktop&gt;python Hello.py Lincoln</div><div class="line">Hello, Lincoln!</div></pre></td></tr></table></figure>
<h4 id="在交互环境下执行"><a href="#在交互环境下执行" class="headerlink" title="在交互环境下执行"></a>在交互环境下执行</h4><p>比方说使用IDLE或者在命令行中输入python进入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop&gt;python</div><div class="line">Python <span class="number">3.5</span><span class="number">.1</span> |Anaconda <span class="number">4.0</span><span class="number">.0</span> (<span class="number">64</span>-bit)| (default, Feb <span class="number">16</span> <span class="number">2016</span>, <span class="number">09</span>:<span class="number">49</span>:<span class="number">46</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> Hello</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.__name__</div><div class="line"><span class="string">'Hello'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.test()</div><div class="line">No argument <span class="keyword">is</span> passed.</div></pre></td></tr></table></figure>
<p>导入Hello模块时，它的 <code>__name__</code> 变量会被赋值为模块名 <code>Hello</code>，而不是 <code>__main__</code>，所以if判断为 <code>False</code>，if判断里的代码不会被执行。如果要使用 <code>test</code> 函数，就要通过 <code>模块名.函数名</code> 的方式进行调用，使用模块内的其他变量/函数同理。</p>
<hr>
<h3 id="命名规范和作用域"><a href="#命名规范和作用域" class="headerlink" title="命名规范和作用域"></a>命名规范和作用域</h3><p>在模块中我们会定义很多函数和变量，有些是希望给别人用的，有些则希望仅仅在模块内部使用。</p>
<h4 id="公开-public-的变量和函数"><a href="#公开-public-的变量和函数" class="headerlink" title="公开(public)的变量和函数"></a>公开(public)的变量和函数</h4><p>命名格式如： <code>abc</code>，<code>x123</code>，<code>PI</code>， 如果是有特殊用途则<strong>在名称前后各加上两个下划线</strong>，如：<code>__author__</code>，<code>__name__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.__doc__</div><div class="line"><span class="string">'This is the docstring(document comment) of this module '</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.__name__</div><div class="line"><span class="string">'Hello'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.__author__</div><div class="line"><span class="string">'Lincoln Deng'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Hello.__file__</div><div class="line"><span class="string">'C:\\Users\\Administrator\\Desktop\\Hello.py'</span></div></pre></td></tr></table></figure>
<p>可以看到 <code>__doc__</code> 变量返回了我们前面模块例子的代码中第一个字符串，也即<strong>文档注释(DocString)</strong>。什么是文档注释呢？其实就是一个<strong>模块/类/函数/方法的定义中第一个声明的字符串</strong>，使用这些对象的 <code>.doc</code> 属性即可访问。关于文档注释的书写标准可以查看<a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="external">PEP 0257</a>。</p>
<h4 id="私有-private-的变量和函数"><a href="#私有-private-的变量和函数" class="headerlink" title="私有(private)的变量和函数"></a>私有(private)的变量和函数</h4><p>命名格式是在<strong>名称前加一个或两个下划线</strong>，如 <code>_xxx</code> 和 <code>__xxx</code>。这样的函数或变量<strong>不应该被外部直接引用(即通过 <code>模块名.变量名</code> 的方式调用)</strong>。比方说下面定义的 <code>_private_1</code> 函数和 <code>_private_2</code> 函数，我们不希望使用这个模块的人调用它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_1</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, %s'</span> % name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_2</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hi, %s'</span> % name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(name) &gt; <span class="number">3</span>:</div><div class="line">        <span class="keyword">return</span> _private_1(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> _private_2(name)</div></pre></td></tr></table></figure>
<p>虽然不希望用户调用私有函数，但我们<strong>可以暴露给用户一个接口（公开的函数）</strong>，也即这里的 <code>greeting</code> 函数，把调用两个私有函数的代码和逻辑封装在里面，用户直接调用 <code>greeting</code> 函数，然后让 <code>greeting</code> 函数决定怎样调用私有函数。</p>
<p>当用户使用模块时不需要关心私有的变量和函数，直接使用公开的变量和函数就可以了。 这是一种常用的<strong>代码封装和抽象</strong>的方法。</p>
<p><strong>注意：</strong></p>
<p>这里说私有函数和变量 <strong>不应该被直接引用</strong>，而不是 <strong>不能被直接引用</strong>。 因为Python没有方法可以限制用户调用私有函数和变量（没有），所以这样命名<strong>只是一种约定的编程习惯</strong>，使用者怎么做就要看他自己怎么决定了。</p>
<p>良好的习惯是<strong>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public</strong>。</p>
<hr>
<p><br></p>
<h2 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h2><p>在Python中，安装第三方库（从而使用第三方库中提供的第三方模块），可以通过<strong>包管理工具pip</strong>（也有其他的包管理工具）完成。</p>
<p>安装Python时选择了安装pip的话，就可以直接在命令行中使用pip工具了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Pillow</div></pre></td></tr></table></figure>
<p>在命令行键入 <code>pip install 第三方库的库名</code> 后， pip就会自动帮用户下载并安装第三方库。</p>
<p><img src="http://imglf0.nosdn.127.net/img/dnpRZUpJZlB5VUQ2UTdlUDluSm9RZEZVQ0hEMjZrWjJReENQRmwvNVp4U0tnN3VUV004RE1BPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt="安装1"></p>
<p><img src="http://imglf2.nosdn.127.net/img/dnpRZUpJZlB5VUQ2UTdlUDluSm9RZU9hUFRtT0dMaFRWTENkaW1SREVrN25rd3VXSlVBKy9nPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt="安装2"></p>
<p>这里安装的是<strong>Python Imaging Library</strong>这个第三方库，是一个Python下非常强大的图像处理工具库。 因为PIL只支持到Python2.7，所以这里用的是基于PIL开发的支持Python3的<strong>Pillow</strong>。</p>
<p>安装完成后打开 <code>F:\Python35\Lib\site-packages</code> 文件夹（具体路径看安装Python的位置而定）就会发现多了两个文件夹，一个是 <code>Pillow-3.1.1.dist-info</code>, 另一个是 <code>PIL</code>。 前者包含该库的一些基本信息，后者就是我们需要用到的包了，里面是有 <code>__init__.py</code> 文件的。</p>
<p>安装好的包我们可以在文件中直接用 <code>from 包名 import 模块名</code> 来导入要使用的模块，而不需要先转到模块所在的目录下再导入，也不需要把模块复制到我们的工程文件夹中。</p>
<p>举一个使用Pillow包中利用Image模块生成图片缩略图的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>im = Image.open(<span class="string">'C:/Users/Administrator/Desktop/test.png'</span>) <span class="comment"># 打开指定路径下的一张照片</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.format, im.size, im.mode) <span class="comment"># 打印照片的文件格式&amp;尺寸&amp;颜色模式</span></div><div class="line">PNG (<span class="number">400</span>, <span class="number">300</span>) RGB</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>im.thumbnail((<span class="number">200</span>, <span class="number">100</span>)) <span class="comment"># 创建缩略图</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>im.save(<span class="string">'thumb.jpg'</span>, <span class="string">'JPEG'</span>) <span class="comment"># 保存缩略图</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>im.show()  <span class="comment"># 查看图片</span></div></pre></td></tr></table></figure>
<p>其他常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具Jinja2，等等。</p>
<hr>
<p><br></p>
<h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>在Python中导入模块时，Python解释器会从指定好的路径中进行搜索。我们可以使用sys模块的变量 <code>path</code> 来查看模块的搜索路径，导入模块时会从这些路径中查找.py文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator&gt;python</div><div class="line">Python <span class="number">3.5</span><span class="number">.1</span> |Anaconda <span class="number">4.0</span><span class="number">.0</span> (<span class="number">64</span>-bit)| (default, Feb <span class="number">16</span> <span class="number">2016</span>, <span class="number">09</span>:<span class="number">49</span>:<span class="number">46</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</div><div class="line">[<span class="string">''</span>, <span class="string">'F:\\Anaconda3\\python35.zip'</span>, <span class="string">'F:\\Anaconda3\\DLLs'</span>, <span class="string">'F:\\Anaconda3\\lib'</span>, <span class="string">'F:\\Anaconda3'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\Sphinx-1.3.5-py3.5.egg'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\win32'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages\\win32\\lib'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\Pythonwin'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages\\setuptools-20.3-py3.5.egg'</span>]</div></pre></td></tr></table></figure>
<p>sys模块的 <code>path</code> 变量是一个列表，它会<strong>在启动Python时被初始化</strong>，初始赋值（按顺序）由三个部分组成，一是<strong>当前目录</strong>（即列表中的空字符串），二是<strong>环境变量 <code>PYTHONPATH</code> 中的路径</strong>，三是一些<strong>默认的路径</strong>（包含内置模块和一些通过pip安装的模块）。由于我没有设置环境变量 <code>PYTHONPATH</code>，所以上面只有一和三两部分。尝试新建一个名为 <code>PYTHONPATH</code> 的环境变量，添加一条路径指向F盘，<strong>重新启动Python程序</strong>，此时就会发现 <code>path</code> 变量的初始赋值中多了F盘的路径了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator&gt;python</div><div class="line">Python <span class="number">3.5</span><span class="number">.1</span> |Anaconda <span class="number">4.0</span><span class="number">.0</span> (<span class="number">64</span>-bit)| (default, Feb <span class="number">16</span> <span class="number">2016</span>, <span class="number">09</span>:<span class="number">49</span>:<span class="number">46</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</div><div class="line">[<span class="string">''</span>, <span class="string">'F:\\'</span>, <span class="string">'F:\\Anaconda3\\python35.zip'</span>, <span class="string">'F:\\Anaconda3\\DLLs'</span>, <span class="string">'F:\\Anaconda3\\lib'</span>, <span class="string">'F:\\Anaconda3'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\Sphinx-1.3.5-py3.5.egg'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\win32'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages\\win32\\lib'</span>,</div><div class="line"><span class="string">'F:\\Anaconda3\\lib\\site-packages\\Pythonwin'</span>, <span class="string">'F:\\Anaconda3\\lib\\site-packages\\setuptools-20.3-py3.5.egg'</span>]</div></pre></td></tr></table></figure>
<p>如果需要使用自己编写的模块，可以把它们放到这些目录中。 也可以自己<strong>增加搜索路径</strong>。具体来说分为两种方法：</p>
<ul>
<li>方法一：<strong>直接使用 <code>apeend</code> 往 <code>sys.path</code> 列表添加搜索路径</strong>，这种方法<strong>只在该次运行时有效</strong>，重启Python交互环境后会恢复原来的路径：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">'C:/Users/Administrator/Desktop'</span>)</div></pre></td></tr></table></figure>
<ul>
<li>方法二：<strong>配置环境变量PYTHONPATH</strong>，只需要增加自己的搜索路径，默认的路径是不会被覆盖掉的，使用这种方法就<strong>不需要每次都修改 <code>sys.path</code> </strong>了。</li>
</ul>
<p>关于 <code>sys.path</code> 的详情可以查看<a href="https://docs.python.org/3/library/sys.html#sys.path" target="_blank" rel="external">官方文档</a>。</p>
<hr>
<p><br></p>
<h2 id="文件搜索路径"><a href="#文件搜索路径" class="headerlink" title="文件搜索路径"></a>文件搜索路径</h2><p>这一节与模块无关，但是觉得有必要区分好<strong>文件搜索路径</strong>和<strong>模块搜索路径</strong>！ 文件搜索路径是当前工作目录，如果我们不指定路径，直接使用文件名访问文件的时候，Python会从当前路径中进行查找；模块搜索路径则是像上一节提及的那样，指 <code>sys.path</code> 列表中包含的路径。</p>
<p>要获取当前工作路径可以使用os模块的 <code>getcwd</code> 函数，也即<strong>get current work directory</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</div><div class="line"><span class="string">'C:\\Users\\Administrator\\Desktop'</span></div></pre></td></tr></table></figure>
<p>要调用的文件如果放在当前工作路径上就可以直接用 <code>文件名.文件格式</code> 指定，比方说我在桌面放了一张 <code>test.jpg</code>，那么访问时直接用 <code>im = Image.open(&#39;test.jpg&#39;)</code> 就可以打开了，无须使用完整的路径，也即 <code>im = Image.open(&#39;C:/Users/Administrator/Desktop/test.jpg&#39;)</code>。</p>
<p>注意Python中<strong>路径字符串里斜杠的使用</strong>， 如果<strong>使用反斜杠划分就必须转义</strong>，也即写作双反斜杠 <code>\\</code>；如果<strong>使用左斜杠 <code>/</code> 则不需要进行转义</strong>。Python默认路径字符串都使用双反斜杠。</p>
<p>如果文件不在当前工作路径，那么我们写路径时可以有两种写法：</p>
<ul>
<li>使用<strong>绝对路径</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im = Image.open(<span class="string">'C:/Users/Administrator/Desktop/test.jpg'</span>)</div></pre></td></tr></table></figure>
<p>这里使用了左斜杠，所以不需要转义。</p>
<ul>
<li>使用<strong>相对路径</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im = Image.open(<span class="string">'./test.jpg'</span>)</div></pre></td></tr></table></figure>
<p>相对路径即相对当前工作路径而言的路径，这是为了避免路径过长而设计的，可以<strong>用 <code>.</code> 符来代替当前工作路径</strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-04函数式编程]]></title>
      <url>http://2wildkids.com/2016/11/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#函数式编程的三大特性">函数式编程的三大特性</a></li>
<li><a href="#函数式编程的几个技术">函数式编程的几个技术</a></li>
<li><a href="#函数式编程的几个好处">函数式编程的几个好处</a><ul>
<li><a href="#简单举例">简单举例</a></li>
</ul>
</li>
<li><a href="#高阶函数">高阶函数</a><ul>
<li><a href="#变量可以指向函数">变量可以指向函数</a></li>
<li><a href="#函数名也是变量">函数名也是变量</a></li>
<li><a href="#传入函数">传入函数</a></li>
<li><a href="#mapreduce">map/reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sorted">sorted</a></li>
</ul>
</li>
<li><a href="#返回函数">返回函数</a><ul>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
<li><a href="#闭包">闭包</a></li>
</ul>
</li>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#装饰器">装饰器</a><ul>
<li><a href="#带参数的decorator">带参数的decorator</a></li>
<li><a href="#属性复制">属性复制</a></li>
<li><a href="#练习">练习</a></li>
</ul>
</li>
<li><a href="#偏函数">偏函数</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p><strong>函数</strong>是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p><strong>函数式编程</strong>（请注意多了一个<strong>“式”</strong>字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其<strong>思想更接近数学计算</strong>。</p>
<p>我们首先要搞明白<strong>计算机（Computer）</strong>和<strong>计算（Compute）</strong>的概念。</p>
<ul>
<li><p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以汇编语言是最贴近计算机的语言。</p>
</li>
<li><p>计算则是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
</li>
</ul>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p><strong>归纳一下</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">低级语言</th>
<th style="text-align:center">高级语言</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">特点</td>
<td style="text-align:center">贴近计算机</td>
<td style="text-align:center">贴近计算（数学意义上）</td>
</tr>
<tr>
<td style="text-align:center">抽象程度</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">执行效率</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">例子</td>
<td style="text-align:center">汇编和C</td>
<td style="text-align:center">Lisp</td>
</tr>
</tbody>
</table>
</div>
<p>函数式编程就是一种<strong>抽象程度很高的编程范式</strong>，纯粹的函数式编程语言编写的函数<strong>没有变量</strong>，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为<strong>没有副作用</strong>。而允许使用变量的程序设计语言，由于函数内部的<strong>变量状态不确定</strong>，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数</strong>！</p>
<p>Python<strong>仅对函数式编程提供部分支持</strong>。由于Python允许使用变量，因此，<strong>Python不是纯函数式编程语言</strong>。</p>
<h2 id="函数式编程的三大特性"><a href="#函数式编程的三大特性" class="headerlink" title="函数式编程的三大特性"></a>函数式编程的三大特性</h2><ol>
<li><p><strong>immutable data</strong><br><br>变量不可变，或者说没有变量，只有常量。 函数式编程输入确定时输出就是确定的，函数内部的变量和函数外部的没有关系，不会受到外部操作的影响。</p>
</li>
<li><p><strong>first class functions</strong><br><br>第一类函数(也称高阶函数)，意思是函数可以向变量一样用，可以像变量一样创建、修改、传递和返回。 这就允许我们把大段代码拆成函数一层层地调用，这种面向过程的写法相比循环更加直观。</p>
</li>
<li><p><strong>尾递归优化</strong><br><br>之前一章的递归函数中已经提及过了，就是递归时返回函数本身而非表达式。 可惜Python中没有这个特性。</p>
</li>
</ol>
<hr>
<p><br></p>
<h2 id="函数式编程的几个技术"><a href="#函数式编程的几个技术" class="headerlink" title="函数式编程的几个技术"></a>函数式编程的几个技术</h2><ol>
<li><p><strong>map &amp; reduce</strong><br><br>函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起传统的面向过程的写法来说，在代码上要更容易阅读（不需要使用一堆for、while循环来倒腾数据，而是使用更抽象的Map函数和Reduce函数）。</p>
</li>
<li><p><strong>pipeline</strong><br><br>这个技术的意思是把函数实例成一个一个的action，然后把一组action放到一个数组或是列表中组成一个action list，然后把数据传给这个action list，数据就像通过一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。</p>
</li>
<li><p><strong>recursing</strong><br><br>递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</p>
</li>
<li><p><strong>currying</strong><br><br>把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数（减少函数的参数数目）。</p>
</li>
<li><p><strong>higher order function</strong><br><br>高阶函数：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出。</p>
</li>
</ol>
<p>对currying进行一点补充，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(i, j)</span>:</span></div><div class="line">    <span class="keyword">return</span> i**j</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> pow(i, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>这里就是把原本平方函数<code>square</code>的参数j分解了，它返回幂函数<code>pow</code>函数，把幂次封装在里面，从而减少了求平方时所需用到的参数。</p>
<p>关于函数式编程的一些概念理解可以看<a href="http://www.kancloud.cn/kancloud/functional-programm-for-rest/56931" target="_blank" rel="external">傻瓜函数式编程</a>或者英文原版的<a href="http://www.defmacro.org/ramblings/fp.html" target="_blank" rel="external">Functional Programming For The Rest of Us</a>。</p>
<hr>
<p><br></p>
<h2 id="函数式编程的几个好处"><a href="#函数式编程的几个好处" class="headerlink" title="函数式编程的几个好处"></a>函数式编程的几个好处</h2><ol>
<li><p><strong>parallelization 并行</strong><br><br>在并行环境下，各个线程之间不需要同步或互斥(变量都是内部的，不需要共享)。</p>
</li>
<li><p><strong>lazy evaluation 惰性求值</strong><br><br>表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p>
</li>
<li><p><strong>determinism 确定性</strong><br><br>输入是确定的，输出就是确定的。</p>
</li>
</ol>
<h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><p>以往面向过程式的编程需要引入额外的逻辑变量以及使用循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upname =[<span class="string">'HAO'</span>, <span class="string">'CHEN'</span>, <span class="string">'COOLSHELL'</span>]</div><div class="line">lowname =[]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(upname)):</div><div class="line">    lowname.append( upname[i].lower() )</div></pre></td></tr></table></figure>
<p>而函数式编程则非常简洁易懂：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toUpper</span><span class="params">(item)</span>:</span></div><div class="line">  <span class="keyword">return</span> item.upper()</div><div class="line"></div><div class="line">upper_name = map(toUpper, [<span class="string">"hao"</span>, <span class="string">"chen"</span>, <span class="string">"coolshell"</span>])</div><div class="line"><span class="keyword">print</span> upper_name</div></pre></td></tr></table></figure>
<p>再看一个计算一个列表中所有正数的平均数的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">num =[<span class="number">2</span>, <span class="number">-5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">-2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">8</span>]</div><div class="line">positive_num_cnt = <span class="number">0</span></div><div class="line">positive_num_sum = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</div><div class="line">    <span class="keyword">if</span> num[i] &gt; <span class="number">0</span>:</div><div class="line">        positive_num_cnt += <span class="number">1</span></div><div class="line">        positive_num_sum += num[i]</div><div class="line"></div><div class="line"><span class="keyword">if</span> positive_num_cnt &gt; <span class="number">0</span>:</div><div class="line">    average = positive_num_sum / positive_num_cnt</div><div class="line"></div><div class="line"><span class="keyword">print</span> average</div></pre></td></tr></table></figure>
<p>如果采用函数式编程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">positive_num = filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, num)</div><div class="line">average = reduce(<span class="keyword">lambda</span> x,y: x+y, positive_num) / len( positive_num )</div></pre></td></tr></table></figure>
<p>可以看到<strong>函数式编程减少了变量的使用，也就减少了出Bug的可能，维护更加方便。可读性更高，代码更简洁</strong>。</p>
<p>更多的例子和解析详见<a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">函数式编程</a>。</p>
<hr>
<p><br></p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>前面已经提到了函数式编程中的高阶函数特性，这一节将针对Python中的使用方式进行更详细的描述。</p>
<h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs</div><div class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>这个例子表明在Python中变量是可以指向函数的，并且这样赋值的变量能够作为函数的别名使用。</p>
<hr>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs = <span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</div></pre></td></tr></table></figure>
<p>这里把abs函数赋值为10，这样赋值以后abs就变成一个整形变量，指向int型对象10而不指向原本的函数了。所以无法再作为函数使用。</p>
<p>想恢复abs函数要重启Python交互环境。 abs函数定义在 <code>__builtin__</code> 模块中，要让修改abs变量的指向在其它模块也生效，用 <code>__builtin__.abs = 10</code> 就可以了。 当然<strong>实际写代码绝对不应该这样做</strong>..</p>
<hr>
<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>函数能够作为参数传递，接收这样的参数的函数就称为高阶函数。 简单举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></div><div class="line">    <span class="keyword">return</span> f(x) + f(y)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">-5</span>, <span class="number">6</span>, abs)</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>这里abs函数可以作为一个参数传入我们编写的add函数中，add函数就是一个高阶函数。</p>
<hr>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>map()函数和reduce()函数是Python的两个内建函数(BIF)。</p>
<h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><p>map()函数接收两个参数，一个是函数，一个是<strong>Iterable对象</strong>，map将传入的函数依次作用到序列的每个元素，并把结果作为<strong>Iterator对象</strong>（惰性序列，可以用list转换为列表输出）返回。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>这里直接使用list()函数将迭代器对象转换为一个列表。</p>
<p>写循环也能达到同样效果，但是显然没有map()函数直观。 map()函数作为高阶函数，大大简化了代码，更易理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</div></pre></td></tr></table></figure>
<p>将一个整数列表转换为字符列表仅仅需要一行代码。</p>
<h4 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h4><p>reduce接收两个参数，一个是函数（假设该函数称为f），一个是Iterable对象（假设是l）。函数f必须接收两个参数，reduce函数每次会把上一次函数f返回的值和l的下一个元素传入到f中，直到l中所有元素都参与过运算时返回函数f最后返回的值（第一次传入时传入l的头两个元素）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>这里举了一个最简单的序列求和作例子(当然实际上我们直接用sum()函数更方便，这里只是为了举例子)。 这里reduce函数每次将add<strong>作用于序列的前两个元素</strong>，并<strong>把结果返回序列的头部</strong>，直到序列只剩下1个元素就返回结果（这样理解可能更直观一些）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s] <span class="comment">#字符对应整数的dict，返回传入字符对应的整数</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, map(char2num, <span class="string">'13579'</span>))</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<p>可以整理一下，作为一个整体的str2int函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line">        <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</div></pre></td></tr></table></figure>
<p>使用lambda匿名函数还可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, map(char2num, s))</div></pre></td></tr></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>1.利用map()函数，把不规范的英文名字变为首字母大写其他字母小写的规范名字。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>字符串支持切片操作，并且可以用加号做字符串拼接。</li>
<li>转换大写用upper函数，转换小写用lower函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> name[<span class="number">0</span>].upper()+name[<span class="number">1</span>:].lower()</div><div class="line"></div><div class="line">L1 = [<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]</div><div class="line">L2 = list(map(normalize, L1))</div><div class="line">print(L2)</div></pre></td></tr></table></figure>
<blockquote>
<p>2.编写一个prod()函数，可以接受一个list并利用reduce()求积。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>用匿名函数做两数相乘</li>
<li>用reduce函数做归约，得到列表元素连乘之积。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">(L)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y,L)</div><div class="line"></div><div class="line">print(<span class="string">'3 * 5 * 7 * 9 ='</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))</div></pre></td></tr></table></figure>
<blockquote>
<p>3.利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.45。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>这题的思路是找到小数点的位置i(从个位开始数i个数字之后)，然后让转换出的整数除以10的i次方。</li>
<li>另外一种思路是在转换时遇到小数点后，改变转换的方式由 <code>num*10+当前数字</code> 变为 <code>num+当前数字/point</code>。 point初始为1，每次加入新数字前除以10。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pow</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chr2num</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,map(chr2num,s.replace(<span class="string">'.'</span>,<span class="string">''</span>))) / pow(<span class="number">10</span>,len(s)-s.find(<span class="string">'.'</span>)<span class="number">-1</span>)</div><div class="line"></div><div class="line">print(str2float(<span class="string">'985.64785'</span>))</div></pre></td></tr></table></figure>
<hr>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter()函数同样是内建函数，用于过滤序列。 filter()接收一个函数和一个Iterable对象。 和map()不同的时，filter()把传入的函数依次作用于每个元素，然后<strong>根据函数返回值是True还是False决定保留还是丢弃该元素</strong>。</p>
<p>简单的奇数筛选例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></div><div class="line"></div><div class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</div><div class="line"><span class="comment"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure>
<p>筛掉列表的空字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</div><div class="line"></div><div class="line">list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</div><div class="line"><span class="comment"># 结果: ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>其中，<code>strip</code> 函数用于删除字符串中特定字符，格式为：<code>s.strip(rm)</code>，删除s字符串中开头、结尾处的包含在rm删除序列中的字符。 rm为空时默认删除空白符(包括’\n’, ‘\r’,  ‘\t’,  ‘ ‘)。</p>
<p>注意到 <code>filter()</code> 函数返回的是一个 <strong>Iterator对象</strong>，也就是一个<strong>惰性序列</strong>，所以要强迫 <code>filter()</code> 完成计算结果，需要用 <code>list()</code> 函数获得所有结果并返回list。</p>
<p>filter函数最重要的一点就是正确地定义一个<strong>筛选函数</strong>（即传入filter作为参数的那个函数)。</p>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>1.用filter筛选素数</p>
</blockquote>
<p>这里使用<strong>埃氏筛法</strong>。</p>
<blockquote>
<p>首先，列出从2开始的所有自然数，构造一个序列：</p>
</blockquote>
<pre><code>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...
</code></pre><blockquote>
<p>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：</p>
</blockquote>
<pre><code>3, 5, 7, 9, 11, 13, 15, 17, 19, ...
</code></pre><blockquote>
<p>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：</p>
</blockquote>
<pre><code>5, 7, 11, 13, 17, 19, ...
</code></pre><blockquote>
<p>以此类推…</p>
</blockquote>
<p>首先构造一个生成器，输出3开始的奇数序列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></div><div class="line">    n = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = n + <span class="number">2</span></div><div class="line">        <span class="keyword">yield</span> n</div></pre></td></tr></table></figure>
<p>然后定义一个筛选函数，传入n，判断x能否除尽n：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里x是匿名函数的参数，<strong>由外部提供</strong>。</p>
<p>然后就是定义返回素数的生成器了。</p>
<ul>
<li><p>首先输出素数2，然后初始化奇数队列，每次输出队首(必然是素数，因为前一轮的过滤已经排除了比当前队首小且非素数的数)。</p>
</li>
<li><p>构造新的队列，每次用当前序列最小的数作为除数，检验后面的数是否素数。</p>
</li>
</ul>
<p>定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span></div><div class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></div><div class="line">        <span class="keyword">yield</span> n</div><div class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></div></pre></td></tr></table></figure>
<p>这里因为it是一个迭代器，每次使用next就得到队列的下一个元素，实际上就类似队列的出列操作，挤掉队首，不用担心重复。</p>
<p>然后这里filter的原理，就是把当前it队列的每个数都放进_not_divisible(n)中检测一下，注意<strong>不是作为参数n传入而是作为匿名函数的参数x传入</strong>！</p>
<p><code>_not_divisible(n)</code> 实际是<strong>作为一个整体来看</strong>的，它返回一个<strong>自带参数n的函数</strong>(也即那个匿名函数)，然后filter再把列表每一个元素一一传返回的匿名函数中。一定要搞清楚这一点。</p>
<ul>
<li>最后，因为primes产生的也是一个无限长的惰性序列，我们一般不需要求那么多，简单写个循环用作退出即可：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打印1000以内的素数:</span></div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</div><div class="line">        print(n)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>2.用filter筛选回文数</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>str可以把整数转换为字符串</li>
<li>[::-1]可以得到逆序的列表。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> str(n) == str(n)[::<span class="number">-1</span>]</div><div class="line"></div><div class="line">print(list(filter(is_palindrome, range(<span class="number">0</span>,<span class="number">1001</span>))))</div></pre></td></tr></table></figure>
<hr>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>Python内置的 <code>sorted()</code> 函数就可以对list进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>])</div><div class="line">[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure>
<p>并且 <code>sorted()</code> 作为<strong>高阶函数</strong>还允许接受一个key函数用于自定义排序，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure>
<p>key指定的函数将作用于list的每一个元素上，并<strong>根据key函数返回(映射)的结果进行排序</strong>，最后<strong>对应回列表中的元素</strong>进行输出。</p>
<p>再看一个字符串排序例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</div><div class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</div></pre></td></tr></table></figure>
<p>默认情况下是按ASCII码排序的，但我们往往希望按照字典序来排，思路就是把字符串变为全小写/全大写再排：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</div><div class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</div></pre></td></tr></table></figure>
<p>默认排序是由小到大，要反相排序只需把reverse参数设为True。 温习前面的知识，这里reverse参数是一个<strong>命名关键字参数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</div><div class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</div></pre></td></tr></table></figure>
<p>使用好sorted函数的关键就是定义好一个映射函数。</p>
<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>给出成绩表，分别按姓名和成绩进行排序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = sorted(L, key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])    <span class="comment">#按姓名排序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2</div><div class="line">[(<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L3 = sorted(L, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])    <span class="comment">#按成绩排序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L3</div><div class="line">[(<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>)]</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>比方说我们想实现一个对可变参数求和的函数，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(*args)</span>:</span></div><div class="line">    ax = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line">        ax = ax + n</div><div class="line">    <span class="keyword">return</span> ax</div></pre></td></tr></table></figure>
<p>调用时可以传入任意个数字，并得到这些数字的和。而如果我们不需要立即求和，而是后面再根据需要来进行求和，可以写为返回求和函数的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></div><div class="line">        ax = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line">            ax = ax + n</div><div class="line">        <span class="keyword">return</span> ax</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>在调用 <code>lazy_sum</code> 时，返回一个sum函数，但sum函数内部的求和代码没有执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</div></pre></td></tr></table></figure>
<p>当我们再调用返回的这个sum函数时，就能得到和值了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f()</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>注意！每一次调用 <code>lazy_sum</code> 返回的函数都是不同的！<strong>即使传入相同的参数，返回函数也是不同的</strong>！举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1==f2</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>f1和f2是不同的两个函数，虽然调用它们得到同样的结果，但它们是互不影响的。</p>
<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在Python中，从表现形式上来讲，闭包可以定义为：如果在一个内部函数里，对外部作用域（<strong>非全局作用域</strong>）的变量进行了引用，那么这个<strong>内部函数就被认为是闭包</strong>(closure)。 如上面例子中的f就是一个闭包，它调用了变量i，变量i属于外面的循环体而不是全局变量。</p>
<p>看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">             <span class="keyword">return</span> i*i</div><div class="line">        fs.append(f)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count()</div></pre></td></tr></table></figure>
<p>三个返回函数的调用结果是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>解析一下，这里count函数是一个返回三个函数的函数，里面使用了一个循环体来产生要返回的三个函数。从i为1开始到i等于3，每次产生一个函数f，返回i的平方值。如果按照平常的思路来看，可能会觉得返回的三个函数f1、f2、f3应该分别输出1、4、9。</p>
<p>但实际上并不是这样的，这是因为<strong>返回一个函数时，函数内部的代码是没有执行的！ 只有在调用这个返回的函数时才会执行</strong>！</p>
<p>调用count函数时，实际上返回了3个新的函数，循环变量i的值也变为3。在调用这3个返回的函数时，它们的代码才会执行，这时引用的i的值就都是3。</p>
<p>如果一定要在闭包中用到外部的循环变量，要怎么办呢？ 我们先定义一个函数，<strong>用它的参数绑定循环变量</strong>，然后再在它的里面定义要返回的函数。 这样无论后面循环变量怎么变，<strong>已经绑定到参数的值是不会变</strong>的，就能得到我们期望的结果了。也即把上面的例子改写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">return</span> j*j</div><div class="line">        <span class="keyword">return</span> g</div><div class="line"></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span></div><div class="line">    <span class="keyword">return</span> fs</div></pre></td></tr></table></figure>
<p>调用结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>这里闭包g用到的变量j是<strong>外部作用域f</strong>的，并且<strong>j作为参数绑定在f中不再改变</strong>，不同于外部作用域count函数中的变量i。 所以执行count返回的3个函数，每个的结果都不同。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>返回闭包时，<strong>不要在闭包的代码中引用外部作用域的循环变量或者外部作用域中会变化的变量</strong>。</p>
</li>
<li><p><strong>不应该在闭包中修改外部作用域的局部变量</strong>。</p>
</li>
</ul>
<hr>
<p><br></p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>当我们在使用函数作为参数时，有些时候，<strong>不需要预先显式地定义函数</strong>，直接传入一个匿名函数更方便。</p>
<p>举个简单例子，计算 <code>f(x)=x²</code> 时，不需要显示定义f(x)，使用匿名函数可以直接一行解决，这样写非常简洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p><strong>关键字lambda</strong>表示要定义一个匿名函数，<strong>冒号前面</strong>的x表示函数的参数。</p>
<p>匿名函数有个限制，就是<strong>只能包含一个表达式</strong>，不用写return，<strong>返回值就是该表达式的结果</strong>。</p>
<p>所以上面这个匿名函数就是：x作为参数传入，返回 <code>x*x</code> 的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，<strong>不必担心函数名冲突</strong>。此外，匿名函数也是一个<strong>函数对象</strong>，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>并且匿名函数作为一个函数对象，也能被函数返回(像上一节那样)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</div></pre></td></tr></table></figure>
<p>这里返回的函数是一个匿名函数，它没有参数，里面调用的变量x和变量y是绑定在外部作用域build中的参数。所以调用build时会根据使用的参数返回这个匿名函数，调用返回的这个函数时使用的变量x和变量y就是调用build时用的参数。</p>
<hr>
<p><br></p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>有时候我们希望为函数增加一些额外的功能，比如在调用函数的前后自动打印某些信息，但又<strong>不希望修改定义函数的代码</strong>。这时就可以使用<strong>装饰器（Decorator）</strong>了，它是python中对<a href="http://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">装饰器模式</a>的实现，可以<strong>在代码运行期间动态增加功能</strong>（装饰器的代码和要装饰的函数的代码还是要写好，这里只是说对要装饰的函数使用装饰器后，在运行时要装饰的函数会被重新包装一遍，使得它具有了装饰器中定义的功能）。</p>
<p>比方说我们要实现一个打印函数名的额外功能，它是通过调用函数对象的 <code>__name__</code> 属性获得的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2015-3-25'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'now'</span></div></pre></td></tr></table></figure>
<p>如果我们不想在每个函数中都重复写实现这个功能的代码，可以把它写为装饰器的形式，然后为每个函数添加这个装饰器。<strong>装饰器本身也是一个函数</strong>，这个例子可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>它<strong>像正常函数一样定义</strong>（没有特别的语法），接收一个函数作为参数，并且返回一个函数 <code>wrapper</code>（Python中函数也是对象，既可以作为参数，也能被返回）。回顾前一节的内容，可以看出 <code>wrapper</code> 函数是一个闭包，它本身接收可变参数 <code>*args</code> 和关键字参数 <code>**kw</code>，并且引用了外部作用域中绑定在 <code>log</code> 函数参数中的 <code>func</code> 变量。</p>
<p>使用装饰器时，借助Python的<strong>@语法</strong>，把装饰器放在函数定义的上一行即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div></pre></td></tr></table></figure>
<p>运行时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">call now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>原理是这样的，把 <code>@log</code> 放在 <code>now()</code> 函数的定义前，运行代码的时候，实际上是在函数定义后执行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now = log(now)</div></pre></td></tr></table></figure>
<p>也即执行了 <code>log</code> 函数，并把 <code>now</code> 这个变量名赋值为 <code>log(now)</code> 返回的 <code>wrapper(*args, **kw)</code> 函数（也即 <code>now</code> 引用的函数对象变了）。此时查看 <code>now</code> 变量指向的函数对象的名字，会发现已经变成了 <code>wrapper</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'wrapper'</span></div></pre></td></tr></table></figure>
<p>此时我们调用这个新的 <code>now()</code> 函数时，实际上执行的就是 <code>wrapper</code> 函数中的代码，打印出函数信息，然后再<strong>调用原来的 <code>now</code> 函数</strong>。要注意 <strong><code>wrapper</code> 调用的 <code>now</code> 函数和我们调用的 <code>now</code> 函数是不同的两个函数</strong>，我们调用的 <code>now</code> 函数已经变成了 <code>wrapper</code> 函数，而 <code>wrapper</code> 函数调用的则是绑定在 <code>log</code> 函数参数中的原本的 <code>now</code> 函数。</p>
<p><strong>简单归纳一下</strong>：</p>
<ul>
<li>装饰器也是一个函数</li>
<li>装饰器实际上是把传入的函数进行一层包装，返回一个新函数</li>
<li>要为函数添加装饰器时，在函数定义前使用 <code>@装饰器名</code> 即可</li>
</ul>
<p>装饰器的原理部分如果还有不清楚的，不妨看看知乎上<a href="https://www.zhihu.com/question/26930016/answer/105175177" target="_blank" rel="external">李冬</a>的答案，讲得比较浅显和清楚。</p>
<hr>
<h3 id="带参数的decorator"><a href="#带参数的decorator" class="headerlink" title="带参数的decorator"></a>带参数的decorator</h3><p>前面提到<strong>装饰器可以用于为函数提供增强功能而无须修改函数本身的代码</strong>，在装饰器函数中，闭包 <code>wrapper</code> 接收的参数就是函数的参数。但是，如果我们希望在使用装饰器时可以更灵活一些，为不同的函数添加功能类似但又略有不同的装饰器呢？这时我们可以使用<strong>带参数的装饰器</strong>来实现（装饰器本身也是函数，是可以传入参数的）。</p>
<p>比方说要实现一个自定义打印文本的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>注意到这里在 <code>wrapper</code> 和 <code>log</code> 之间又套了一层函数，现在变为了 <code>log</code> 接收参数 <code>text</code> 并返回一个装饰器 <code>decorator</code>。这个 <code>decorator</code> 接收一个函数对象，输出文本 <code>text</code> 和函数对象的名字，理解起来其实不难。</p>
<p>使用这个装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log('execute')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2015-3-25'</span>)</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">execute now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>事实上，把 <code>@log</code> 放在 <code>now()</code> 函数的定义前，运行代码时实际上在函数定义后执行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">'execute'</span>)(now)</div></pre></td></tr></table></figure>
<p>也即是先调用 <code>log</code> 函数，传入参数 <code>log(&#39;execute&#39;)</code>，这时返回了 <code>decorator</code> 这个装饰器，然后传入了 <code>now</code> 函数，最后返回包装好的 <code>now</code> 函数（也即 <code>wrapper</code> 函数）。</p>
<hr>
<h3 id="属性复制"><a href="#属性复制" class="headerlink" title="属性复制"></a>属性复制</h3><p>前面已经提到使用 <strong><code>@语法</code></strong> 之后，now变量指向的函数名字等属性都改变了，变成了 <code>wrapper</code> 函数的，实际上，我们希望变量 <code>now</code> 的属性依然是原本 <code>now()</code> 函数的属性，这时就需要进行<strong>属性复制</strong>。</p>
<p>我们不需要编写类似 <code>wrapper.__name__ = func.__name__</code> 这样的代码来逐个把原函数的属性复制给 <code>wrapper</code>，Python内置的 <code>functools.wraps</code> 装饰器可以满足我们的需求。方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @functools.wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>和原来定义装饰器的代码对比，唯一修改的就是加上了 <code>@functools.wraps(func)</code> 这一句。 当然，还要注意先导入functools模块。</p>
<hr>
<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><h4 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h4><blockquote>
<p>编写一个decorator，能在函数调用的前后分别打印出 <code>&#39;begin call&#39;</code> 和 <code>&#39;end call&#39;</code> 的日志。</p>
</blockquote>
<p><strong>解析：</strong></p>
<p>这题很简单，在 <code>wrapper</code> 调用原函数之前，各编写一条打印语句就可以了。</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line">        print(<span class="string">"begin call"</span>)</div><div class="line">        a = func(*args,**kw)</div><div class="line">        print(<span class="string">"end call"</span>)</div><div class="line">        <span class="keyword">return</span> a</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"haha"</span>)</div></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now   <span class="comment"># now是一个函数</span></div><div class="line">&lt;function decorator.&lt;locals&gt;.wrapper at <span class="number">0x00000254B45D8EA0</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now() <span class="comment"># 调用now函数</span></div><div class="line">begin call</div><div class="line">haha</div><div class="line">end call</div></pre></td></tr></table></figure>
<h4 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h4><blockquote>
<p>写出一个@log的decorator，使它既支持：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<blockquote>
<p>又支持：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log('execute')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<p>思路很简单，我们知道使用不带参数的装饰器时，传入装饰器函数（即这里的 <code>log</code>）的参数就是要装饰的函数（比方说 <code>now</code> 函数）；而带参数的装饰器接收的参数则不是要装饰的函数而是别的（比方说一个字符串）。所以呀，我们可以依然使用带参数的装饰器作为原型，但在里面加入对参数类型的判断，如果接收到字符串参数则表示这次调用的是有参数的装饰器，否则就是调用不带参数的装饰器。</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span> <span class="comment"># 默认参数，没有参数时，text就是空字符串</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">        @functools.wraps(func)    # 属性复制</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line">            <span class="keyword">if</span> isinstance(text, str):</div><div class="line">                print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                print(<span class="string">'%s():'</span> % func.__name__)</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">if</span> isinstance(text, str): <span class="comment"># 接收到字符串后返回decorator函数</span></div><div class="line">        <span class="keyword">return</span> decorator</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> decorator(text) <span class="comment"># 接收到函数则直接返回wrapper函数</span></div><div class="line"></div><div class="line"><span class="meta">@log('execute')  # 带参数text的decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now1</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div><div class="line"></div><div class="line"><span class="meta">@log             # 不带参数text的decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now2</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now1()</div><div class="line">execute now1():</div><div class="line"><span class="number">2016</span><span class="number">-2</span><span class="number">-10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now2()</div><div class="line">now2():</div><div class="line"><span class="number">2016</span><span class="number">-2</span><span class="number">-10</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是<strong>偏函数（Partial function）</strong>。</p>
<p><code>functools.partial(f, *args, **kw)</code> 的作用就是创建一个偏函数，<strong>把一个函数的某些参数给固定住</strong>（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<p>举个例子，字符串转整型数的函数int，可以使用<strong>关键字参数base</strong>，指定字符串的进制是多少，然后转换为int的时候会按照base进行进制转换，把字符串<strong>转换成十进制整数</strong>。 如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1000000'</span>, base=<span class="number">2</span>)</div><div class="line"><span class="number">64</span></div></pre></td></tr></table></figure>
<p>如果有大量的二进制字符串要转换，每次都写base=2很麻烦，我们就会希望定义一个新函数，把base参数固定为2，无须每次指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> int(x, base)</div></pre></td></tr></table></figure>
<p>实际上我们不需要自己定义，使用 <code>functools.partial</code> 就可以轻松创建偏函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</div><div class="line"><span class="number">64</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</div><div class="line"><span class="number">85</span></div></pre></td></tr></table></figure>
<p>运行int(‘1000000’)实际相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kw = &#123; <span class="string">'base'</span>: <span class="number">2</span> &#125;</div><div class="line">int(<span class="string">'1000000'</span>, **kw)</div></pre></td></tr></table></figure>
<p><strong>Notice</strong>：</p>
<p>这里创建偏函数只是设定了默认值为2，<strong>调用偏函数时依然可以把参数设置为其他值</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>, base=<span class="number">10</span>)</div><div class="line"><span class="number">1000000</span></div></pre></td></tr></table></figure>
<p><code>functools.partial</code> <strong>不但可以接收关键字参数，还可以接收可变参数</strong> <code>*args</code>，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>max2 = functools.partial(max, <span class="number">10</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>相当于max函数每次接收到若干数字时，都默认再放入一个整数10，然后找其中的最大值。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-03高级特性]]></title>
      <url>http://2wildkids.com/2016/11/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#切片">切片</a></li>
<li><a href="#迭代">迭代</a></li>
<li><a href="#列表生成式">列表生成式</a><ul>
<li><a href="#生成器">生成器</a></li>
<li><a href="#杨辉三角">杨辉三角</a></li>
</ul>
</li>
<li><a href="#迭代器">迭代器</a><ul>
<li><a href="#小结">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>在Python中，代码越少越简单约好。基于这一思想，后面的几个篇章介绍Python一些非常有用的高级特性。</p>
<p>比方说构造一个1~99的奇数列表，可以简单地用循环实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line">n = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> n &lt;= <span class="number">99</span>:</div><div class="line">    L.append(n)</div><div class="line">    n = n + <span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片即取一个list或tuple部分元素的操作。 当我们需要取列表前n个元素，即索引0~<strong>N-1</strong>的元素时，有两种方法：</p>
<p>1.方法1是用循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line"><span class="meta">... </span>    r.append(L[i])</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>2.方法2是利用<strong>切片操作符</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>如果经常要取指定的索引范围，用循环就显得太过繁琐了，Python提供了切片操作来简化这个过程。注意，<strong>切片操作的索引左闭右开</strong>。</p>
<p>如果索引从0开始，还可以改写为 <code>L[:3]</code>。 如果索引到列表最后结束，同样可以简略写为 <code>L[0:]</code>。</p>
<p>此外，Python还支持<strong>倒数切片</strong>。<strong>列表最后一项的索引在倒数中为-1</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</div><div class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</div><div class="line">[<span class="string">'Bob'</span>]</div></pre></td></tr></table></figure>
<p>特别地，切片操作还支持每隔k个元素取1个这样的操作。先创建一个0~99的整数列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</div></pre></td></tr></table></figure>
<p>取后10个只需起始索引为-10即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-10</span>:]</div><div class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</div></pre></td></tr></table></figure>
<p>前十个数隔两个取一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p>所有数，隔五个取一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</div></pre></td></tr></table></figure>
<p>注意！<strong>对list进行切片操作得到的还是list；对tuple进行切片操作得到的还是tuple</strong>。 特别地，<strong>字符串也可看为一种list，同样可以使用切片操作</strong>。</p>
<hr>
<p><br></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>Python中可迭代的对象包括字符串，list，tuple，dict，set和文件等等。 对这些可迭代对象可以使用 <code>for...in</code> 循环来遍历。Python对for循环的抽象程度高于Java和C，所以即使没有下标也能迭代。</p>
<p>比如循环遍历一个dict：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</div><div class="line"><span class="meta">... </span>  print(key, d[key])</div><div class="line">...</div><div class="line">a <span class="number">1</span></div><div class="line">c <span class="number">3</span></div><div class="line">b <span class="number">2</span></div></pre></td></tr></table></figure>
<p>直接打印key会打印所有dict中的key，更改迭代的写法为 <code>for value in d.values()</code> 就变为迭代dict中所有的value。 如果同时要访问key和value，还可以使用 <code>for k, v in d.items()</code>。</p>
<p>字符串同样可以用for循环迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'ABC'</span>:</div><div class="line"><span class="meta">... </span>    print(ch)</div><div class="line">...</div><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure>
<p>要<strong>判断一个对象是否可迭代对象可以通过collections模块的 <code>Iterable</code> 类型</strong>来判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>正如上面迭代dict一样，for循环可以同时引用两个甚至多个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</div><div class="line"><span class="meta">... </span>    print(i, value)</div><div class="line">...</div><div class="line"><span class="number">0</span> A</div><div class="line"><span class="number">1</span> B</div><div class="line"><span class="number">2</span> C</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</div><div class="line"><span class="meta">... </span>    print(x, y)</div><div class="line">...</div><div class="line"><span class="number">1</span> <span class="number">1</span></div><div class="line"><span class="number">2</span> <span class="number">4</span></div><div class="line"><span class="number">3</span> <span class="number">9</span></div></pre></td></tr></table></figure>
<p>例子里的 <code>enumerate</code> 方法通过<a href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="external">enumerate官方文档</a>了解，它返回一个枚举对象，并且传入参数可迭代时它就是一个可迭代的对象。</p>
<p><strong>可以用 <code>list(enumerate(可迭代对象))</code> 把一个可迭代对象变为元素为tuple类型的list</strong>，每个tuple有两个元素，形式如：<code>(序号，原可迭代对象内容)</code>。</p>
<p>并且使用enumerate时可以指定开始的序号，<code>enumerate(iterable, start=0)</code>，不写时默认参数为0，即序号从0开始。 可以自己指定为其他数。</p>
<hr>
<p><br></p>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的用于创建list的方式。</p>
<p>比方说生成1到10，可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>要生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code>平方序列，笨办法是用循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</div><div class="line"><span class="meta">... </span>   L.append(x * x)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>用列表生成式只用一个语句就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素 <code>x * x</code> 放到前面，后面跟for循环，就可以把list创建出来。</p>
<p>在for循环后面还可以加上if判断，比方说这个例子用于筛选出偶数的平方数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>使用两层循环还可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</div><div class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</div></pre></td></tr></table></figure>
<p>列出当前目录下所有文件和目录名也非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></div><div class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.Trash'</span>,  <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>]</div></pre></td></tr></table></figure>
<p>前面一节提到for循环迭代可以同时用两个变量，这里列表生成式同样可以用两个变量来生成list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</div><div class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</div></pre></td></tr></table></figure>
<p>把list中所有字符串的大写字母换成小写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</div><div class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>通过列表生成式可以简单地创建列表，但受到内存限制，列表容量是有限的。如果列表元素很多，而我们仅需访问前面一部分元素，则会造成很大的存储空间的浪费。</p>
<p><strong>生成器(generator)</strong>就意在解决这个问题，允许在循环过程中不断推算出后续元素，而不用创建完整的list。在Python中，这种边循环边计算的机制称为生成器。</p>
<p>和列表生成式的区别很简单，仅仅是把外层的<strong>[]方括号</strong>换成<strong>()圆括号</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</div></pre></td></tr></table></figure>
<p>生成器无法通过索引访问，因为它<strong>保存的是算法</strong>，要遍历生成器需要通过 <code>next()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure>
<p>当到达最后一个元素时，再使用 <code>next()</code> 就会出现 <code>StopIteration</code> 错误。 当然，实际遍历生成器时不会这样一个一个用 <code>next()</code> 方法遍历，用for循环进行迭代即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure>
<p>当算法比较复杂，用简单for循环无法写出来时，还可以通过函数来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        print(b)</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div></pre></td></tr></table></figure>
<p>比方说这个计算斐波那契数列的函数，稍微改写一下即可变成generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b  <span class="comment">#只修改这里</span></div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div></pre></td></tr></table></figure>
<p>这是定义generator的另一种方法，<strong>如果一个函数定义中包含yield关键字，则该函数就变为一个generator</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;generator object fib at <span class="number">0x104feaaa0</span>&gt;</div></pre></td></tr></table></figure>
<p>函数是顺序执行，遇到return语句或到达最后一行函数语句就返回。而变成generator的函数，在每次调用 <code>next()</code> 的时候执行，<strong>遇到yield就返回</strong>，下次执行会从yield的地方开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>同样地，把函数改成generator后，我们不需要用next()方法获取写一个返回值，而是只借用for循环进行迭代。</p>
<p>但是这样就拿不到fib函数return语句的值(即字符串done)，要获取这个值必须捕获 <code>StopIteration</code> 这个错误，它的value就是我们返回的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</div><div class="line"><span class="meta">... </span>        x = next(g)</div><div class="line"><span class="meta">... </span>        print(<span class="string">'g:'</span>, x)</div><div class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line"><span class="meta">... </span>        print(<span class="string">'Generator return value:'</span>, e.value)</div><div class="line"><span class="meta">... </span>        <span class="keyword">break</span></div><div class="line">...</div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">2</span></div><div class="line">g: <span class="number">3</span></div><div class="line">g: <span class="number">5</span></div><div class="line">g: <span class="number">8</span></div><div class="line">Generator <span class="keyword">return</span> value: done</div></pre></td></tr></table></figure>
<p>生成器的工作原理是：在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。</p>
<p>对于函数改成的generator来说，<strong>遇到return语句或者执行到函数体最后一行语句就结束generator</strong>，for循环随之结束。</p>
<p>普通函数和生成器函数可以通过调用进行区分，调用普通函数会直接返回结果，调用生成器函数则会返回一个生成器对象。</p>
<hr>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>要求使用生成器生成1~10行的杨辉三角。 提示：把每一行当作一个list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">(max)</span>:</span></div><div class="line">    n = <span class="number">0</span></div><div class="line">    b = [<span class="number">1</span>]</div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b</div><div class="line">        b = [<span class="number">1</span>] + [ b[i] + b[i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b) - <span class="number">1</span>)] + [<span class="number">1</span>]</div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这段代码非常短，但是已经充分实现了题目要求，值得欣赏!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> L <span class="keyword">in</span> triangles(<span class="number">6</span>):</div><div class="line"><span class="meta">... </span>    L</div><div class="line">...</div><div class="line">[<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>代码里面有两个窍门，一是列表相加，注意不是列表元素相加。 列表相加相当于把后一个列表的元素全部append到前一个列表。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>R = [<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L+R</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<p>上面代码中的b即把每一行当作一个list，因为每一行的开头结尾都是1，所以可以每一行的list看作三个list的相加，一头一尾两个list是只有1个元素1的list，中间的list用列表生成式生成。</p>
<p>另一个窍门就是这里的列表生成式。 注意这里计算时还没赋值，引用列表b的内容是上一行的信息，所以能巧妙地借助上一行计算相邻两数之和，最终得到含有n-2项的中间列表。</p>
<p>补充解析一下代码执行的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b = [<span class="number">1</span>], n = <span class="number">0</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>] = [<span class="number">1</span>,<span class="number">1</span>], n = <span class="number">1</span> <span class="comment"># 无中间列表</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">2</span> <span class="comment"># 中间列表包含1个元素</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">2</span>, <span class="number">2</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">3</span> <span class="comment"># 中间列表包含2个元素</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">3</span>, <span class="number">3</span>+<span class="number">3</span>, <span class="number">3</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">4</span> <span class="comment"># 中间列表包含4个元素</span></div><div class="line"><span class="meta">... </span>...</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器即<strong>Iterator</strong>， 前面说到可以通过<strong>collections模块</strong>的<strong>Iterable类型</strong>来判断一个对象是否可迭代对象。 这里引入Iterator的概念，可以通过类似的方式判断。</p>
<p><strong>list，dict，str虽然都Iterable，却不是Iterator</strong>。 生成器都是Iterator。<strong>Iterator的特性允许对象通过next()函数不断返回下一个值</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p><strong>要把list，dict，str变为Iterator可以使用 <code>iter()</code> 函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>Python的Iterator对象表示的其实是一个<strong>数据流</strong>，Iterator对象可以被 <code>next()</code> 函数调用并不断返回下一个数据，直到没有数据时抛出 <code>StopIteration</code> 错误。</p>
<p>可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 <code>next()</code> 函数实现按需计算下一个数据，所以 <code>Iterator</code> 的计算是惰性的，只有在需要返回下一个数据时它才会计算，也因此能够节省空间。</p>
<p>Iterator甚至可以表示一个<strong>无限大的数据流</strong>，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>凡是可作用于for循环的对象都是 <code>Iterable</code> 类型；</p>
<p>凡是可作用于 <code>next()</code> 函数的对象都是 <code>Iterator</code> 类型，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是 <code>Iterable</code> 但不是 <code>Iterator</code>，不过可以通过 <code>iter()</code> 函数获得一个 <code>Iterator</code> 对象。</p>
<p>Python的<strong>for循环本质上就是通过不断调用 <code>next()</code> 函数实现的</strong>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>实际上完全等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先获得Iterator对象:</span></div><div class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment"># 循环:</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 获得下一个值:</span></div><div class="line">        x = next(it)</div><div class="line">    <span class="keyword">except</span> StopIteration:</div><div class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-02函数]]></title>
      <url>http://2wildkids.com/2016/11/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#定义函数">定义函数</a><ul>
<li><a href="#空函数">空函数</a></li>
<li><a href="#参数检查">参数检查</a></li>
<li><a href="#返回多个值">返回多个值</a></li>
</ul>
</li>
<li><a href="#函数的参数">函数的参数</a><ul>
<li><a href="#位置参数">位置参数</a></li>
<li><a href="#默认参数">默认参数</a></li>
<li><a href="#可变参数">可变参数</a></li>
<li><a href="#关键字参数">关键字参数</a></li>
<li><a href="#命名关键字参数">命名关键字参数</a></li>
<li><a href="#参数组合">参数组合</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#递归函数">递归函数</a><ul>
<li><a href="#汉诺塔">汉诺塔</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>Python支持函数，不仅可以灵活地自定义函数，而且本身也内置了很多有用的函数。</p>
<p>除了可以使用help(函数名)查看内置函数（<strong>built-in function, BIF</strong>）的用法和用途，也可以直接查看<a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">官方文档</a>。</p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个<strong>别名</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义函数要使用 <code>def</code> 语句，依次写出 <em>函数名</em>、<em>括号</em>、<em>括号中的参数</em> 和<em>冒号</em>，然后，在缩进块中编写函数体，函数的返回值用 <code>return</code> 语句返回。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> -x</div></pre></td></tr></table></figure>
<p>注意，如果没有return语句，则函数执行完毕也会返回 <code>None</code>，如果想要函数返回 <code>None</code>，除了写 <code>return None</code> 之外还可以直接写 <code>return</code>。</p>
<p>我们既可以直接在命令行定义函数，也可以把函数放在 <code>.py</code> 文件中定义。若采用后者,则使用函数时要先把工作目录跳转到文件保存的目录，再启动Python，然后用 <code>from 文件名 import 函数名</code> 即可导入函数。(这里文件名不需要包含文件扩展名 <code>.py</code>)</p>
<p>比方说把上面的 <code>my_abs</code> 函数写入到 <code>my_abs.py</code> 文件中，保存在桌面，使用该函数需要先 <code>cd</code> 到桌面目录，然后再导入和使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator&gt;cd Desktop</div><div class="line"></div><div class="line">C:\Users\Administrator\Desktop&gt;python</div><div class="line">Python <span class="number">3.5</span><span class="number">.1</span> |Anaconda <span class="number">4.0</span><span class="number">.0</span> (<span class="number">64</span>-bit)| (default, Feb <span class="number">16</span> <span class="number">2016</span>, <span class="number">09</span>:<span class="number">49</span>:<span class="number">46</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_abs <span class="keyword">import</span> my_abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">5</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">0</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">-5</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果还没想好怎么写一个函数，可以用 <code>pass</code> 语句来实现一个空函数，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><code>pass</code> 语句什么都不做，但可以用来做占位符。用在其他语句中也可以，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>当<strong>参数个数不对</strong>时，Python解释器会抛出 <code>TypeError</code> 错误，但是当<strong>参数类型错误</strong>时，如果函数里面没有给出对应的方法，Python解释器就无法抛出正确的错误提示信息。</p>
<p>上面实现的 <code>my_abs</code> 函数还不够完善，使用Python的内置函数 <code>isinstance()</code> 和 <code>raise</code> 语句来实现类型检查并报错的功能，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</div><div class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</div><div class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> -x</div></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">'a'</span>) <span class="comment"># 参数类型错误</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> my_abs</div><div class="line">TypeError: bad operand type</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 参数个数错误</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</div></pre></td></tr></table></figure>
<hr>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>举一个返回坐标点的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    <span class="keyword">return</span> nx, ny</div></pre></td></tr></table></figure>
<p>这里用到math包的函数 <code>cos</code> 和 <code>sin</code>，返回坐标点的两个维度的值。接收时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(x)</div><div class="line"><span class="number">151.96152422706632</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(y)</div><div class="line"><span class="number">70.0</span></div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</div><div class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</div></pre></td></tr></table></figure>
<p>实际上，在Python中，函数返回的仍然是一个变量，但<strong>在返回多个值时，Python会将它们合并为一个tuple返回</strong>，又因为语法上返回一个tuple可以省略括号，所以可以直接写成返回多个值的形式。 特别地，我们可以使用多个变量来接收一个返回的tuple，Python会按位置顺序来赋对应的值。</p>
<hr>
<p><br></p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数。</p>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>传入值按位置顺序依次赋给参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></div><div class="line">    s = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">        n = n - <span class="number">1</span></div><div class="line">        s = s * x</div><div class="line">    <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>如这个幂函数，调用时使用 <code>power(5,2)</code> 这样的格式即可，5和2会按位置顺序分别被赋给变量x和n。</p>
<hr>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>有时候我们希望函数带有默认设置，比方说令幂函数默认计算平方，这样就不需要每次都传入参数n了。 可以使用默认参数来实现这样的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></div><div class="line">s = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">    n = n - <span class="number">1</span></div><div class="line">    s = s * x</div><div class="line"><span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>此时使用 <code>power(5)</code> 也能调用幂函数，计算的是5的平方。</p>
<p>在编写函数的参数列表时，应当注意：</p>
<ol>
<li>必选参数在前，默认参数在后，否则Python的解释器会报错。</li>
<li>有多个参数时，把变化大的参数放前面，变化小的参数放后面。这样我们可以把变化小的参数设为默认参数，调用的时候就不需要每次都填写这个参数了。</li>
</ol>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender, age=<span class="number">6</span>, city=<span class="string">'Beijing'</span>)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name)</div><div class="line">    print(<span class="string">'gender:'</span>, gender)</div><div class="line">    print(<span class="string">'age:'</span>, age)</div><div class="line">    print(<span class="string">'city:'</span>, city)</div></pre></td></tr></table></figure>
<p>age和city是默认参数，调用时可以不提供。并且提供默认参数时既可以按顺序也可以不按顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enroll(<span class="string">'Bob'</span>, <span class="string">'M'</span>, <span class="number">7</span>)</div><div class="line">enroll(<span class="string">'Adam'</span>, <span class="string">'M'</span>, city=<span class="string">'Tianjin'</span>)</div></pre></td></tr></table></figure>
<p>按顺序不需指定参数名，<strong>不按顺序时则必须提供参数名，这样其他未提供的参数依然使用默认参数的值</strong>。</p>
<p>注意<strong>默认参数必须指向不可变对象</strong>！举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<p>多次使用默认参数时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure>
<p>可以看到这里默认参数的内容改变了，因为L是可变对象，每次调用add_end，函数会修改默认参数的内容。 所以切记默认参数要指向不可变对象，要实现同样的功能，使用None就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        L = []</div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<p>使用不可变对象做参数，在多任务环境下读取对象不需要加锁，同时读没有问题。因此能使用不可变对象就尽量用不可变对象。</p>
<hr>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数即<strong>传入的参数个数可变，传入任意个参数都可以</strong> 。先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></div><div class="line">    sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>这个求和函数只有一个参数，必须传入一个list或者tuple才行，即 <code>calc([1, 2, 3，7])</code> 或者 <code>calc((1, 3, 5, 7))</code>。如果使用可变参数，则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></div><div class="line">    sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>只是在参数前面加了一个 <code>*</code> 号，函数内容不需要改变。这样定义的函数可以使用任意个数的参数，包括0个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>传入参数时不需要构建list或者tuple，<strong>函数接收参数时会自动构建为一个tuple</strong>。 如果已经有一个list或者tuple要调用可变参数也很方便，<strong>将它变成可变参数</strong>就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums) <span class="comment"># 在列表前面加上一个星号即可完成转换</span></div><div class="line"><span class="number">14</span></div></pre></td></tr></table></figure>
<p>同样只需要加一个 <code>*</code> 号即可完成转换。</p>
<p>args是一个tuple类型的对象，<strong>没有传入时就是一个空的tuple</strong>。</p>
<hr>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许传入0个或任一个参数，这些可变参数会自动组装为一个tuple。 而<strong>关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数会自动组装为一个dict</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</div></pre></td></tr></table></figure>
<p>调用时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</div><div class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</div><div class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>kw是一个dict类型的对象，<strong>没有传入时就是一个空的dict</strong>。 和可变参数类似，先组装一个dict然后再传入也是可以的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>或者进行转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra) <span class="comment"># 在字典前面加上两个星号即可完成转换</span></div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>这里使用 <code>**</code> 转换的实质是把extra拷贝一份，然后令kw指向这个拷贝，所以<strong>函数内的操作不会对函数外的extra有任何影响</strong>。</p>
<hr>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>关键字参数的自由度很大，但有时我们需要限制用户可以传入哪些参数，这时就需要用到命名关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></div><div class="line">    print(name, age, city, job)</div></pre></td></tr></table></figure>
<p>和关键字参数不同，这里<strong>采用一个 <code>*</code> 号作为分隔符</strong>，<code>*</code> 号后面的参数被视为关键字参数。 调用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">Jack <span class="number">24</span> Beijing Engineer</div></pre></td></tr></table></figure>
<h4 id="错误举例"><a href="#错误举例" class="headerlink" title="错误举例"></a>错误举例</h4><p><strong>1.没有给参数名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</div></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，如果没有参数名，Python解释器会视其为位置参数，从而报参数个数超出的错误。</p>
<p><strong>2.没有传入参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#83&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>)</div><div class="line">TypeError: person() missing <span class="number">2</span> required keyword-only arguments: <span class="string">'city'</span> <span class="keyword">and</span> <span class="string">'job'</span></div></pre></td></tr></table></figure>
<p><strong>命名关键字参数若没有定义默认值则被视为必选参数</strong>。 可以为命名关键字参数设置默认值， 比如 <code>def person(name, age, *, city=&#39;Beijing&#39;, job):</code>，这样即使不传入也不会报错了。</p>
<p><strong>3.传入没有定义的参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, joc=<span class="string">'Engineer'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#84&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, joc=<span class="string">'Engineer'</span>)</div><div class="line">TypeError: person() got an unexpected keyword argument <span class="string">'joc'</span></div></pre></td></tr></table></figure>
<p><strong>命名关键字参数限制了可以传入怎样的参数，如果传入参数的参数名不在其中也会报错。</strong></p>
<hr>
<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数除了<strong>可变参数和命名关键字参数无法混合</strong>，可以任意组合必选参数、默认参数、可变参数、关键字参数和命名关键字参数。</p>
<p>注意！<strong>参数定义的顺序必须是： <code>必选参数 -&gt; 默认参数 -&gt; 可变参数/命名关键字参数 -&gt; 关键字参数</code></strong>。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></div><div class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></div><div class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</div></pre></td></tr></table></figure>
<p>除了这种普通的调用方式，通过tuple和dict也可以很神奇地调用！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div></pre></td></tr></table></figure>
<p>赋值是按照上面的固定顺序来进行的！<strong>对于任意函数，都可以通过类似 `func(*args, </strong>kw)` 的形式调用它，无论它的参数是如何定义的**。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p><strong>默认参数一定要用不可变对象</strong>，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code> 是可变参数，<code>*args</code> 接收的是一个<strong>tuple</strong>；</p>
<p><code>**kw</code> 是关键字参数，<code>**kw</code> 接收的是一个<strong>dict</strong>。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p><strong>可变参数既可以直接传入</strong>：func(1, 2, 3)，<strong>又可以先组装list或tuple</strong>，再通过 <code>*args</code> 传入： <code>func(*(1, 2, 3))</code>；</p>
<p><strong>关键字参数既可以直接传入</strong>：func(a=1, b=2)，<strong>又可以先组装dict</strong>，再通过 <code>**kw</code> 传入： <code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<p>使用 <code>*args</code> 和 <code>**kw</code> 这两个名字是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名关键字参数是为了限制调用者可以传入的参数名，并且我们可以为其提供默认值。</p>
<p><em>*定义命名关键字参数不要忘了写分隔符 `</em>` ，否则定义的将是位置参数。</p>
<hr>
<p><br></p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>若一个函数在函数内部调用自身，则该函数是一个递归函数。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>阶乘函数就是一个递归函数，<strong>使用递归函数需要注意防止栈溢出</strong>。在计算机中，函数调用是通过<strong>栈（stack）</strong>这种数据结构实现的。</p>
<p>每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。<strong>由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</strong>。</p>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，尾递归和循环效果一样，实际上可以把循环看作特殊的尾递归函数。</p>
<p><strong>尾递归要求函数返回时调用自身本身而不能包含表达式</strong>。这样编译器或解释器就可以把尾递归进行优化，无论递归了多少次都只占用一个栈帧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">  <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></div><div class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> product</div><div class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</div></pre></td></tr></table></figure>
<p>之前的函数定义有乘法表达式，所以不是尾递归。</p>
<p>计算过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">===&gt; fact(<span class="number">5</span>)</div><div class="line">===&gt; <span class="number">5</span> * fact(<span class="number">4</span>)</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * fact(<span class="number">3</span>))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * fact(<span class="number">2</span>)))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * fact(<span class="number">1</span>))))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * <span class="number">2</span>))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * <span class="number">6</span>)</div><div class="line">===&gt; <span class="number">5</span> * <span class="number">24</span></div><div class="line">===&gt; <span class="number">120</span></div></pre></td></tr></table></figure>
<p>这里改为在函数调用前先计算product，每次递归仅调用函数本身就可以了。</p>
<p>计算过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">===&gt; fact_iter(<span class="number">5</span>, <span class="number">1</span>)</div><div class="line">===&gt; fact_iter(<span class="number">4</span>, <span class="number">5</span>)</div><div class="line">===&gt; fact_iter(<span class="number">3</span>, <span class="number">20</span>)</div><div class="line">===&gt; fact_iter(<span class="number">2</span>, <span class="number">60</span>)</div><div class="line">===&gt; fact_iter(<span class="number">1</span>, <span class="number">120</span>)</div><div class="line">===&gt; <span class="number">120</span></div></pre></td></tr></table></figure>
<p>可惜<strong>Python标准的解释器没有对尾递归做优化，所以即使改为尾递归的写法还是有可能产生栈溢出</strong>。</p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>a有n个盘子（从上到下由轻到重），要求只借助a，b，c三个支架，把所有盘子移动到c。并且重的盘子不可以在轻的盘子上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a,<span class="string">' --&gt; '</span>,c)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        move(n<span class="number">-1</span>,a,c,b)    <span class="comment">#将前n-1个盘子从A移动到B上</span></div><div class="line">        print(a,<span class="string">' --&gt; '</span>,c) <span class="comment">#将最底下的最后一个盘子从A移动到C上</span></div><div class="line">        move(n<span class="number">-1</span>,b,a,c)    <span class="comment">#将B上的n-1个盘子移动到C上</span></div></pre></td></tr></table></figure>
<p>代码很短，思路很清晰，基于规则，每次只能把余下盘子中最重的移到c上。 这里通过改变传入参数的顺序可以灵活使用三个支架。 a在一次移动中可能充当b的角色，b，c也可能充当a的角色。</p>
<p>但总的来说，我们都是希望把充当a的支架上n-1个盘子先移到充当b的支架上，再把a的剩下的最重的一个盘子移动到充当c的支架上，然后递归，这时充当b的支架就变成a，充当a的支架就变成b，直到最后完成所有移动。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-01Python基础]]></title>
      <url>http://2wildkids.com/2016/10/21/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01Python%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#数据类型和变量">数据类型和变量</a><ul>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#常量">常量</a></li>
</ul>
</li>
<li><a href="#使用list和tuple">使用list和tuple</a><ul>
<li><a href="#list">list</a></li>
<li><a href="#tuple">tuple</a></li>
</ul>
</li>
<li><a href="#使用dict和set">使用dict和set</a><ul>
<li><a href="#dict">dict</a></li>
<li><a href="#set">set</a></li>
<li><a href="#再议不可变对象">再议不可变对象</a></li>
</ul>
</li>
<li><a href="#条件判断">条件判断</a><ul>
<li><a href="#条件判断-1">条件判断</a></li>
<li><a href="#再议input">再议input</a></li>
<li><a href="#循环">循环</a></li>
</ul>
</li>
<li><a href="#字符串和编码">字符串和编码</a><ul>
<li><a href="#字符编码">字符编码</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#格式化">格式化</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python可以直接表达的数据类型包括：整数，浮点数，复数，字符串，布尔值和空值。</p>
<h5 id="整数-int"><a href="#整数-int" class="headerlink" title="整数 int"></a>整数 int</h5><p>任意大小，正负皆可。并且可以用0b、0o、0x分别表示二进制、八进制和十六进制数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0b10</span> <span class="comment"># 也可以是 0B10</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0o10</span> <span class="comment"># 也可以是 0O10</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0x10</span> <span class="comment"># 也可以是 0X10</span></div><div class="line"><span class="number">16</span></div><div class="line"></div><div class="line"><span class="comment"># 十进制转其他进制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">2</span>)</div><div class="line"><span class="string">'0b10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">8</span>)</div><div class="line"><span class="string">'0o10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">16</span>)</div><div class="line"><span class="string">'0x10'</span></div><div class="line"></div><div class="line"><span class="comment"># 其他进制转十进制（也可将字符串转换为十进制）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0b10</span>) <span class="comment"># 也可以是 int('10', 2)</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0o10</span>) <span class="comment"># 也可以是 int('10', 8)</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0x10</span>) <span class="comment"># 也可以是 int('10', 16)</span></div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>除了普通的写法之外，也可使<strong>用科学记数法</strong>，即1.23x10^9就是1.23e9 ，0.000012可以写成1.2e-5，等等。</p>
<p><strong>整数运算永远是精确的(结果也是整数)，浮点数运算则有四舍五入的误差</strong>。</p>
<p>Python提供两种除法+求余运算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><code>/</code></strong></td>
<td style="text-align:center">结果为浮点数，即使两数整除，<strong>结果也是浮点数</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>//</code></strong></td>
<td style="text-align:center">结果为整数，也称地板除，对<strong>结果向下取整</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>%</code></strong></td>
<td style="text-align:center">结果为整数，用于计算余数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p>Python中复数用j表示虚数部分，比如说 <code>x=2.4 + 5.6j</code>， 并且可以通过复数的类属性 <code>real</code> 取得实部，类属性 <code>imag</code> 取得虚部，通过类方法 <code>conjugate()</code> 获得共轭复数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">2.4</span> + <span class="number">5.6j</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</div><div class="line"><span class="number">2.4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</div><div class="line"><span class="number">5.6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.conjugate()</div><div class="line">(<span class="number">2.4</span><span class="number">-5.6j</span>)</div></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>使用单引号或双引号括起。而引号本身需要使用转义符<code>\</code>来表达。 用<code>\&#39;</code>来表示<code>&#39;</code>。</p>
<p>转义符还可以用来转义很多字符，如<code>\n</code>表示换行。<code>\t</code>表示制表符。 <code>\</code>本身也需要转义用 <strong>双斜杠</strong> 来代替。</p>
<p>如果一个字符串中很多字符都要转义就会很麻烦，所以Python又提供一种简便的写法，<strong><code>r&#39;&#39;</code>表示两个引号之间的内容是不需要转义的</strong>。 对于多行的字符串，为了避免加入<code>\n</code>的不方便，可以使用<code>&#39;&#39;&#39;something&#39;&#39;&#39;</code>的格式，即<strong>用三个引号来括起字符串，换行会被保留</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 没使用三引号</div><div class="line">&gt;&gt;&gt; a = '123</div><div class="line">  File "&lt;stdin&gt;", line 1</div><div class="line">a = '123</div><div class="line">   ^</div><div class="line">SyntaxError: EOL while scanning string literal</div><div class="line"></div><div class="line"># 使用了三引号</div><div class="line">&gt;&gt;&gt; a = '''123</div><div class="line">... 456</div><div class="line">... 789'''</div><div class="line">&gt;&gt;&gt; a</div><div class="line">'123\n456\n789'</div></pre></td></tr></table></figure>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>只有True和False两种，首字母大写。如果输入一个判断式，则Python会给出布尔值的结果。比方说输入3&gt;2，运行后会得到True。 对于布尔值有三个逻辑运算符，分别是and，or和not。 <strong>本质上True用1存储，False用0存储</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> != <span class="number">0</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == <span class="keyword">False</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><p>Python中用None表示，<strong>不同于数值0</strong>。数值0是有意义的，而None是一个特殊的空值。可以将None赋值给变量，但无法创建None以外的其他NoneType对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; a = None</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; None == a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; None == ''</div><div class="line">False</div><div class="line">&gt;&gt;&gt; None == 0</div><div class="line">False</div></pre></td></tr></table></figure>
<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>Python是一门动态类型语言</strong>，这意味着在Python中，<strong>可以反复把任意数据类型的对象赋值给同一个变量</strong>，相比起静态语言更加地灵活。</p>
<p>在Python中变量名不可以以数字开头，构成可以包括大小写英文，数字及下划线。</p>
<p>当我们写：a=’ABC’ 时，Python解释器干了两件事情：</p>
<ol>
<li>在内存中创建了一个值为<code>&#39;ABC&#39;</code>的字符串对象；</li>
<li>在内存中创建了一个名为a的变量，并把它指向对象<code>&#39;ABC&#39;</code>。</li>
</ol>
<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>Python中没有常量</strong>，因为变量都可以重复赋值。但是一般<strong>约定用全部字母大写的单词来表示一个常量</strong>，如：PI=3.14。</p>
<hr>
<p><br></p>
<h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种Python内置的数据类型，表示<strong>有序集合</strong>，可动态删除和插入。通过索引可以访问列表元素，<strong>索引从0开始</strong>，即访问第一个列表元素。并且列表是循环的，<strong>可以通过索引－1访问最尾的元素</strong>，索引－2访问倒数第二个元素。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</div><div class="line"><span class="string">'Michael'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</div><div class="line"><span class="string">'Tracy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>]</div><div class="line"><span class="string">'Bob'</span></div></pre></td></tr></table></figure>
<p>另外，还可以用 <code>len()</code> 函数获取列表的元素个数。</p>
<p>list 是一个<strong>可变的</strong>有序表，所以，可以往 list 中追加元素到末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>也可以把元素插入到指定的位置，比如索引号为 1 的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>要删除 list 末尾的元素，用 pop() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</div><div class="line"><span class="string">'Adam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</div><div class="line"><span class="string">'Jack'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素的数据类型可以不同，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素也可以是另一个 list，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>] <span class="comment"># 四个元素，其中第三个元素是一个列表</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</div><div class="line"><span class="string">'python'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</div><div class="line">[<span class="string">'asp'</span>, <span class="string">'php'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">0</span>]</div><div class="line"><span class="string">'asp'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">1</span>]</div><div class="line"><span class="string">'php'</span></div></pre></td></tr></table></figure>
<p>要注意s只有4个元素，s[2]作为一个list类型的元素。要拿到’php’可以用 <code>s[2][1]</code>，即把s看作一个二维数组，这样的嵌套可以有很多层。</p>
<p>如果一个 list 中一个元素也没有，就是一个空的 list，它的长度为 0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(L)</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple也是一种<strong>有序列表</strong>，但<strong>tuple一旦初始化就无法再修改</strong>，也因为这个特性，所以代码更安全。和list不同，tuple用小括号来括起。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</div></pre></td></tr></table></figure>
<p>定义空的tuple如下如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">()</div></pre></td></tr></table></figure>
<p>但是，要<strong>定义一个只有1个元素的 tuple</strong>，就要注意一下，如果使用t = (1)来定义，则得到的不是一个tuple，而是整数1，因为括号既可以表示tuple又可以表示数学公式中的小括号。这种情况下默认为后者。要定义1个元素的tuple格式如下，使用一个逗号进行区分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line"><span class="number">1</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="number">1</span>,)</div></pre></td></tr></table></figure>
<p>tuple也有 “可变” 的例子，如果tuple的其中一个元素是list，则这个list元素的内容是可以修改的，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</div></pre></td></tr></table></figure>
<p>这个例子实际修改的是list而不是tuple，tuple指向的位置不会变，而list指向的位置可变，上面的例子实际上是创建了字符串X和Y，然后让tuple的第三个元素也即list元素指向这两个新的字符串。</p>
<hr>
<p><br></p>
<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict即字典，用于存储键值对，查找速度极快。如果使用list来存键值对就需要两个list，要先从key list找出key，再从value list找到对应项的值，因此list越长，耗时越长。用dict实现则可以直接根据key来找value。格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</div><div class="line"><span class="number">95</span></div></pre></td></tr></table></figure>
<p>dict速度快是因为Python内部像字典一样建立了索引，字典有部首表，Python内部也会根据不同key算出一个存放的「页码」(哈希算法)，所以速度非常快。除了初始化赋值还可以对同一个key进行多次赋值，会覆盖原来的value，如果key不存在就会对dict插入一个新的键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>] = <span class="number">20</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Lincoln'</span>] = <span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p>要判断key是否在dict里面有两种方法：</p>
<p>1.使用in关键字，有则返回True，无则返回False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>2.使用dict提供的get方法，有则返回key对应的value，无则返回空值None或者自己指定的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</div><div class="line"><span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>删除一个key则对应的value也会从dict中删除，使用pop方法来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</div><div class="line"><span class="number">75</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>dict的插入和查找速度极快，不会随着key的增加而增加，但需要占用大量的内存</strong>，内存浪费多。list则相反，插入和查找时间随元素增加而增加，但占用空间少。所以dict是一种用空间换时间的方法，注意<strong>dict的key必须是不可变对象</strong>，无法修改key，不然dict就混乱了。<strong>字符串和整数等都可以作为key，list无法作为key</strong>。</p>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict的原理是一样的，同样<strong>不可以放入可变对象做key</strong>，唯一的区别是<strong>set只有key没有value</strong>。显然<strong>set里面是没有重复的元素的</strong>，不然哈希时会出错。<strong>set是有序的，需要使用列表/元组做初始化</strong>，定义方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>列表中有重复元素时set会自动被过滤</strong>，添加可以使用add方法，如s.add(4)。删除则用remove方法，如s.remove(4)。</p>
<p>集合可以看成数学意义上无序和无重复的集合，<strong>可以做交集、并集、差集等操作</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</div><div class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1-s2</div><div class="line">&#123;<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="再议不可变对象"><a href="#再议不可变对象" class="headerlink" title="再议不可变对象"></a>再议不可变对象</h3><p>Python中一切皆对象，而对象又分可变对象和不可变两类对象两类，具体来说，它们的差别就是<strong>对象的内容是否可变</strong>。不可变对象包括int, float, string, tuple，空值等，可变对象包括list, dict, set等。要注意对象和变量的关系，<strong>在Python里，变量都是对对象的引用</strong>。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'b'</span>  <span class="comment"># 字符串对象本身是不可变的</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"></div><div class="line"><span class="comment"># 变量可以指向另一个字符串对象</span></div><div class="line"><span class="comment"># 但字符串对象'abc'并没有改变，它依然存在于内存中</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'bbc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'bbc'</span></div></pre></td></tr></table></figure>
<p>关于参数传递，可以简单总结为以下两点：</p>
<ul>
<li>当一个可变对象作为函数参数时，函数内对参数修改会生效。</li>
<li>当一个不可变对象作为函数参数时，函数内对参数修改无效，因为实际上函数是创建一个新的对象并返回而已，没有修改传入的对象。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</div><div class="line">&gt;&gt; a</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<p>list是可变对象，使用函数操作，内容会变化，注意区分一下<strong>变量</strong>和<strong>对象</strong>，这里a是一个变量，它指向一个列表对象，这个列表对象的内容才是[‘c’, ‘b’, ‘a’]。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line"><span class="string">'Abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'abc'</span></div></pre></td></tr></table></figure>
<p>字符串是不可变对象，所以replace函数并不会修改变量a指向的对象，实际上调用不可变对象的任意方法都不改变该对象自身的内容，只会创建新对象并返回，如果使用一个新的变量来接收返回的对象，就能得到操作结果。不接收则直接打印，<strong>原变量指向的对象不会变化</strong>。</p>
<p>注意，虽然tuple是不可变对象，但是如果使用tuple作为dict或者set的key，还是有可能产生错误，因为tuple允许元素中包含列表，列表内容可变。如果使用了带有列表元素的tuple作为key就会报 <strong><code>TypeError: unhashable type: &#39;list&#39;</code></strong> 的错误。</p>
<hr>
<p><br></p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>Python中代码块是以缩进作区分的，<strong>if－else条件判断注意要在判定条件后写冒号，并且代码块都正确对齐。多个判断条件可以使用多个elif来实现</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">age = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</div><div class="line">print(<span class="string">'teenager'</span>)</div><div class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</div><div class="line">print(<span class="string">'adult'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">'kid'</span>)</div></pre></td></tr></table></figure>
<p>判断条件并不一定要是一个判断式，可以简写为一个变量，<strong>当变量为非零数值，非空字符串，非空list等时，判断为True，否则为False</strong>。</p>
<hr>
<h3 id="再议input"><a href="#再议input" class="headerlink" title="再议input"></a>再议input</h3><p>有时会采取 <strong><code>input(&#39;提示语句&#39;)</code></strong> 的方式读取用户输入，作为判定条件。要注意<strong>用户输入属于字符串类型</strong>，要进行数值比较必须先转换为对应的数据类型，否则会报错。</p>
<p>Python提供int(), float(), str()等方法进行数据类型的转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输入1表示Yes，输入0表示No</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>choose = input(<span class="string">'If you choose yes, please input 1. Otherwise, input 0: '</span>)</div><div class="line">If you choose yes, please input <span class="number">1.</span> Otherwise, input <span class="number">0</span>: <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> choose: <span class="comment"># 没有进行转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">Yes</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> int(choose): <span class="comment"># 进行了转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">No</div></pre></td></tr></table></figure>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Python提供两种循环写法，一种是 <strong><code>for...in...</code></strong> 循环，一种是 <strong><code>while...</code></strong> 循环。for循环依次把list或tuple中的每个元素赋值给目标标识符，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> names:</div><div class="line"><span class="meta">... </span>print(name)</div><div class="line">...</div><div class="line">Michael</div><div class="line">Bob</div><div class="line">Tracy</div></pre></td></tr></table></figure>
<p>当列表为连续数值时，可以用range方法生成，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line"><span class="meta">... </span>sum = sum + x</div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>while循环的写法和if－else很相似，也是在判定条件后面加一个冒号。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">11</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>sum = sum + n</div><div class="line"><span class="meta">... </span>n = n - <span class="number">2</span></div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">11</span></div><div class="line"><span class="number">20</span></div><div class="line"><span class="number">27</span></div><div class="line"><span class="number">32</span></div><div class="line"><span class="number">35</span></div><div class="line"><span class="number">36</span></div></pre></td></tr></table></figure>
<p>另外，对于死循环的程序，可以通过<strong>Ctrl＋C</strong> 强制终止。</p>
<hr>
<p><br></p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li><p>ASCII</p>
<blockquote>
<p>最早的编码，包含大小写英文，数字及一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8位二进制组合(1个字节)，可表示128个不同字符(最高位用于校验)。</p>
</blockquote>
</li>
<li><p>GB2312</p>
<blockquote>
<p>处理中文时一个字节显然不足，至少需要用两个字节，并且不与ASCII冲突，因此有了中国自己制定的GB2312编码，可用于编码中文。</p>
</blockquote>
</li>
<li><p>Shift_JIS和Euc-kr</p>
<blockquote>
<p>日本编码为Shift_JIS，韩文编码为Euc-kr。这样各个国家都用自己不同的标准和编码就很容易在多语言的环境产生冲突，变成乱码。因此又有了通用的一套编码。</p>
</blockquote>
</li>
<li><p>Unicode</p>
<blockquote>
<p>Unicode将所有语言统一到一套编码中，一般使用2个字节，部分非常偏僻的字符会用到4个字节。但是使用Unicode编码，如果在大量英文的环境又非常浪费空间，因为存储和传输时大小是使用ASCII编码的两倍，不划算，于是又有了新的方式。</p>
</blockquote>
</li>
<li><p>UTF-8</p>
<blockquote>
<p>UTF-8是可变长编码，对Unicode字符不同的数字大小编码成1-6个字节，英文字母为1个字节，汉字一般是3个字节。需要用到4-6字节的字符非常少，这样比较节省空间。</p>
</blockquote>
</li>
</ul>
<p><strong>Example</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">ASCII</th>
<th style="text-align:center">Unicode</th>
<th style="text-align:center">UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">01000001</td>
<td style="text-align:center">00000000 01000001</td>
<td style="text-align:center">01000001</td>
</tr>
<tr>
<td style="text-align:center">中</td>
<td style="text-align:center">(超出范围)</td>
<td style="text-align:center">01001110 00101101</td>
<td style="text-align:center">11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
</div>
<h4 id="插播一段课外知识"><a href="#插播一段课外知识" class="headerlink" title="插播一段课外知识"></a>插播一段课外知识</h4><p>摘录整理自知乎提问<a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a>。</p>
<p>为什么要分Unicode和UTF-8，它们两者有什么区别和关联呢？</p>
<p>其实最早的时候，由于各地区使用的编码方式不同，使用不同语言的人交流就成了一个大问题。国际标准组织ISO制订了统一的<strong>通用字符集（Universal Character Set，UCS）</strong>，也<strong>简称为Unicode</strong>。<strong>早期的Unicode版本对应于UCS-2编码方式</strong>，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示 2^16 也即 65536 个字符，基本满足各种语言的使用。根据维基的说法，当前最新版本的Unicode标准收录了128,000个字符，已经远远超出两字节所能表示的65536了。所以<strong>把Unicode视作UCS-2是一种过时的说法，Unicode标准存在多于两字节的字符</strong>。</p>
<p><strong>Unicode有多种字符编码实现方式</strong>。一个Unicode字符的code point是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，<strong>会使用不同的字符编码来实现Unicode</strong>。<strong>这些字符编码统称为Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong>。</p>
<p>例如，对于一个仅包含ASCII字符(只需要7位)的Unicode文件，如果每个字符都使用2字节的<strong>原Unicode编码</strong>传输，其第一字节的首位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用<strong>UTF-8编码，这是一种变长编码，它将ASCII字符仍用7位编码表示，占用一个字节（首位补0）</strong>。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以ASCII字符为主的西文文档就大大节省了编码长度。</p>
<p>但是，<strong>现在所说的Unicode一般都指的是字符集而非编码方式</strong>，廖雪峰老师在教程里提到的Unicode编码实际上指的是UCS-2这种编码方式。又因为以前UCS-2和UTF-16是等价的，所以微软的文档习惯把UTF16称为Unicode，这也导致很多开发者容易对此产生误会。</p>
<p>以上内容虽然有部分针对廖雪峰老师教程中描述不准确的地方进行了修改，但可能还是存在一些让人迷惑的说法，更详细的讲解可以看我的博文<a href="http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%EF%BC%8C%E4%BB%A5%E5%8F%8APython3%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">字符集与编码的恩怨情仇，以及Python3中的编码问题</a>。</p>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><p>在计算机存储中，内存统一使用Unicode编码，而硬盘保存或者传输数据就用UTF-8编码。比方说打开记事本时，数据会从硬盘中UTF-8编码格式转换为Unicode格式，保存时则相反。</p>
<p>浏览网页时，服务器端动态生成的内容是Unicode编码，而传输时则会变为传输UTF-8编码格式的网页。所以常常在网页源码中看到 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的语句，表示该网页正是用的UTF-8编码。</p>
<p><strong>按我的理解，可以这样总结：在传输/储存时，为了节省带宽/空间，会使用UTF-8这样的Unicode字符集的实现方式；而在计算机要处理的时候，应当使用原Unicode编码方式，也即每个字符都是固定两字节，这样字符长度统一更便于操作。</strong></p>
<p>特别注意，在涉及到字节流和字符串转换的程序里，我们<strong>应始终坚持使用UTF-8编码进行转换</strong>，从而避免乱码问题。</p>
<p>另外，代码本身也是文本，所以也有编码相关的问题。在编写Python脚本时，一般会在文件头部加入以下两句注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统则会忽略这个注释；</p>
<p>第二行注释是为了告诉<strong>Python解释器，按照UTF-8编码读取源代码</strong>，否则，如果源代码中有中文的话，就会出现乱码了。</p>
<p>注意，这里<strong>仅仅是声明了读取时采用UTF-8编码，但文件本身的编码不一定是UTF-8</strong>，要确定把代码文件编码为UTF-8格式，我们需要对写代码的IDE/文本编辑器进行相应的设置。廖老师提到，<strong>要确保使用UTF-8 without BOM编码</strong>，<strong>那么BOM和without BOM有什么区别呢？</strong>暂不在此进行讨论。</p>
<p>关于Python3中编码的信息，可以再看看<a href="https://docs.python.org/3/howto/unicode.html#introduction-to-unicode" target="_blank" rel="external">官方文档</a>。</p>
<hr>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><p>Python中，<strong>字符串类型中的每个字符采用的是两字节的Unicode编码</strong>，支持多语言。</p>
<h4 id="ord函数"><a href="#ord函数" class="headerlink" title="ord函数"></a>ord函数</h4><p>ord函数可以<strong>获取字符的十进制整数表示</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</div><div class="line"><span class="number">20013</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'文'</span>)</div><div class="line"><span class="number">25991</span></div></pre></td></tr></table></figure>
<p>注意只能传入<strong>单个字符</strong>。</p>
<h4 id="chr函数"><a href="#chr函数" class="headerlink" title="chr函数"></a>chr函数</h4><p>chr函数可以<strong>将十进制整数转换为Unicode编码下对应的字符</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">20013</span>)</div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</div><div class="line"><span class="string">'文'</span></div></pre></td></tr></table></figure>
<p>此外,如果知道了字符的十进制编码，可以将其转换为十六进制，然后<strong>使用<code>\u</code>转义得到对应的Unicode字符</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">20013</span>)</div><div class="line"><span class="string">'0x4e2d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d'</span></div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">25991</span>)</div><div class="line"><span class="string">'0x6587'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u6587'</span></div><div class="line"><span class="string">'文'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span> <span class="comment"># 多个字符</span></div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<p>补充一下，Unicode编码是多语言的，不仅限于中文和英文，还可以使用多种语言的字符及符号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: ord(<span class="string">'한'</span>) <span class="comment"># 韩语</span></div><div class="line">Out[<span class="number">1</span>]: <span class="number">54620</span></div><div class="line">In [<span class="number">2</span>]: hex(<span class="number">54620</span>)</div><div class="line">Out[<span class="number">2</span>]: <span class="string">'0xd55c'</span></div><div class="line">In [<span class="number">3</span>]: <span class="string">'\ud55c'</span></div><div class="line">Out[<span class="number">3</span>]: <span class="string">'한'</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: ord(<span class="string">'に'</span>) <span class="comment"># 日语</span></div><div class="line">Out[<span class="number">4</span>]: <span class="number">12395</span></div><div class="line">In [<span class="number">5</span>]: hex(<span class="number">12395</span>)</div><div class="line">Out[<span class="number">5</span>]: <span class="string">'0x306b'</span></div><div class="line">In [<span class="number">6</span>]: <span class="string">'\u306b'</span></div><div class="line">Out[<span class="number">6</span>]: <span class="string">'に'</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: ord(<span class="string">'a'</span>) <span class="comment"># 英语</span></div><div class="line">Out[<span class="number">7</span>]: <span class="number">97</span></div><div class="line">In [<span class="number">8</span>]: hex(<span class="number">97</span>)</div><div class="line">Out[<span class="number">8</span>]: <span class="string">'0x61'</span></div><div class="line">In [<span class="number">9</span>]: <span class="string">'\u0061'</span></div><div class="line">Out[<span class="number">9</span>]: <span class="string">'a'</span></div><div class="line"></div><div class="line">In [<span class="number">10</span>]: ord(<span class="string">'1'</span>) <span class="comment"># 数字</span></div><div class="line">Out[<span class="number">10</span>]: <span class="number">49</span></div><div class="line">In [<span class="number">11</span>]: hex(<span class="number">49</span>)</div><div class="line">Out[<span class="number">11</span>]: <span class="string">'0x31'</span></div><div class="line">In [<span class="number">12</span>]: <span class="string">'\u0031'</span></div><div class="line">Out[<span class="number">12</span>]: <span class="string">'1'</span></div><div class="line"></div><div class="line">In [<span class="number">13</span>]: ord(<span class="string">','</span>) <span class="comment"># 符号</span></div><div class="line">Out[<span class="number">13</span>]: <span class="number">44</span></div><div class="line">In [<span class="number">14</span>]: hex(<span class="number">44</span>)</div><div class="line">Out[<span class="number">14</span>]: <span class="string">'0x2c'</span></div><div class="line">In [<span class="number">15</span>]: <span class="string">'\u002c'</span></div><div class="line">Out[<span class="number">15</span>]: <span class="string">','</span></div></pre></td></tr></table></figure>
<p>从以上代码可以看到，这里的Unicode编码中<strong>每个字符都是固定用两字节表示（一个字符用4位16进制数表示，每个16进制数需要4bit，所以一共是4*4 = 16bits = 2bytes）</strong>，<strong>和廖老师教程中所说的若干个字节不一致，是否真的有多于两字节的Unicode字符呢？有待考究。</strong></p>
<h4 id="bytes类型"><a href="#bytes类型" class="headerlink" title="bytes类型"></a>bytes类型</h4><p>因为Python程序执行时，字符串类型是用Unicode编码的，一个字符对应若干字节（<strong>若干字节还是固定两个字节呢？</strong>），要在网络中传输或存储到硬盘中就要把字符串变为bytes类型（<strong>因为传输和存储都是以字节为单位的，所以需要进行转换。又因为要节省资源，所以会使用别的编码方式如utf-8</strong>）。</p>
<p>Python显示bytes类型的数据会用b作前缀，要注意 <strong><code>b&#39;ABC&#39;</code></strong> 和 <strong><code>&#39;ABC&#39;</code></strong> 的差别，尽管内容一样，但前者的每个字符都只占1个字节，而后者在Python中以Unicode进行编码，每个字符占两个字节。也即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x41\x42\x43'</span>  <span class="comment"># bytes类型，每个英文字符占1个字节</span></div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u0041\u0042\u0043'</span> <span class="comment"># Unicode类型，每个英文字符占2个字节，前8bit用0填充</span></div><div class="line"><span class="string">'ABC'</span></div></pre></td></tr></table></figure>
<p>Unicode字符串可以通过 <strong><code>encode()</code></strong> 方法编码为指定的bytes，如ASCII编码，utf-8编码etc，bytes类型的数据如果字符不属于ASCII码的范围，就用 <strong><code>&#39;\x##</code></strong> 的格式表示。 相应地，如果读取字节流的数据，就要用 <strong><code>decode()</code></strong> 方法解码。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<h4 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h4><p><strong>对字符串使用len函数会得到字符的数目</strong>，而<strong>对字节流使用len函数则会得到有多少字节</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>) <span class="comment"># 字符串'中文'包含两个字符</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u4e2d\u6587'</span>) <span class="comment"># 用4个字节表示字符串'中文'</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 字符串'中文'编码为utf-u格式后，占6个字节</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 用6个字节表示字节流'中文'</span></div><div class="line"><span class="number">6</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>) <span class="comment"># 字符串'ABC'包含三个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u0041\u0042\u0043'</span>) <span class="comment"># 用6个字节表示字符串'ABC'</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)) <span class="comment"># 字符串'ABC'编码为ASCII格式后，占3个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\x41\x42\x43'</span>) <span class="comment"># 用3个字节表示字节流'ABC'</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>和C语言类似，Python中使用百分号 <code>％</code> 占位符实现格式化的功能。<code>％s</code>表示用字符串替换，<code>％d</code>，<code>％f</code>，<code>％x</code>分别表示用整数，浮点数和十六进制数替换。其中<code>％s</code>可以将任意数据类型转换为字符串。而<code>％d</code>和<code>％f</code>则可以指定整数和小数部分的位数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的格式化</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %d %f %x'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.200000 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %s可以转换任意数据类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %s %s %s'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.2 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %d可以控制整数部分的位数，不足的位数默认以空格填充</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%4d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'   5'</span></div><div class="line"></div><div class="line"><span class="comment"># 除了用空格填充之外，也可以使用0填充不足的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%04d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'0005'</span></div><div class="line"></div><div class="line"><span class="comment"># %f也可以控制整数和小数部分的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%f - %.2f - %2.2f - %02.2f'</span> % (<span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>)</div><div class="line"><span class="string">'1.200000 - 1.20 - 1.20 - 1.20'</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>只有一个占位符时，后面变量不需要用括号括起。</li>
<li>如果字符串本身包含<code>％</code>，则需要转义，用<code>％％</code>来表示百分号。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %'</span> % <span class="number">7</span> <span class="comment"># 没有转义百分号</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: incomplete format</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span> <span class="comment"># 转义了百分号</span></div><div class="line"><span class="string">'growth rate: 7 %'</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符集与编码的恩怨情仇]]></title>
      <url>http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87/</url>
      <content type="html"><![CDATA[<p>最近在整理Python学习笔记的时候，发现自己一直以来对Unicode的认识和廖雪峰老师在Python3教程中所说的有不一致的地方，抱着求知的态度，查找多方资料后总算是弄明白了，也就整理成了这一篇文章。</p>
<p>编码问题一直以来都是很多程序员的噩梦，有时候好不容易写好一个带着详细注释的代码文件，保存一下再打开就发现注释全都乱码了。自己工作的时候还好，摸索一下弄对编码就好了。但是如果是多人协作或者发布产品时，没有统一好编码就会造成很大的问题，特别是对于来自不同国家使用不同语言的工作人员/用户来说。因此，统一编码是非常重要的，也就有了Unicode的出现。</p>
<p>下文将通过以下顺序进行讲解：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#编码的历史">编码的历史</a></li>
<li><a href="#标准、字符集与编码">标准、字符集与编码</a><ul>
<li><a href="#character-repertoire">Character repertoire</a></li>
<li><a href="#coded-character-set">Coded character set</a></li>
<li><a href="#character-encoding-form">Character encoding form</a></li>
<li><a href="#character-encoding-scheme">Character encoding scheme</a></li>
</ul>
</li>
<li><a href="#带bom和不带bom">带BOM和不带BOM</a></li>
<li><a href="#windows中的编码问题">Windows中的编码问题</a></li>
<li><a href="#python3中的编码问题">Python3中的编码问题</a></li>
<li><a href="#参考与感谢">参考与感谢</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="编码的历史"><a href="#编码的历史" class="headerlink" title="编码的历史"></a>编码的历史</h2><p>首先需要理解一下<strong>为什么要进行编码</strong>。我们知道，对计算机而言，一切信息都不过是01比特串，不同的01组合成不同的比特串从而可以表示不同的信息。但是，对人类来说，我们阅读写作所用的是自然语言，于是就存在着<strong>如何使用01比特串来表示自然语言</strong>这样一个问题。</p>
<p>在计算机中，8个比特（bit）组成1个字节（byte），可以表示256种不同状态。在最早的时候，计算机使用者用的都是英语，于是美国人就设计了<strong>ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）</strong>，它包含了大小写英文，数字，控制码以及其它一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8个比特(也即1个字节)，可表示128个不同字符(最高位留出，用于校验)。这样计算机就能使用不同的字节来表示英文了，显示时GUI工具或者字体渲染器只需要根据字节来显示相应的字母就可以了。</p>
<p>后来随着计算机技术的发展，各个国家都开始使用计算机了，但并不是每个国家都使用英语呀。中华文化博大精深，光是常用汉字就有6000多个，显然处理中文时一个字节是不足够的，至少要用两个字节，并且不能与ASCII冲突，因此就有了中国自己制定的<strong>GB2312标准</strong>（每个字符两字节）。后来由于中文字实在太多了，然后还有一些少数民族使用的文字，于是又相继推出了GBK标准和GB18030标准。</p>
<p>日本和韩国也不例外，日本制定了<strong>Shift_JIS标准</strong>，韩国制定了<strong>Euc-kr标准</strong>。还有很多使用其他语言的国家/地区也纷纷制定了适合自己语言的编码标准。</p>
<p>但是，各个国家都用自己不同的标准和编码，在多语言的环境下就很容易产生冲突，产生乱码。国际标准组织ISO看不下去了，就制定了一套统一的标准：<strong>通用字符集（Universal Character Set，UCS）</strong>，后来发展为俗称的<strong>Unicode标准</strong>，将多种语言文字统一到一套标准中。</p>
<h2 id="标准、字符集与编码"><a href="#标准、字符集与编码" class="headerlink" title="标准、字符集与编码"></a>标准、字符集与编码</h2><p>在查找相关资料的过程中，我发现<strong>标准、字符集、编码这几个概念相当容易被混淆</strong>，甚至不少资深程序员也会说混。在廖雪峰老师的Python3教程中，他所说的Unicode指的是一种编码，而现在我们讨论Unicode的时候，一般是指Unicode字符集，它有多种编码，如UTF-8、UTF-16和UTF-32。那是不是廖雪峰老师所说的是错误的呢？<strong>XXX标准、XXX字符集、XXX编码到底有什么区别呢？</strong></p>
<p>首先呀，像前面一节说到的那样，根据需要会制定出不同的<strong>标准（standard）</strong>。有时候一套标准只涉及到字符集，就称为字符集标准。但是一套标准里面还可能涉及到实现该字符集的一种或多种编码以及其它一些细节。</p>
<p><strong>字符集（character set）</strong>是什么呢？更准确的说，应该称其为<strong>编码字符集coded character set (CCS)</strong>。它定义的是<strong>字符和code point的映射关系</strong>，code point通常是用十六进制表示的整数，比方说Unicode字符集中，使用4位十六进制数的code point <code>0061</code>（十进制的97） 来表示小写字母 <code>a</code>。字符集里的每一条标识包括code point，对应的字符以及一个明确的字符名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061</span><span class="string">'a'</span>; LATIN SMALL LETTER A</div><div class="line"><span class="number">0062</span><span class="string">'b'</span>; LATIN SMALL LETTER B</div><div class="line"><span class="number">0063</span><span class="string">'c'</span>; LATIN SMALL LETTER C</div><div class="line">...</div><div class="line"><span class="number">007</span>B<span class="string">'&#123;'</span>; LEFT CURLY BRACKET</div></pre></td></tr></table></figure>
<p>接下来再说说最难说清楚的<strong>编码、编码方式、编码方案、实现方式、字符编码（character encoding）</strong>，这几个术语经常都会混用，甚至在同一篇文献中的不同地方也常常出现不同的称谓，它们之间或许有一些细微的差别，但是由于中文文献中混用得太多，基本上都被认为是同一样东西了。</p>
<p>那<strong>为什么有时候很难分清标准、字符集、编码这几个概念呢？</strong></p>
<p>其实呀，对于 ASCII、GB2312、Big5、GBK、GB18030 之类的标准来说，基本上一个字符集只对应一种编码。比如 ASCII标准 本身就直接规定了 ASCII字符集 和 ASCII编码；而 GB2312标准 则是一套字符集标准，实际上用 EUC-CN 来编码。GBK 和 GB18030 等也类似。</p>
<p>又因为很多文献中，写作并不严谨，有时就会省略掉 “标准”、”字符集”、”编码”这样的后缀，只使用名称。在提及 ASCII 的时候，实际上指的既可以是 ASCII字符集 又可以是 ASCII编码，还可以是 ASCII标准 这样一个整体；提及 GB2312 时，指的则是 GB2312字符集 和 EUC-CN编码 组合起来的整体。于是呀，很多人受到这些遗留标准的影响，以为字符集和编码是同一回事儿，而无法正确理解字符集和编码的关系。</p>
<p>但是，<strong>对 Unicode标准 来说，字符集和编码是明确区分的</strong>。Wikipedia的Unicode词条是这样说的：</p>
<blockquote>
<p><strong>Unicode</strong> is a computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world’s writing systems. <strong>Developed in conjunction with the Universal Coded Character Set (UCS) standard</strong> and <strong>published as The Unicode Standard.</strong> …… The standard consists of a set of code charts for visual reference, an encoding method and set of standard character encodings, a set of reference data files, and a number of related items, such as character properties, rules for normalization, decomposition, collation, rendering, and bidirectional display order (for the correct display of text containing both right-to-left scripts, such as Arabic and Hebrew, and left-to-right scripts).</p>
</blockquote>
<p>那么这里又产生一个新问题了？<strong>UCS和Unicode的关系是怎样的呢？</strong></p>
<p>最开始的时候，UCS和Unicode是两个不同的标准，由不同的组织提出。Unicode是Unicode联盟进行整理和编码的。和Unicode联盟类似，ISO也做了类似的事情，创造了UCS字符集标准。后来双方意识到世界上并不需要两套通用字符集，于是就开始整合，到了Unicode2.0时，Unicode和UCS的编码（字符集）就基本一致了，所以<strong>粗略来说，可以认为Unicode和UCS是同一样东西，它们是共同发展的</strong>。</p>
<p>但是从细节上来说，UCS中除了字符集，还定义有<strong>UCS-2（曾被称为Unicode，但现在Unicode字符集的范围已经远远超出UCS-2所能表示的，所以UCS-2被废弃了）</strong>、UCS-4等等用于实现UCS字符集的编码；而Unicode标准不但能够使用UCS-2和UCS-4编码，还针对传输/存储定义了另外一些编码，如UTF-8、UTF-16（可以认为是UCS-2的扩展）和UTF-32（可以认为是UCS-4的子集）等等。综上所述，<strong>说 Unicode 是一种编码是带误导性并且不合时的。</strong></p>
<p>再贴一段Wikipedia上的原话：</p>
<blockquote>
<p>Unicode can be implemented by different character encodings. The most commonly used encodings are UTF-8, UTF-16 and the now-obsolete UCS-2.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>Unicode（字符集标准） 可以使用不同的字符编码进行实现。 最常用的编码（方式）有UTF-8，UTF-16以及现在已经废弃了的UCS-2。</p>
</blockquote>
<p>最后再总结一下几个概念吧：</p>
<h3 id="Character-repertoire"><a href="#Character-repertoire" class="headerlink" title="Character repertoire"></a>Character repertoire</h3><p>字符集，是一个系统所能支持的所有抽象字符（包含一种或多种语言以及使用的标点符号）的集合。它有可能是闭合的，比如ASCII标准的字符集，只包含西文字符和符号等等；也可能是开放的，比如Unicode标准的字符集，可以允许继续添加新的字符。</p>
<h3 id="Coded-character-set"><a href="#Coded-character-set" class="headerlink" title="Coded character set"></a>Coded character set</h3><p>编码字符集，是一个把字符映射为code point的函数，每个code point对应一个字符。比方说给定一个Character repertoire，拉丁字母中的大写字母A可以被表示为65这个code point。多个编码字符集可能使用同一个Character repertoire，但采用不同的映射方式。</p>
<h3 id="Character-encoding-form"><a href="#Character-encoding-form" class="headerlink" title="Character encoding form"></a>Character encoding form</h3><p>字符编码方式，是code point和一个/多个code unit之间的映射。比方说一个使用16 bit code unit来存储信息的系统，它的一个code unit最多能表示0~65535，对于code point小于等于65535的字符，一个code unit就能存储了，而code point大于65535的字符则需要使用多个code unit来存储。</p>
<h3 id="Character-encoding-scheme"><a href="#Character-encoding-scheme" class="headerlink" title="Character encoding scheme"></a>Character encoding scheme</h3><p>字符编码方案，是code unit和octets序列之间的映射。在传统的二进制数字概念中，1 byte（字节）=8 bit（位）。<strong>大多数因特网标准使用octet（八位组）这个术语而不是使用字节来表示8 bit</strong>。该术语起始于TCP/IP发展的早期，当时许多早期的工作是在诸如DEC－10这样的系统上进行的，然而这些系统的结构使用的字节(byte)长度是10位（bit）,因此出现了octet的单位，即准确定义 1 octet = 8 bit。字符编码方案包括UTF-8、UTF-16等等。</p>
<p>所以呀，从这里可以看出<strong>编码方式和编码方案还是有那么一些区别的</strong>，我们知道英文字母只需要8 bit就能存储了，如果都采用16 bit的code unit来存就会造成很大的浪费。正因为这样，所以又有了编码方案，在存储/传输的实现上进行改变，从而节省空间/带宽。但是混用得实在太多了，也就很难再分清了。</p>
<h2 id="带BOM和不带BOM"><a href="#带BOM和不带BOM" class="headerlink" title="带BOM和不带BOM"></a>带BOM和不带BOM</h2><p>先贴一段wikipedia的原文：</p>
<blockquote>
<p>The byte order mark (BOM) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), whose appearance as a magic number at the start of a text stream can signal several things to a program consuming the text:</p>
</blockquote>
<ul>
<li><blockquote>
<p>What byte order, or endianness, the text stream is stored in;</p>
</blockquote>
</li>
<li><blockquote>
<p>The fact that the text stream is Unicode, to a high level of confidence;</p>
</blockquote>
</li>
<li><blockquote>
<p>Which of several Unicode encodings that text stream is encoded as.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>BOM use is optional, and, if used, should appear at the start of the text stream.</p>
</blockquote>
<p>BOM其实就是用来标示Unicode纯文本字节流用的是哪一种编码，它设计出来不是用来支持HTML和XML的。要识别文本的编码，HTML可以使用charset属性，XML可以使用encoding属性，没必要使用BOM。使用BOM主要是微软的习惯，UNIX系统是不鸟BOM的。</p>
<p>有一个最主要的原因是，在UNIX系统中，所有脚本语言通用的首行 <code>#!</code> 标示依赖于shell解析，而很多shell出于兼容的考虑是不检测BOM的。因此在文本开头加入BOM时，shell会把它解释为某个普通字符，从而破坏了 <code>#!</code> 标示。另外还有一点就是，BOM本身违反了一个UNIX设计的常见原则，就是文档中存在的数据必须可见，而BOM不能作为可见字符被文本编辑器编辑。</p>
<p>注意，我们<strong>在使用文件编辑器保存文本文件时，应当保存为UTF-8 without BOM的格式</strong>，在UTF-8文件中放置 BOM 主要是微软的习惯。BOM是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。</p>
<h2 id="Windows中的编码问题"><a href="#Windows中的编码问题" class="headerlink" title="Windows中的编码问题"></a>Windows中的编码问题</h2><p>这一节所说的Windows中的编码，主要是指Windows自带的文本编辑器-记事本中的语境。</p>
<p>在记事本中：</p>
<ul>
<li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码[1]。</li>
<li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16[2]。</li>
<li>所谓的「UTF-8」指的是带 BOM 的 UTF-8[3]。</li>
</ul>
<p><strong>标注</strong></p>
<ul>
<li><p>[1] Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。</p>
</li>
<li><p>[2] 把带有 BOM 的小端序 UTF-16（即UTF-16LE）称作「Unicode」也是 Windows 的臭毛病。Windows 从 Windows 2000 开始就已经支持 surrogate pair 了，所以已经是 UTF-16 了，「UCS-2」这个说法已经不合适了。UCS-2 只能编码 BMP 范围内的字符，从 1996 年起就在 Unicode/ISO 标准中被 UTF-16 取代了（UTF-16 通过蛋疼的 surrogate pair 来编码超出 BMP 的字符）。都十多年了，求求大家别再误称了……</p>
</li>
<li><p>[3] 把带 BOM 的 UTF-8 称作「UTF-8」又是 Windows 的臭毛病。如果忽略 BOM，那么在 ASCII 范围内与 ASCII 一致。</p>
</li>
</ul>
<h2 id="Python3中的编码问题"><a href="#Python3中的编码问题" class="headerlink" title="Python3中的编码问题"></a>Python3中的编码问题</h2><p>廖雪峰老师说Python3中字符串使用Unicode编码，但正如我们前面所说的，现在说Unicode是一种编码是不合时的，准确来说，Python3中字符串用的是严格使用两个字节的UCS-2编码，即使是英文字母也使用两个字节。</p>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><p><strong>廖雪峰-Python3教程</strong></p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="external">字符串和编码</a></li>
</ul>
<p><strong>Python官方文档</strong></p>
<ul>
<li><a href="https://docs.python.org/3/c-api/unicode.html" target="_blank" rel="external">Unicode Objects and Codecs</a></li>
<li><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="external">Unicode HOWTO</a></li>
</ul>
<p><strong>知乎</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？</a></li>
<li><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">Unicode 和 UTF-8 有何区别？</a></li>
<li><a href="https://www.zhihu.com/question/20167122" target="_blank" rel="external">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a></li>
<li><a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a></li>
</ul>
<p><strong>Wikipedia</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Wide_character" target="_blank" rel="external">Wide character</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode#Mapping_and_encodings" target="_blank" rel="external">Unicode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Byte_order_mark" target="_blank" rel="external">Byte order mark</a></li>
<li><a href="https://en.wikipedia.org/wiki/Character_encoding#Code_unit" target="_blank" rel="external">Character encoding</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="external">Universal Coded Character Set</a></li>
</ul>
<p>最后，特别感谢知乎用户<a href="https://www.zhihu.com/people/lianghai" target="_blank" rel="external">梁海</a>、<a href="https://www.zhihu.com/people/chen-fu-zhou" target="_blank" rel="external">陈甫鸼</a>和<a href="https://www.zhihu.com/people/yu-yang-31-64" target="_blank" rel="external">于洋</a>，他们的回答都对我构建这篇文章很有帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何处理Hexo和MathJax的兼容问题]]></title>
      <url>http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天写文章写得正高兴，码Latex公式的时候突然发现无法渲染，经过一番推敲和实践，最终解决了这个问题，在这篇博文中简单记录一下，方便其他遇到同样问题的朋友们也能顺利解决。<strong>不想看解决思路的朋友也可以<a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#小结">跳到文章末尾直接看解决方案（Jump to the end to see sulution）</a></strong>。</p>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>先重现一下这个问题。在写文章的时候，我码了一个相当简单的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$$</div></pre></td></tr></table></figure>
<p>渲染出来却变成了（红框内变为了斜体）：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer1.png" alt="before"></p>
<a id="more"></a>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>琢磨了一下，MathJax支持是开了的，这么简单的公式都渲染不出，肯定不是MathJax要背的锅。简单地测试了一下，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125;$$</div></pre></td></tr></table></figure>
<p>这个公式是能work的，那到底是什么问题呢？回到前面的公式，细心观察一下，不难发现渲染之后<strong>下划线 <code>_</code> 被吞掉了</strong>，而<strong>两个下划线 <code>_</code> 之间的文本变为了斜体</strong>，这就很有意思了。</p>
<p>浏览一下网页源码，可以看到对应这一条公式的代码是：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer2.png" alt="before"></p>
<p>原来下划线被渲染成了 <code>&lt;em&gt;</code>，在HTML里这个tag是用于将文本准换为斜体进行强调的。为什么会产生这样的错误呢？其实，在Markdown语法中 <em>两个下划线之间的文本会被转换为斜体</em>，所以<strong>这个错误是由Markdown渲染器引起的</strong>。Markdown本身没有支持Latex，在渲染时正则匹配到两条下划线就会把下划线替换成了 <code>&lt;em&gt;</code>，于是到了MathJax渲染公式时就彻底懵了。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>意识到这个问题的本质后，带着疑问，我先来到Next主题的<a href="https://github.com/iissnan/hexo-theme-next/" target="_blank" rel="external">Github主页</a>，在<a href="https://github.com/iissnan/hexo-theme-next/issues?utf8=%E2%9C%93&amp;q=mathjax" target="_blank" rel="external">issue</a>里面搜索MathJax。很可惜，没有找到直接的答案，但是思路清晰了一些。<strong>Next不背这个锅</strong>，我们要做的是<strong>更换Hexo使用的Markdown渲染器</strong>。</p>
<p>接下来我又到Hexo的<a href="https://github.com/hexojs/hexo/" target="_blank" rel="external">Github主页</a>搜索相关的解决方案，在<a href="https://github.com/hexojs/hexo/issues/524" target="_blank" rel="external">issue #524</a> 中，有人提到了<strong>可以使用 rawblock 来解决</strong>，可是每次要写公式都得在公式前后加上 rawblock 来声明实在太烦了，对于公式大户来说简直要崩溃（想想之后要写机器学习的相关文章，一大堆公式证明，已经想手动再见了）。</p>
<p>另一个提出的解决方案是<strong>更换pandoc渲染器</strong>，pandoc大法固然好，但要下载安装完pandoc然后再装hexo插件实在是太重量级了.. 我只是想轻松愉悦地写写博客呀。当然，感兴趣的朋友也不妨去<a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="external">hexo-renderer-pandoc主页</a>看看。</p>
<p>有没有更好的方法呢？我在<a href="https://segmentfault.com/q/1010000003987383/a-1020000003987577/revision" target="_blank" rel="external">segmentfault</a>查到另一位朋友写的解决方案，可以<strong>使用 hexo-renderer-markdown-it 进行渲染</strong>，似乎是个不错的思路，在hexo-renderer-markdown-it的<a href="https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started" target="_blank" rel="external">文档</a>中可以看到操作相当简单：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-markdown-it --save</code></li>
</ol>
<p>两行命令即可完成，先卸载Hexo自带的Markdown解析器 hexo-renderer-marked 再安装 hexo-renderer-markdown-it 就可以了。安装完以后，先 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态网页，然后 <code>hexo s</code> 查看，这回公式能正常显示了：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/After_Change_Markdown_Renderer1.png" alt="after"></p>
<p>但是这是我又发现一个新的问题，使用 hexo-renderer-markdown-it 渲染之后，我原本为Markdown编写的<strong>TOC里的链接都失效了</strong>，而<strong>侧边栏的快速导航链接也都失效了</strong>。这怎么可以呢？文章写得短还好，鼠标滚轮滚一滚就好了。要是写得长那岂不就得浪费很多时间才能定位到自己想看的地方？这可不行！！！</p>
<p>继续查找更优的解决方案，Hexo有没有更好的Markdown渲染插件呢？有的，在<a href="https://hexo.io/plugins/" target="_blank" rel="external">Hexo主站的插件页</a>搜索关键字 Markdown，发现了 hexo-renderer-kramed 这个插件，打开它的<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">Github主页</a>，描述已经说得很清楚，作者fork了 hexo-renderer-marked 项目，并且只针对MathJax支持进行了改进，这正是我们需要的！！卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），然后安装 hexo-renderer-kramed：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>这下，不仅能正常使用TOC，也能完美地支持MathJax渲染了。至此，问题得到了解决。</p>
<p>P.S. 其实，这个问题就是因为Markdown渲染和MathJax渲染冲突造成的，除了换别的渲染器，<strong>直接修改渲染用的正则表达式</strong>也是一种解决思路，但是这个思路有一定风险，如果引起了别的bug而没有及时发现，自己又没有做好备份和记录，就需要浪费很多额外的时间来定位问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单来说，要让你的Hexo支持MathJax渲染公式，你只需要使用两条命令：<br>To fully support MathJax in your Hexo blog, you can simply use the following commands:</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>第一条命令用于卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），它是hexo自带的Markdown渲染引擎。<br>The first command uninstall Hexo’s default Markdown renderer.</p>
<p>第二条命令用于安装 hexo-renderer-kramed 插件，这个渲染插件针对MathJax支持进行了改进。安装完成后，重新生成博客就会惊喜地发现你的公式已经能够正常显示了。<br>The second command install new Markdown renderer which can support MathJax fully. After installation, you should regenerate your blog to see the changes.</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>作为一名编程人员，不屈服于bug，不妥协于简陋的solution是很重要的。除此之外，也要善于定位问题和解决问题，能够弄清楚出问题的地方，并且利用丰富的网络资源来解决问题。</p>
<p>最后，感谢开源和分享。</p>
<p>最后的最后，再码一条写在SVM笔记里的长公式检验一下吧：</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad  i=1,2,...,m\qquad(9)</script><p>完美~ The end.</p>
<hr>
<p><strong>备注</strong></p>
<p>补充一下评论中L同学的问题，关于行内代码，确实还存在一点问题，之后有时间会再研究一下。</p>
<ul>
<li>首先，我们希望行内公式可以用两个 <code>$</code> 符标识；</li>
<li>而当我们使用的行内代码中出现两个 <code>$</code> 符时，它们之间的内容不应被转义为Latex公式，而是应该按原来的内容展示；</li>
<li>同理，在代码块中出现两个 <code>$</code> 符时，我们也不希望它们之间的内容不应被转义为Latex公式。</li>
</ul>
<p><strong>行内公式</strong>： $R<em>{m \times n} = U</em>{m \times m} S<em>{m \times n} V</em>{n \times n}’$</p>
<p><strong>包含两个 $ 的行内代码</strong>： <script type="math/tex">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'</script></p>
<p><strong>行间公式</strong>：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'</script><p><strong>包含两个 $ 的代码块</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$</div></pre></td></tr></table></figure>
<p>这里可以看到行内公式和行内代码的渲染确实有问题，这是因为kramed对行内公式的实现就是基于行内代码来做的，也就是说，对于kramed而言，<strong>出现 ` 符以后的两个 <code>$</code> 符之间的部分才会被kramed认为是行内公式（注意，即使没有用两个 ` 符括起来也会被匹配成行内公式，相当容易出bug）</strong>，要解决这个问题需要修改kramed的渲染机制。而在代码块中这种情况是没问题的，因为kramed里面对行内公式和行间公式的实现机制不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用推荐算法]]></title>
      <url>http://2wildkids.com/2016/10/04/%E5%B8%B8%E7%94%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这篇<a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247483811&amp;idx=1&amp;sn=fc3ee4ddfc4a8d6014a4cd90cdb5983c&amp;scene=4#wechat_redirect" target="_blank" rel="external">文章</a>首发在【阿里技术】这个微信公众号，内容上主要围绕电商中用到的一些推荐算法，参考了 Xavier Amatriain 在CMU的 Machine Learning 暑期学校上的讲授的内容。不仅有提到一些基础的推荐算法，也讲了一些推荐系统领域比较新的研究方向，个人认为是一篇不错的概括性文章，摘录在博客里，加入一点自己的理解。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC -->
<ul>
<li><a href="#推荐系统简介">推荐系统简介</a></li>
<li><a href="#传统的推荐算法">传统的推荐算法</a><ul>
<li><a href="#非个性化推荐：热度排行（popularity）">非个性化推荐：热度排行（Popularity）</a></li>
<li><a href="#协同过滤（collaborative-filtering）">协同过滤（Collaborative Filtering）</a></li>
<li><a href="#基于内容知识的推荐（content-basedknowledge-based）">基于内容/知识的推荐（Content-based/Knowledge-based）</a></li>
<li><a href="#混合方法（hybird-approaches）">混合方法（Hybird Approaches）</a></li>
</ul>
</li>
<li><a href="#推荐算法的最新研究">推荐算法的最新研究</a><ul>
<li><a href="#学习排序（learning-to-rank）">学习排序（Learning to Rank）</a></li>
<li><a href="#页面整体优化（page-optimization）">页面整体优化（Page Optimization）</a></li>
<li><a href="#情景推荐：张量分解分解机（factoriztion-machine）">情景推荐：张量分解/分解机（Factoriztion Machine）</a></li>
<li><a href="#深度学习（deep-learning）">深度学习（Deep Learning）</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image2.jpeg" alt="g2"></p>
<p>推荐系统本身就是为了解决信息过载这个问题而出现的，在互联网出现以后，人们在生活中所能获取到的消息呈爆炸性增长。从衣食住行再到其他一些更高端的需求，我们都有非常多的选择，但是要怎么在较短的时间内从这么多的选择里找到自己最感兴趣的那个呢？推荐系统解决的就是这样一个问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image3.jpeg" alt="g3"></p>
<p>事实上，<strong>解决信息过载的问题并不是只有推荐系统这一个手段</strong>。PC时代早期出现的门户网站是一种手段，帮助上网的人快速找到想要浏览的网站。而搜索引擎也是一种很好的办法，通过关键字来筛选出用户想要看的网页。但以上两种途径展示的内容对任意两个上网用户来说都是相同的。由于每个人的喜好总会有一部分和别人重叠，而一部分比较特殊，为了展示的内容能尽可能符合大多数人的期望，导航/搜索引擎只能给出重叠最多的部分，也即最流行的网站/网页，没有办法做到根据不同用户的喜好提供不同结果。推荐系统则致力于解决这一难点，实现千人千面的效果。</p>
<p>P.S. 事实上，目前在搜索引擎这个研究领域，已经有根据用户搜索习惯和搜索历史进行个性化结果展示的研究了，可以说是吸取了推荐系统的精髓进行改进的结果吧。随着计算机处理数据的能力上升，个性化将是未来的必然趋势。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image4.jpeg" alt="g4"></p>
<p>Netflix举办的百万美元竞赛绝对是推荐系统发展史上一个重要的标志，可以说从那以后，推荐系统的研究才开始真正地被重视，随后就是百花齐放，越来越多的算法和推荐架构被提出来了。</p>
<p>特别Mark一下<strong>推荐系统的未来——基于上下文的推荐</strong>，这个确实是很值得思考的。尽管目前关注推荐系统的研究已经不少了，但绝大部分都是使用协同过滤技术，或者把推荐视作一个二分类问题来解决的。有一个很明显的缺点就是它们都需要大量的标记数据才能实现准确的预测。还有一个问题就是，这里说的推荐并没有针对用户实际所处的环境来给出结果，只是从用户的历史记录和习惯来推测，给出他可能喜欢的其它商品，而<strong>没有关注用户是否真的有需求</strong>。<strong>怎么把我们从大量历史数据中学习到的知识应用到用户所处的具体场景中？</strong>这是一个等待研究的相当有价值的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image5.jpeg" alt="g5"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image6.jpeg" alt="g6"></p>
<p>这些指标都蛮有意思的，但是并不是都能通过离线测试来得出，比方说用户满意度、惊喜性等等，都是一些比较主观的东西，在这种情况下，怎么能够提高这些指标呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image7.jpeg" alt="g7"></p>
<p>这里列了几个比较传统的因素：相似的人越喜欢一件物品，那么用户就越有可能也喜欢它；用户对相似的物品越喜爱，那么也越有可能喜欢这一件物品；对这件物品的评论中赞赏的话越多，则用户也越有可能对这件物品感兴趣；用户和这件物品的历史交互行为越多，也意味着用户对这件物品越感兴趣…</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image8.jpeg" alt="g8"></p>
<p>虽然说我们做研究主要是针对推荐的算法，但在工业界里，一个真正的推荐产品，必须要有良好的用户界面，准确的产品定位，否则从一开始就输了，连用户数据都获取不到，自然也就没有所谓个性化的后话了。特别地，花在处理数据上的时间应该是最多的，因为从真实场景中收集到的数据往往都有很大的噪音，如果不经过处理就放进算法跑的话，算法再好也难以获得好的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image9.jpeg" alt="g9"></p>
<h2 id="传统的推荐算法"><a href="#传统的推荐算法" class="headerlink" title="传统的推荐算法"></a>传统的推荐算法</h2><h3 id="非个性化推荐：热度排行（Popularity）"><a href="#非个性化推荐：热度排行（Popularity）" class="headerlink" title="非个性化推荐：热度排行（Popularity）"></a>非个性化推荐：热度排行（Popularity）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image10.jpeg" alt="g10"></p>
<p>其实在没有电商的时候，传统的线下店铺就是采用热度排行的方式来增加销量的，因为能展示给客户的商品有限，所以只能选最热门的商品放在店铺里。</p>
<p>虽然这种做法可以避免新用户的冷启动窘境，因为我们不需要知道新用户是怎样的，只要知道大的趋势就可以了。但这样做对新的商品来说显然是致命的，因为热门的商品被展示得越多就越热门，长期占据热度榜，而新商品得不到被展示的机会，就只能烂在仓库里了。这个问题也被称为<strong>马太效应（The Matthew Effect）</strong>。</p>
<p>比较有意思的是这里指出除了单纯地考虑热度，<strong>在基于热度排行时还可以综合考虑一些其它因素</strong>。事实上，即使是如此强调个性化的今天，热度依然是影响用户做出购买决定的一个很重要的因素，所以在构建推荐系统时也要充分考虑到这一点。</p>
<h3 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h3><h4 id="Memory-based-方法"><a href="#Memory-based-方法" class="headerlink" title="Memory-based 方法"></a>Memory-based 方法</h4><p>Memory-based 方法又可以称为 <strong>neighborhood-based方法</strong>。可以简单分为User-based CF和Item-based CF两种思路。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image11.jpeg" alt="g11"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image12.jpeg" alt="g12"></p>
<p>注意一下Step3过滤这个步骤，比方说用户已经买过某一本书，如果再推荐他重复购买是不合理的。但是，对于一些可能会周期性购买的物品（如抽纸、沐浴露etc），我们要怎么处理呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image13.jpeg" alt="g13"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image14.jpeg" alt="g14"></p>
<p>可以说各有各好处吧，Item-based更流行除了准确性好之外，物品的变动相对用户较少也是一个很大的原因，这能够减少很多计算花费。但是相对地，Item-based可能没有办法很好地承担<strong>开拓用户的眼界</strong>这个功能，是不是真的这样呢？值得思考。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image15.jpeg" alt="g15"></p>
<p>这里提到的缺点是需要注意的，但<strong>并不是说协同过滤就必定有这些缺点</strong>，我们可以针对这些缺点对协同过滤进行改良。这里记录一下一些简单的思路：</p>
<ul>
<li><p>冷启动问题怎么解决呢？是否可以引入一些领域知识？或者引入额外的数据来源（社交、地点、时间etc）呢？如果引入了，又该怎么使用呢？</p>
</li>
<li><p>过去的行为真的决定现在吗？过去的行为有哪些特征是可以视为用户的特征的呢？有哪些特征可能只是干扰因素呢？</p>
</li>
<li><p>怎么才能引入小众偏好，让推荐系统更强调个性化呢？</p>
</li>
</ul>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image16.jpeg" alt="g16"></p>
<p>LSH是一个相当有意思的减少计算量的方法。协同过滤的一个最基本步骤就是计算相似性，而无论从用户的角度还是从物品的角度来看，维度都相当高，计算花费很大。而使用LSH进行映射后，既能保持相似关系不会发生太大的变化，又能降低维度，确实是一种很好的解决方案。不过<strong>要特别注意哈希函数的选择</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image17.jpeg" alt="g17"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image18.jpeg" alt="g18"></p>
<h4 id="Model-based方法"><a href="#Model-based方法" class="headerlink" title="Model-based方法"></a>Model-based方法</h4><p>基于模型的方法，用到的技术就比较多涉及到机器学习领域了。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image19.jpeg" alt="g19"></p>
<h5 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image20.jpeg" alt="g20"></p>
<p>关联规则挖掘其实跟买东西的场景是非常搭的，有兴趣的朋友不妨查查 “啤酒与尿布” 这个经典案例。</p>
<p>值得注意的是：我们<strong>从结果反推出的 “现象” 并不一定是事实</strong>，这其中有可能存在巧合的因素，所以我们一定要慎重地对待。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image21.jpeg" alt="g21"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image22.jpeg" alt="g22"></p>
<p>Mark一下这里产生悖论的原因：<strong>数据的不同分组之间基数差异很大</strong>，导致合并时产生了偏差。用上面的例子来说就是对顾客分组是，在职人员的数量要远多于大学生的数量，在把这两个分组合并为顾客来考虑时就会产生偏差。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image23.jpeg" alt="g23"></p>
<h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image24.jpeg" alt="g24"></p>
<p>事实上，我们并不一定要在同一个簇里面找推荐物品的候选集，完全可以基于簇之间来使用KNN，把最近邻的簇对应的物品集作为候选，这样做就有一定概率引入一些额外的物品，给用户带来惊喜了。当然，如何平衡好这一点和推荐的准确性是需要研究的。</p>
<h5 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image25.jpeg" alt="g25"></p>
<p>比方说把推荐看作一个二分类问题，预测用户是否购买/点击；把推荐看作一个回归问题，预测用户对推荐物品的评分。这样来看的话，很多有监督学习的机器学习技术都能被用上了。但是，如何获得大量独立同分布的训练数据会是一个很大的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image26.jpeg" alt="g26"></p>
<ul>
<li>如何应对评分矩阵的稀疏性？ —— 现实问题，用户接触到的商品仅占非常小的一部分，会进行反馈的就更少了</li>
<li>如何降低大规模矩阵计算的时间开销？ —— 决定能否满足实时性的需求</li>
</ul>
<p>图片中的两条式子可能有些模糊，它们分别是是：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}' \qquad(1)</script><p>和</p>
<script type="math/tex; mode=display">R_{m \times n} \approx U_{m \times k} S_{k \times k} V_{k \times n}' \qquad(2)</script><p>式（1）是标准的SVD矩阵分解，式（2）则是<strong>利用SVD技术进行低阶近似</strong>，也称为<strong>截断SVD（Truncated SVD）</strong>，它只取最大的k个奇异值，而k要远小于原矩阵的行数m和列数n，因此能够大大地降低计算开销。由于篇幅原因，这里就不科普SVD相关的知识了，详细内容可以check一下<a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank" rel="external">维基百科里对SVD的描述</a>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image27.jpeg" alt="g27"></p>
<p>Funk提出的这种矩阵分解算法在很大程度上弥补了标准SVD的不足，它不需要关注缺失值，而且计算复杂度也降低了很多。这种矩阵分解方法后来被Netflix Prize的冠军Koren称为<strong>Latent Factor Model（简称LFM）</strong>，也即后来大名鼎鼎的<strong>隐语义模型</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image28.jpeg" alt="g28"></p>
<p>加入偏置项是一种很直觉的想法，举一个简单的例子，对商品要求较高的用户通常会给出较低的评分，所以在满意程度同等时，他给出的评分可能比其他用户都要低。如果我们不排除这个影响的话，他的评分就会错误地拉低了商品的评价。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image29.jpeg" alt="g29"></p>
<p>更进一步地，我们还可以考虑用户的历史行为对评分的影响。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image30.jpeg" alt="g30"></p>
<p>向量化可以理解为对原事物表现形式的改变，不仅仅用于推荐系统领域，也是很多其他研究领域的基础。比方说自然语言处理，要理解对话，就先就要把对话的句子进行向量化，将句子分解为不同的单词，每个单词对应一个维度（最近Google翻译已经改进为以句子为单元了，使得翻译更加准确，不过由于我没有进行过自然语言处理相关的研究，所以不太清楚具体的情况）。</p>
<h5 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image31.jpeg" alt="g31"></p>
<p>Boltzmann机是全连接的一个网络，参数相当多，即使去除同同一层内的连接，变为RBM，参数依然很多。参数越多，自然拟合的能力就越强，所以RBM可以说是浅层学习（相对于深度学习的一个概念，毕竟RBM就只有两层神经元）中非常强大的一个模型。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image32.jpeg" alt="g32"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image33.jpeg" alt="g33"></p>
<p>Mark一下，<strong>一个用户一个RBM</strong>，也即为每个用户都训练一个RBM模型，这样开销固然很大，但私以为这样做要比协同过滤更加符合<strong>个性化</strong>的需求。除了开销大之外，这种方法还需要海量的训练数据，否则无法得到可以接受的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image34.jpeg" alt="g34"></p>
<p>自从深度学习火了之后，越来越多的研究者开始对其进行研究。在推荐系统领域也不例外，虽然RBM并不算“深”，但是可以帮助我们理解深度学习技术是如何应用到推荐系统领域的。我个人还不是太过了解深度学习，上面的PPT也不是讲得讲得很清楚（在推荐系统问题中应用的RBM是改良过的）。感兴趣的朋友不妨阅读一下腾讯数字音乐部智能推荐组编写的文章——<strong><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=417547354&amp;idx=1&amp;sn=1cda80702cff4f9d0f739f75d30eb773" target="_blank" rel="external">解密深度学习在智能推荐系统的实践与应用</a></strong>。</p>
<h5 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image35.jpeg" alt="g35"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image36.jpeg" alt="g36"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image37.jpeg" alt="g37"></p>
<p>Mark一下：<strong>图模型可以发现协同过滤发现不来的弱相似性，给推荐带来一定的惊喜。</strong></p>
<h3 id="基于内容-知识的推荐（Content-based-Knowledge-based）"><a href="#基于内容-知识的推荐（Content-based-Knowledge-based）" class="headerlink" title="基于内容/知识的推荐（Content-based/Knowledge-based）"></a>基于内容/知识的推荐（Content-based/Knowledge-based）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image38.jpeg" alt="g38"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image39.jpeg" alt="g39"></p>
<h3 id="混合方法（Hybird-Approaches）"><a href="#混合方法（Hybird-Approaches）" class="headerlink" title="混合方法（Hybird Approaches）"></a>混合方法（Hybird Approaches）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image40.jpeg" alt="g40"></p>
<p>所谓混合方法，指的是将多个算法集成在一起来完成任务，更详细的讲解可以查询集成学习相关的内容了解。</p>
<h2 id="推荐算法的最新研究"><a href="#推荐算法的最新研究" class="headerlink" title="推荐算法的最新研究"></a>推荐算法的最新研究</h2><h3 id="学习排序（Learning-to-Rank）"><a href="#学习排序（Learning-to-Rank）" class="headerlink" title="学习排序（Learning to Rank）"></a>学习排序（Learning to Rank）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image41.jpeg" alt="g41"></p>
<p>对NDCG和MRR这两种排序评价准则感兴趣的朋友可以浏览<a href="http://www.cnblogs.com/startover/archive/2013/06/18/3141616.html" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="页面整体优化（Page-Optimization）"><a href="#页面整体优化（Page-Optimization）" class="headerlink" title="页面整体优化（Page Optimization）"></a>页面整体优化（Page Optimization）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image42.jpeg" alt="g42"></p>
<h3 id="情景推荐：张量分解-分解机（Factoriztion-Machine）"><a href="#情景推荐：张量分解-分解机（Factoriztion-Machine）" class="headerlink" title="情景推荐：张量分解/分解机（Factoriztion Machine）"></a>情景推荐：张量分解/分解机（Factoriztion Machine）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image43.jpeg" alt="g43"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image44.jpeg" alt="g44"></p>
<h3 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image45.jpeg" alt="g45"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image46.jpeg" alt="g46"></p>
<p>Mark一下：<strong>仅仅利用行为数据的RNN可能效果有限，可以结合更多数据来源。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image47.jpeg" alt="g47"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image48.jpeg" alt="g48"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image49.jpeg" alt="g49"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction]]></title>
      <url>http://2wildkids.com/2016/10/03/Introduction/</url>
      <content type="html"><![CDATA[<p>自从知道了Github Pages和Hexo这对绝佳搭配之后，一直心心念念地想做一个自己的独立博客。虽然从阅读量来说，肯定还是在CSDN、简书或者知乎专栏发布会有更多被阅读的机会，但总感觉或多或少地有些阻碍，不能随心所欲地写作。之前倒是一直把Github当作一个博客，天天把markdown写的笔记contribute到仓库里面，不过鉴于Github支持的是源生的markdown，而markdown本身是不支持latex公式的，所以多少有点遗憾。Anyway，终于用Github Pages+Hexo搭建了这个博客，有MathJax和七牛图床的支持，终于可以随心所欲地写作了~</p>
<p>鉴于大四一直在忙自己的项目和论文，所以少有时间做些真正原创的技术分享，前期主要打算在这个博客做一些阅读笔记。暑假一直在读周志华博士写的《机器学习》一书，把本科生课程部分（书的前半部分）的笔记基本都整理好了，放在了Github上面，但这显然是不够的，想做研究当然还是得往更深的技术里钻，所以书的后半部分还要继续细读精读。另一方面，这本书比较新，所以习题部分目前网上还没有比较好的解答。书中的公式有些比较复杂，对工程人员来说理解可能有不少困难，所以我也希望可以用课余的时间认真地把这本书的习题过一遍，如何对公式进行向量化，如何融入到实际的项目中，用代码进行实现。希望可以分享出来，为开源做点贡献，为其他书友带来一点帮助，自己应该也会有不少的收获。之后会逐渐把笔记和解答迁移到这个博客里，需要花费的时间也比较多，不过贵在坚持。</p>
<a id="more"></a>
<p>因为个人研究方向主攻数据挖掘的推荐系统领域，所以阅读的书籍和文章也比较多涉及这个方面。而中文书籍中，个人认为推荐系统领域最好的一本入门书籍是项亮的《推荐系统实践》，之后也会在这个博客中更新阅读这本书的笔记。另外也会搬运一些机器学习和数据挖掘比较好的文章到这个博客中，加入一些自己的理解，算是记录自己成长的轨迹吧，虽然不是技术原创，但在阅读和学习的过程中，记录下自己的见解，以后再看也会有很大的帮助。</p>
<p>另外，我个人也非常喜欢Python这门编程语言，在数据科学方面的研究中，Python是一个不可多得的利器，所以要是遇到好的Python相关的文章，也会收录到这个博客中。再有就是linux和Hadoop、Spark方面的一些笔记了，要做大数据总是免不了碰到这些东西。虽然工具年年变，说不定以后Spark就不像现在这么火了，但是好的工具总是有研究价值的，好好学的话还是会有不错的收获。</p>
<p>最后，也是一点小寄望吧，希望以后可以能逐渐有多一些技术原创，多一些项目分享，目前就先脚踏实地地积累知识吧。</p>
<p>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://2wildkids.com/2016/09/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Test-MathJAX"><a href="#Test-MathJAX" class="headerlink" title="Test MathJAX"></a>Test MathJAX</h3><script type="math/tex; mode=display">a = \frac{1}{5}</script><p>something is equals to $\alpha 5$.</p>
]]></content>
    </entry>
    
  
  
</search>
