<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[字符集与编码的恩怨情仇，以及Python3中的编码问题]]></title>
      <url>http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%EF%BC%8C%E4%BB%A5%E5%8F%8APython3%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在整理Python学习笔记的时候，发现自己一直以来对Unicode的认识和廖雪峰老师在Python3教程中所说的有不一致的地方，抱着求知的态度，查找资料后总算是弄明白了，也就整理成了这一篇文章。</p>
<p>编码问题一直以来都是很多程序员的噩梦，有时候好不容易写好一个带着详细注释的代码文件，保存一下再打开就发现注释全都乱码了。自己工作的时候还好，摸索一下弄对编码就好了。但是如果是多人协作或者发布产品时，没有统一好编码就会造成很大的问题，特别是对于来自不同国家使用不同语言的工作人员/用户来说。因此，统一编码是非常重要的，也就有了Unicode的出现。</p>
<p>下文将通过以下顺序进行讲解：<br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#编码的历史">编码的历史</a></li>
<li><a href="#字符集与编码方式">字符集与编码方式</a></li>
<li><a href="#带bom和不带bom">带BOM和不带BOM</a></li>
<li><a href="#python3中的编码问题">Python3中的编码问题</a></li>
<li><a href="#参考与感谢">参考与感谢</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="编码的历史"><a href="#编码的历史" class="headerlink" title="编码的历史"></a>编码的历史</h2><p>首先需要理解一下<strong>为什么要进行编码</strong>。我们知道，对计算机而言，一切信息都不过是01比特串，不同的01组合成不同的比特串从而可以表示不同的信息。但是，对人类来说，我们阅读写作所用的是自然语言，于是就存在着<strong>如何使用01比特串来表示自然语言</strong>这样一个问题。</p>
<p>在计算机中，8个比特（bit）组成1个字节（byte），可以表示256种不同状态。在最早的时候，计算机使用者用的都是英语，于是美国人就设计了<strong>ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）</strong>，它包含了大小写英文，数字，控制码以及其它一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8个比特(也即1个字节)，可表示128个不同字符(最高位留出，用于校验)。这样计算机就能使用不同的字节来表示英文了，显示时GUI工具或者字体渲染器只需要根据字节来显示相应的字母就可以了。</p>
<p>后来随着计算机技术的发展，各个国家都开始使用计算机了，但并不是每个国家都使用英语呀。中华文化博大精深，光是常用汉字就有6000多个，显然处理中文时一个字节是不足够的，至少要用两个字节，并且不能与ASCII冲突，因此就有了中国自己制定的<strong>GB2312编码</strong>（每个字符两字节）。后来由于中文字实在太多了，然后还有一些少数民族使用的文字，于是又相继推出了GBK标准和GB18030标准。</p>
<p>日本和韩国也不例外，日本制定了<strong>Shift_JIS编码</strong>，韩国制定了<strong>Euc-kr编码</strong>。还有很多使用其他语言的国家/地区也纷纷制定了适合自己语言的编码标准。</p>
<p>但是，各个国家都用自己不同的标准和编码，在多语言的环境下就很容易产生冲突，产生乱码。国际标准组织ISO看不下去了，就制定了一套统一的标准：<strong>通用字符集（Universal Character Set，UCS）</strong>，后来发展为俗称的<strong>Unicode</strong>，将所有语言文字统一到一套编码中。</p>
<h2 id="字符集与编码方式"><a href="#字符集与编码方式" class="headerlink" title="字符集与编码方式"></a>字符集与编码方式</h2><p>在查找相关资料的过程中，我发现<strong>字符集和编码这两个概念相当容易被混淆</strong>，甚至不少资深程序员也会说混。在廖雪峰老师的Python3教程中，他所说的Unicode指的是一种编码方式，而现在我们讨论Unicode的时候，一般是指通用字符集，它有多种编码方式，如UTF-8、UTF-16和UTF-32。那是不是廖雪峰老师所说的是错误的呢？<strong>XXX标准、XXX字符集、XXX编码到底有什么区别呢？</strong></p>
<p>对于 ASCII、GB 2312、Big5、GBK、GB 18030 之类的遗留方案来说，基本上一个字符集方案只使用一种编码方案。<br>比如 ASCII 这部标准本身就直接规定了字符和字符编码的方式，所以既是字符集又是编码方案；而 GB 2312 只是一个区位码形式的字符集标准，不过实际上基本都用 EUC-CN 来编码，所以提及「GB 2312」时也说的是一个字符集和编码连锁的方案；GBK 和 GB 18030 等向后兼容于 GB 2312 的方案也类似。<br>于是，很多人受这些遗留方案的影响而无法理解字符集和编码的关系。</p>
<p>对于 Unicode，字符集和编码是明确区分的。Unicode/UCS 标准首先是个统一的字符集标准。而 Unicode/UCS 标准同时也定义了几种可选的编码方案，在标准文档中称作「encoding form」，主要包括 UTF-8、UTF-16 和 UTF-32。<br>所以，对 Unicode 方案来说，同样的基于 Unicode 字符集的文本可以用多种编码来存储、传输。<br>所以，用「Unicode」来称呼一个编码方案不合适，并且误导。</p>
<h2 id="带BOM和不带BOM"><a href="#带BOM和不带BOM" class="headerlink" title="带BOM和不带BOM"></a>带BOM和不带BOM</h2><h2 id="Python3中的编码问题"><a href="#Python3中的编码问题" class="headerlink" title="Python3中的编码问题"></a>Python3中的编码问题</h2><p>其实最早的时候，由于各地区使用的编码方式不同，使用不同语言的人交流就成了一个大问题。国际标准组织ISO制订了统一的<strong>通用字符集（Universal Character Set，UCS）</strong>，也<strong>简称为Unicode</strong>。<strong>目前实际应用的Unicode版本对应于UCS-2编码方式</strong>，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示 2^16 也即 65536 个字符，基本满足各种语言的使用。</p>
<p>Unicode的<strong>实现方式不同于编码方式</strong>。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对<strong>Unicode编码的实现方式有所不同</strong>。<strong>Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong>。</p>
<p>例如，如果一个仅包含ASCII字符(只需要7位)的Unicode文件，如果每个字符都使用2字节的<strong>原Unicode编码</strong>传输，其第一字节的首位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用<strong>UTF-8编码，这是一种变长编码，它将ASCII字符仍用7位编码表示，占用一个字节（首位补0）</strong>。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以ASCII字符为主的西文文档就大大节省了编码长度。</p>
<p>但是，<strong>现在所说的Unicode一般都指的是字符集而非编码方式</strong>，廖雪峰老师在教程里提到的Unicode编码实际上指的是UCS-2这种编码方式。又因为以前UCS-2和UTF-16是等价的，所以微软的文档习惯把UTF16称为Unicode，这也导致很多开发者容易对此产生误会。</p>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何处理Hexo和MathJax的兼容问题]]></title>
      <url>http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天写文章写得正高兴，码Latex公式的时候突然发现无法渲染，经过一番推敲和实践，最终解决了这个问题，在这篇博文中简单记录一下，方便其他遇到同样问题的朋友们也能顺利解决。<strong>不想看解决思路的朋友也可以<a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#小结">跳到文章末尾直接看解决方案（Jump to the end to see sulution）</a></strong>。</p>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>先重现一下这个问题。在写文章的时候，我码了一个相当简单的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$$</div></pre></td></tr></table></figure>
<p>渲染出来却变成了（红框内变为了斜体）：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer1.png" alt="before"></p>
<a id="more"></a>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>琢磨了一下，MathJax支持是开了的，这么简单的公式都渲染不出，肯定不是MathJax要背的锅。简单地测试了一下，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125;$$</div></pre></td></tr></table></figure>
<p>这个公式是能work的，那到底是什么问题呢？回到前面的公式，细心观察一下，不难发现渲染之后<strong>下划线 <code>_</code> 被吞掉了</strong>，而<strong>两个下划线 <code>_</code> 之间的文本变为了斜体</strong>，这就很有意思了。</p>
<p>浏览一下网页源码，可以看到对应这一条公式的代码是：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer2.png" alt="before"></p>
<p>原来下划线被渲染成了 <code>&lt;em&gt;</code>，在HTML里这个tag是用于将文本准换为斜体进行强调的。为什么会产生这样的错误呢？其实，在Markdown语法中 <em>两个下划线之间的文本会被转换为斜体</em>，所以<strong>这个错误是由Markdown渲染器引起的</strong>。Markdown本身没有支持Latex，在渲染时正则匹配到两条下划线就会把下划线替换成了 <code>&lt;em&gt;</code>，于是到了MathJax渲染公式时就彻底懵了。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>意识到这个问题的本质后，带着疑问，我先来到Next主题的<a href="https://github.com/iissnan/hexo-theme-next/" target="_blank" rel="external">Github主页</a>，在<a href="https://github.com/iissnan/hexo-theme-next/issues?utf8=%E2%9C%93&amp;q=mathjax" target="_blank" rel="external">issue</a>里面搜索MathJax。很可惜，没有找到直接的答案，但是思路清晰了一些。<strong>Next不背这个锅</strong>，我们要做的是<strong>更换Hexo使用的Markdown渲染器</strong>。</p>
<p>接下来我又到Hexo的<a href="https://github.com/hexojs/hexo/" target="_blank" rel="external">Github主页</a>搜索相关的解决方案，在<a href="https://github.com/hexojs/hexo/issues/524" target="_blank" rel="external">issue #524</a> 中，有人提到了<strong>可以使用 rawblock 来解决</strong>，可是每次要写公式都得在公式前后加上 rawblock 来声明实在太烦了，对于公式大户来说简直要崩溃（想想之后要写机器学习的相关文章，一大堆公式证明，已经想手动再见了）。</p>
<p>另一个提出的解决方案是<strong>更换pandoc渲染器</strong>，pandoc大法固然好，但要下载安装完pandoc然后再装hexo插件实在是太重量级了.. 我只是想轻松愉悦地写写博客呀。当然，感兴趣的朋友也不妨去<a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="external">hexo-renderer-pandoc主页</a>看看。</p>
<p>有没有更好的方法呢？我在<a href="https://segmentfault.com/q/1010000003987383/a-1020000003987577/revision" target="_blank" rel="external">segmentfault</a>查到另一位朋友写的解决方案，可以<strong>使用 hexo-renderer-markdown-it 进行渲染</strong>，似乎是个不错的思路，在hexo-renderer-markdown-it的<a href="https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started" target="_blank" rel="external">文档</a>中可以看到操作相当简单：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-markdown-it --save</code></li>
</ol>
<p>两行命令即可完成，先卸载Hexo自带的Markdown解析器 hexo-renderer-marked 再安装 hexo-renderer-markdown-it 就可以了。安装完以后，先 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态网页，然后 <code>hexo s</code> 查看，这回公式能正常显示了：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/After_Change_Markdown_Renderer1.png" alt="after"></p>
<p>但是这是我又发现一个新的问题，使用 hexo-renderer-markdown-it 渲染之后，我原本为Markdown编写的<strong>TOC里的链接都失效了</strong>，而<strong>侧边栏的快速导航链接也都失效了</strong>。这怎么可以呢？文章写得短还好，鼠标滚轮滚一滚就好了。要是写得长那岂不就得浪费很多时间才能定位到自己想看的地方？这可不行！！！</p>
<p>继续查找更优的解决方案，Hexo有没有更好的Markdown渲染插件呢？有的，在<a href="https://hexo.io/plugins/" target="_blank" rel="external">Hexo主站的插件页</a>搜索关键字 Markdown，发现了 hexo-renderer-kramed 这个插件，打开它的<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">Github主页</a>，描述已经说得很清楚，作者fork了 hexo-renderer-marked 项目，并且只针对MathJax支持进行了改进，这正是我们需要的！！卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），然后安装 hexo-renderer-kramed：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>这下，不仅能正常使用TOC，也能完美地支持MathJax渲染了。至此，问题得到了解决。</p>
<p>P.S. 其实，这个问题就是因为Markdown渲染和MathJax渲染冲突造成的，除了换别的渲染器，<strong>直接修改渲染用的正则表达式</strong>也是一种解决思路，但是这个思路有一定风险，如果引起了别的bug而没有及时发现，自己又没有做好备份和记录，就需要浪费很多额外的时间来定位问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单来说，要让你的Hexo支持MathJax渲染公式，你只需要使用两条命令：<br>To fully support MathJax in your Hexo blog, you can simply use the following commands:</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>第一条命令用于卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），它是hexo自带的Markdown渲染引擎。<br>The first command uninstall Hexo’s default Markdown renderer.</p>
<p>第二条命令用于安装 hexo-renderer-kramed 插件，这个渲染插件针对MathJax支持进行了改进。安装完成后，重新生成博客就会惊喜地发现你的公式已经能够正常显示了。<br>The second command install new Markdown renderer which can support MathJax fully. After installation, you should regenerate your blog to see the changes.</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>作为一名编程人员，不屈服于bug，不妥协于简陋的solution是很重要的。除此之外，也要善于定位问题和解决问题，能够弄清楚出问题的地方，并且利用丰富的网络资源来解决问题。</p>
<p>最后，感谢开源和分享。</p>
<p>最后的最后，再码一条写在SVM笔记里的长公式检验一下吧：</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad  i=1,2,...,m\qquad(9)</script><p>完美~ The end.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用推荐算法]]></title>
      <url>http://2wildkids.com/2016/10/04/%E5%B8%B8%E7%94%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这篇<a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247483811&amp;idx=1&amp;sn=fc3ee4ddfc4a8d6014a4cd90cdb5983c&amp;scene=4#wechat_redirect" target="_blank" rel="external">文章</a>首发在【阿里技术】这个微信公众号，内容上主要围绕电商中用到的一些推荐算法，参考了 Xavier Amatriain 在CMU的 Machine Learning 暑期学校上的讲授的内容。不仅有提到一些基础的推荐算法，也讲了一些推荐系统领域比较新的研究方向，个人认为是一篇不错的概括性文章，摘录在博客里，加入一点自己的理解。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC -->
<ul>
<li><a href="#推荐系统简介">推荐系统简介</a></li>
<li><a href="#传统的推荐算法">传统的推荐算法</a><ul>
<li><a href="#非个性化推荐：热度排行（popularity）">非个性化推荐：热度排行（Popularity）</a></li>
<li><a href="#协同过滤（collaborative-filtering）">协同过滤（Collaborative Filtering）</a></li>
<li><a href="#基于内容知识的推荐（content-basedknowledge-based）">基于内容/知识的推荐（Content-based/Knowledge-based）</a></li>
<li><a href="#混合方法（hybird-approaches）">混合方法（Hybird Approaches）</a></li>
</ul>
</li>
<li><a href="#推荐算法的最新研究">推荐算法的最新研究</a><ul>
<li><a href="#学习排序（learning-to-rank）">学习排序（Learning to Rank）</a></li>
<li><a href="#页面整体优化（page-optimization）">页面整体优化（Page Optimization）</a></li>
<li><a href="#情景推荐：张量分解分解机（factoriztion-machine）">情景推荐：张量分解/分解机（Factoriztion Machine）</a></li>
<li><a href="#深度学习（deep-learning）">深度学习（Deep Learning）</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image2.jpeg" alt="g2"></p>
<p>推荐系统本身就是为了解决信息过载这个问题而出现的，在互联网出现以后，人们在生活中所能获取到的消息呈爆炸性增长。从衣食住行再到其他一些更高端的需求，我们都有非常多的选择，但是要怎么在较短的时间内从这么多的选择里找到自己最感兴趣的那个呢？推荐系统解决的就是这样一个问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image3.jpeg" alt="g3"></p>
<p>事实上，<strong>解决信息过载的问题并不是只有推荐系统这一个手段</strong>。PC时代早期出现的门户网站是一种手段，帮助上网的人快速找到想要浏览的网站。而搜索引擎也是一种很好的办法，通过关键字来筛选出用户想要看的网页。但以上两种途径展示的内容对任意两个上网用户来说都是相同的。由于每个人的喜好总会有一部分和别人重叠，而一部分比较特殊，为了展示的内容能尽可能符合大多数人的期望，导航/搜索引擎只能给出重叠最多的部分，也即最流行的网站/网页，没有办法做到根据不同用户的喜好提供不同结果。推荐系统则致力于解决这一难点，实现千人千面的效果。</p>
<p>P.S. 事实上，目前在搜索引擎这个研究领域，已经有根据用户搜索习惯和搜索历史进行个性化结果展示的研究了，可以说是吸取了推荐系统的精髓进行改进的结果吧。随着计算机处理数据的能力上升，个性化将是未来的必然趋势。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image4.jpeg" alt="g4"></p>
<p>Netflix举办的百万美元竞赛绝对是推荐系统发展史上一个重要的标志，可以说从那以后，推荐系统的研究才开始真正地被重视，随后就是百花齐放，越来越多的算法和推荐架构被提出来了。</p>
<p>特别Mark一下<strong>推荐系统的未来——基于上下文的推荐</strong>，这个确实是很值得思考的。尽管目前关注推荐系统的研究已经不少了，但绝大部分都是使用协同过滤技术，或者把推荐视作一个二分类问题来解决的。有一个很明显的缺点就是它们都需要大量的标记数据才能实现准确的预测。还有一个问题就是，这里说的推荐并没有针对用户实际所处的环境来给出结果，只是从用户的历史记录和习惯来推测，给出他可能喜欢的其它商品，而<strong>没有关注用户是否真的有需求</strong>。<strong>怎么把我们从大量历史数据中学习到的知识应用到用户所处的具体场景中？</strong>这是一个等待研究的相当有价值的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image5.jpeg" alt="g5"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image6.jpeg" alt="g6"></p>
<p>这些指标都蛮有意思的，但是并不是都能通过离线测试来得出，比方说用户满意度、惊喜性等等，都是一些比较主观的东西，在这种情况下，怎么能够提高这些指标呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image7.jpeg" alt="g7"></p>
<p>这里列了几个比较传统的因素：相似的人越喜欢一件物品，那么用户就越有可能也喜欢它；用户对相似的物品越喜爱，那么也越有可能喜欢这一件物品；对这件物品的评论中赞赏的话越多，则用户也越有可能对这件物品感兴趣；用户和这件物品的历史交互行为越多，也意味着用户对这件物品越感兴趣…</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image8.jpeg" alt="g8"></p>
<p>虽然说我们做研究主要是针对推荐的算法，但在工业界里，一个真正的推荐产品，必须要有良好的用户界面，准确的产品定位，否则从一开始就输了，连用户数据都获取不到，自然也就没有所谓个性化的后话了。特别地，花在处理数据上的时间应该是最多的，因为从真实场景中收集到的数据往往都有很大的噪音，如果不经过处理就放进算法跑的话，算法再好也难以获得好的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image9.jpeg" alt="g9"></p>
<h2 id="传统的推荐算法"><a href="#传统的推荐算法" class="headerlink" title="传统的推荐算法"></a>传统的推荐算法</h2><h3 id="非个性化推荐：热度排行（Popularity）"><a href="#非个性化推荐：热度排行（Popularity）" class="headerlink" title="非个性化推荐：热度排行（Popularity）"></a>非个性化推荐：热度排行（Popularity）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image10.jpeg" alt="g10"></p>
<p>其实在没有电商的时候，传统的线下店铺就是采用热度排行的方式来增加销量的，因为能展示给客户的商品有限，所以只能选最热门的商品放在店铺里。</p>
<p>虽然这种做法可以避免新用户的冷启动窘境，因为我们不需要知道新用户是怎样的，只要知道大的趋势就可以了。但这样做对新的商品来说显然是致命的，因为热门的商品被展示得越多就越热门，长期占据热度榜，而新商品得不到被展示的机会，就只能烂在仓库里了。这个问题也被称为<strong>马太效应（The Matthew Effect）</strong>。</p>
<p>比较有意思的是这里指出除了单纯地考虑热度，<strong>在基于热度排行时还可以综合考虑一些其它因素</strong>。事实上，即使是如此强调个性化的今天，热度依然是影响用户做出购买决定的一个很重要的因素，所以在构建推荐系统时也要充分考虑到这一点。</p>
<h3 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h3><h4 id="Memory-based-方法"><a href="#Memory-based-方法" class="headerlink" title="Memory-based 方法"></a>Memory-based 方法</h4><p>Memory-based 方法又可以称为 <strong>neighborhood-based方法</strong>。可以简单分为User-based CF和Item-based CF两种思路。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image11.jpeg" alt="g11"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image12.jpeg" alt="g12"></p>
<p>注意一下Step3过滤这个步骤，比方说用户已经买过某一本书，如果再推荐他重复购买是不合理的。但是，对于一些可能会周期性购买的物品（如抽纸、沐浴露etc），我们要怎么处理呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image13.jpeg" alt="g13"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image14.jpeg" alt="g14"></p>
<p>可以说各有各好处吧，Item-based更流行除了准确性好之外，物品的变动相对用户较少也是一个很大的原因，这能够减少很多计算花费。但是相对地，Item-based可能没有办法很好地承担<strong>开拓用户的眼界</strong>这个功能，是不是真的这样呢？值得思考。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image15.jpeg" alt="g15"></p>
<p>这里提到的缺点是需要注意的，但<strong>并不是说协同过滤就必定有这些缺点</strong>，我们可以针对这些缺点对协同过滤进行改良。这里记录一下一些简单的思路：</p>
<ul>
<li><p>冷启动问题怎么解决呢？是否可以引入一些领域知识？或者引入额外的数据来源（社交、地点、时间etc）呢？如果引入了，又该怎么使用呢？</p>
</li>
<li><p>过去的行为真的决定现在吗？过去的行为有哪些特征是可以视为用户的特征的呢？有哪些特征可能只是干扰因素呢？</p>
</li>
<li><p>怎么才能引入小众偏好，让推荐系统更强调个性化呢？</p>
</li>
</ul>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image16.jpeg" alt="g16"></p>
<p>LSH是一个相当有意思的减少计算量的方法。协同过滤的一个最基本步骤就是计算相似性，而无论从用户的角度还是从物品的角度来看，维度都相当高，计算花费很大。而使用LSH进行映射后，既能保持相似关系不会发生太大的变化，又能降低维度，确实是一种很好的解决方案。不过<strong>要特别注意哈希函数的选择</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image17.jpeg" alt="g17"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image18.jpeg" alt="g18"></p>
<h4 id="Model-based方法"><a href="#Model-based方法" class="headerlink" title="Model-based方法"></a>Model-based方法</h4><p>基于模型的方法，用到的技术就比较多涉及到机器学习领域了。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image19.jpeg" alt="g19"></p>
<h5 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image20.jpeg" alt="g20"></p>
<p>关联规则挖掘其实跟买东西的场景是非常搭的，有兴趣的朋友不妨查查 “啤酒与尿布” 这个经典案例。</p>
<p>值得注意的是：我们<strong>从结果反推出的 “现象” 并不一定是事实</strong>，这其中有可能存在巧合的因素，所以我们一定要慎重地对待。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image21.jpeg" alt="g21"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image22.jpeg" alt="g22"></p>
<p>Mark一下这里产生悖论的原因：<strong>数据的不同分组之间基数差异很大</strong>，导致合并时产生了偏差。用上面的例子来说就是对顾客分组是，在职人员的数量要远多于大学生的数量，在把这两个分组合并为顾客来考虑时就会产生偏差。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image23.jpeg" alt="g23"></p>
<h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image24.jpeg" alt="g24"></p>
<p>事实上，我们并不一定要在同一个簇里面找推荐物品的候选集，完全可以基于簇之间来使用KNN，把最近邻的簇对应的物品集作为候选，这样做就有一定概率引入一些额外的物品，给用户带来惊喜了。当然，如何平衡好这一点和推荐的准确性是需要研究的。</p>
<h5 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image25.jpeg" alt="g25"></p>
<p>比方说把推荐看作一个二分类问题，预测用户是否购买/点击；把推荐看作一个回归问题，预测用户对推荐物品的评分。这样来看的话，很多有监督学习的机器学习技术都能被用上了。但是，如何获得大量独立同分布的训练数据会是一个很大的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image26.jpeg" alt="g26"></p>
<ul>
<li>如何应对评分矩阵的稀疏性？ —— 现实问题，用户接触到的商品仅占非常小的一部分，会进行反馈的就更少了</li>
<li>如何降低大规模矩阵计算的时间开销？ —— 决定能否满足实时性的需求</li>
</ul>
<p>图片中的两条式子可能有些模糊，它们分别是是：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}' \qquad(1)</script><p>和</p>
<script type="math/tex; mode=display">R_{m \times n} \approx U_{m \times k} S_{k \times k} V_{k \times n}' \qquad(2)</script><p>式（1）是标准的SVD矩阵分解，式（2）则是<strong>利用SVD技术进行低阶近似</strong>，也称为<strong>截断SVD（Truncated SVD）</strong>，它只取最大的k个奇异值，而k要远小于原矩阵的行数m和列数n，因此能够大大地降低计算开销。由于篇幅原因，这里就不科普SVD相关的知识了，详细内容可以check一下<a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank" rel="external">维基百科里对SVD的描述</a>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image27.jpeg" alt="g27"></p>
<p>Funk提出的这种矩阵分解算法在很大程度上弥补了标准SVD的不足，它不需要关注缺失值，而且计算复杂度也降低了很多。这种矩阵分解方法后来被Netflix Prize的冠军Koren称为<strong>Latent Factor Model（简称LFM）</strong>，也即后来大名鼎鼎的<strong>隐语义模型</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image28.jpeg" alt="g28"></p>
<p>加入偏置项是一种很直觉的想法，举一个简单的例子，对商品要求较高的用户通常会给出较低的评分，所以在满意程度同等时，他给出的评分可能比其他用户都要低。如果我们不排除这个影响的话，他的评分就会错误地拉低了商品的评价。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image29.jpeg" alt="g29"></p>
<p>更进一步地，我们还可以考虑用户的历史行为对评分的影响。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image30.jpeg" alt="g30"></p>
<p>向量化可以理解为对原事物表现形式的改变，不仅仅用于推荐系统领域，也是很多其他研究领域的基础。比方说自然语言处理，要理解对话，就先就要把对话的句子进行向量化，将句子分解为不同的单词，每个单词对应一个维度（最近Google翻译已经改进为以句子为单元了，使得翻译更加准确，不过由于我没有进行过自然语言处理相关的研究，所以不太清楚具体的情况）。</p>
<h5 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image31.jpeg" alt="g31"></p>
<p>Boltzmann机是全连接的一个网络，参数相当多，即使去除同同一层内的连接，变为RBM，参数依然很多。参数越多，自然拟合的能力就越强，所以RBM可以说是浅层学习（相对于深度学习的一个概念，毕竟RBM就只有两层神经元）中非常强大的一个模型。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image32.jpeg" alt="g32"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image33.jpeg" alt="g33"></p>
<p>Mark一下，<strong>一个用户一个RBM</strong>，也即为每个用户都训练一个RBM模型，这样开销固然很大，但私以为这样做要比协同过滤更加符合<strong>个性化</strong>的需求。除了开销大之外，这种方法还需要海量的训练数据，否则无法得到可以接受的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image34.jpeg" alt="g34"></p>
<p>自从深度学习火了之后，越来越多的研究者开始对其进行研究。在推荐系统领域也不例外，虽然RBM并不算“深”，但是可以帮助我们理解深度学习技术是如何应用到推荐系统领域的。我个人还不是太过了解深度学习，上面的PPT也不是讲得讲得很清楚（在推荐系统问题中应用的RBM是改良过的）。感兴趣的朋友不妨阅读一下腾讯数字音乐部智能推荐组编写的文章——<strong><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=417547354&amp;idx=1&amp;sn=1cda80702cff4f9d0f739f75d30eb773" target="_blank" rel="external">解密深度学习在智能推荐系统的实践与应用</a></strong>。</p>
<h5 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image35.jpeg" alt="g35"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image36.jpeg" alt="g36"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image37.jpeg" alt="g37"></p>
<p>Mark一下：<strong>图模型可以发现协同过滤发现不来的弱相似性，给推荐带来一定的惊喜。</strong></p>
<h3 id="基于内容-知识的推荐（Content-based-Knowledge-based）"><a href="#基于内容-知识的推荐（Content-based-Knowledge-based）" class="headerlink" title="基于内容/知识的推荐（Content-based/Knowledge-based）"></a>基于内容/知识的推荐（Content-based/Knowledge-based）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image38.jpeg" alt="g38"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image39.jpeg" alt="g39"></p>
<h3 id="混合方法（Hybird-Approaches）"><a href="#混合方法（Hybird-Approaches）" class="headerlink" title="混合方法（Hybird Approaches）"></a>混合方法（Hybird Approaches）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image40.jpeg" alt="g40"></p>
<p>所谓混合方法，指的是将多个算法集成在一起来完成任务，更详细的讲解可以查询集成学习相关的内容了解。</p>
<h2 id="推荐算法的最新研究"><a href="#推荐算法的最新研究" class="headerlink" title="推荐算法的最新研究"></a>推荐算法的最新研究</h2><h3 id="学习排序（Learning-to-Rank）"><a href="#学习排序（Learning-to-Rank）" class="headerlink" title="学习排序（Learning to Rank）"></a>学习排序（Learning to Rank）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image41.jpeg" alt="g41"></p>
<p>对NDCG和MRR这两种排序评价准则感兴趣的朋友可以浏览<a href="http://www.cnblogs.com/startover/archive/2013/06/18/3141616.html" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="页面整体优化（Page-Optimization）"><a href="#页面整体优化（Page-Optimization）" class="headerlink" title="页面整体优化（Page Optimization）"></a>页面整体优化（Page Optimization）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image42.jpeg" alt="g42"></p>
<h3 id="情景推荐：张量分解-分解机（Factoriztion-Machine）"><a href="#情景推荐：张量分解-分解机（Factoriztion-Machine）" class="headerlink" title="情景推荐：张量分解/分解机（Factoriztion Machine）"></a>情景推荐：张量分解/分解机（Factoriztion Machine）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image43.jpeg" alt="g43"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image44.jpeg" alt="g44"></p>
<h3 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image45.jpeg" alt="g45"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image46.jpeg" alt="g46"></p>
<p>Mark一下：<strong>仅仅利用行为数据的RNN可能效果有限，可以结合更多数据来源。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image47.jpeg" alt="g47"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image48.jpeg" alt="g48"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image49.jpeg" alt="g49"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction]]></title>
      <url>http://2wildkids.com/2016/10/03/Introduction/</url>
      <content type="html"><![CDATA[<p>自从知道了Github Pages和Hexo这对绝佳搭配之后，一直心心念念地想做一个自己的独立博客。虽然从阅读量来说，肯定还是在CSDN、简书或者知乎专栏发布会有更多被阅读的机会，但总感觉或多或少地有些阻碍，不能随心所欲地写作。之前倒是一直把Github当作一个博客，天天把markdown写的笔记contribute到仓库里面，不过鉴于Github支持的是源生的markdown，而markdown本身是不支持latex公式的，所以多少有点遗憾。Anyway，终于用Github Pages+Hexo搭建了这个博客，有MathJax和七牛图床的支持，终于可以随心所欲地写作了~</p>
<p>鉴于大四一直在忙自己的项目和论文，所以少有时间做些真正原创的技术分享，前期主要打算在这个博客做一些阅读笔记。暑假一直在读周志华博士写的《机器学习》一书，把本科生课程部分（书的前半部分）的笔记基本都整理好了，放在了Github上面，但这显然是不够的，想做研究当然还是得往更深的技术里钻，所以书的后半部分还要继续细读精读。另一方面，这本书比较新，所以习题部分目前网上还没有比较好的解答。书中的公式有些比较复杂，对工程人员来说理解可能有不少困难，所以我也希望可以用课余的时间认真地把这本书的习题过一遍，如何对公式进行向量化，如何融入到实际的项目中，用代码进行实现。希望可以分享出来，为开源做点贡献，为其他书友带来一点帮助，自己应该也会有不少的收获。之后会逐渐把笔记和解答迁移到这个博客里，需要花费的时间也比较多，不过贵在坚持。</p>
<a id="more"></a>
<p>因为个人研究方向主攻数据挖掘的推荐系统领域，所以阅读的书籍和文章也比较多涉及这个方面。而中文书籍中，个人认为推荐系统领域最好的一本入门书籍是项亮的《推荐系统实践》，之后也会在这个博客中更新阅读这本书的笔记。另外也会搬运一些机器学习和数据挖掘比较好的文章到这个博客中，加入一些自己的理解，算是记录自己成长的轨迹吧，虽然不是技术原创，但在阅读和学习的过程中，记录下自己的见解，以后再看也会有很大的帮助。</p>
<p>另外，我个人也非常喜欢Python这门编程语言，在数据科学方面的研究中，Python是一个不可多得的利器，所以要是遇到好的Python相关的文章，也会收录到这个博客中。再有就是linux和Hadoop、Spark方面的一些笔记了，要做大数据总是免不了碰到这些东西。虽然工具年年变，说不定以后Spark就不像现在这么火了，但是好的工具总是有研究价值的，好好学的话还是会有不错的收获。</p>
<p>最后，也是一点小寄望吧，希望以后可以能逐渐有多一些技术原创，多一些项目分享，目前就先脚踏实地地积累知识吧。</p>
<p>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://2wildkids.com/2016/09/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Test-MathJAX"><a href="#Test-MathJAX" class="headerlink" title="Test MathJAX"></a>Test MathJAX</h3><script type="math/tex; mode=display">a = \frac{1}{5}</script><p>something is equals to $\alpha 5$.</p>
]]></content>
    </entry>
    
  
  
</search>
