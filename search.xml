<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python学习笔记-04函数式编程]]></title>
      <url>http://2wildkids.com/2016/11/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#函数式编程的三大特性">函数式编程的三大特性</a></li>
<li><a href="#函数式编程的几个技术">函数式编程的几个技术</a></li>
<li><a href="#函数式编程的几个好处">函数式编程的几个好处</a><ul>
<li><a href="#简单举例">简单举例</a></li>
</ul>
</li>
<li><a href="#高阶函数">高阶函数</a><ul>
<li><a href="#变量可以指向函数">变量可以指向函数</a></li>
<li><a href="#函数名也是变量">函数名也是变量</a></li>
<li><a href="#传入函数">传入函数</a></li>
<li><a href="#mapreduce">map/reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sorted">sorted</a></li>
</ul>
</li>
<li><a href="#返回函数">返回函数</a><ul>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
<li><a href="#闭包">闭包</a></li>
</ul>
</li>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#装饰器">装饰器</a><ul>
<li><a href="#带参数的decorator">带参数的decorator</a></li>
<li><a href="#属性复制">属性复制</a></li>
<li><a href="#练习">练习</a></li>
</ul>
</li>
<li><a href="#偏函数">偏函数</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p><strong>函数</strong>是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p><strong>函数式编程</strong>（请注意多了一个<strong>“式”</strong>字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其<strong>思想更接近数学计算</strong>。</p>
<p>我们首先要搞明白<strong>计算机（Computer）</strong>和<strong>计算（Compute）</strong>的概念。</p>
<ul>
<li><p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以汇编语言是最贴近计算机的语言。</p>
</li>
<li><p>计算则是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
</li>
</ul>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p><strong>归纳一下</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">低级语言</th>
<th style="text-align:center">高级语言</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">特点</td>
<td style="text-align:center">贴近计算机</td>
<td style="text-align:center">贴近计算（数学意义上）</td>
</tr>
<tr>
<td style="text-align:center">抽象程度</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">执行效率</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">例子</td>
<td style="text-align:center">汇编和C</td>
<td style="text-align:center">Lisp</td>
</tr>
</tbody>
</table>
</div>
<p>函数式编程就是一种<strong>抽象程度很高的编程范式</strong>，纯粹的函数式编程语言编写的函数<strong>没有变量</strong>，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为<strong>没有副作用</strong>。而允许使用变量的程序设计语言，由于函数内部的<strong>变量状态不确定</strong>，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数</strong>！</p>
<p>Python<strong>仅对函数式编程提供部分支持</strong>。由于Python允许使用变量，因此，<strong>Python不是纯函数式编程语言</strong>。</p>
<h2 id="函数式编程的三大特性"><a href="#函数式编程的三大特性" class="headerlink" title="函数式编程的三大特性"></a>函数式编程的三大特性</h2><ol>
<li><p><strong>immutable data</strong><br><br>变量不可变，或者说没有变量，只有常量。 函数式编程输入确定时输出就是确定的，函数内部的变量和函数外部的没有关系，不会受到外部操作的影响。</p>
</li>
<li><p><strong>first class functions</strong><br><br>第一类函数(也称高阶函数)，意思是函数可以向变量一样用，可以像变量一样创建、修改、传递和返回。 这就允许我们把大段代码拆成函数一层层地调用，这种面向过程的写法相比循环更加直观。</p>
</li>
<li><p><strong>尾递归优化</strong><br><br>之前一章的递归函数中已经提及过了，就是递归时返回函数本身而非表达式。 可惜Python中没有这个特性。</p>
</li>
</ol>
<hr>
<p><br></p>
<h2 id="函数式编程的几个技术"><a href="#函数式编程的几个技术" class="headerlink" title="函数式编程的几个技术"></a>函数式编程的几个技术</h2><ol>
<li><p><strong>map &amp; reduce</strong><br><br>函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起传统的面向过程的写法来说，在代码上要更容易阅读（不需要使用一堆for、while循环来倒腾数据，而是使用更抽象的Map函数和Reduce函数）。</p>
</li>
<li><p><strong>pipeline</strong><br><br>这个技术的意思是把函数实例成一个一个的action，然后把一组action放到一个数组或是列表中组成一个action list，然后把数据传给这个action list，数据就像通过一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。</p>
</li>
<li><p><strong>recursing</strong><br><br>递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</p>
</li>
<li><p><strong>currying</strong><br><br>把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数（减少函数的参数数目）。</p>
</li>
<li><p><strong>higher order function</strong><br><br>高阶函数：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出。</p>
</li>
</ol>
<p>对currying进行一点补充，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(i, j)</span>:</span></div><div class="line">    <span class="keyword">return</span> i**j</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> pow(i, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>这里就是把原本平方函数<code>square</code>的参数j分解了，它返回幂函数<code>pow</code>函数，把幂次封装在里面，从而减少了求平方时所需用到的参数。</p>
<p>关于函数式编程的一些概念理解可以看<a href="http://www.kancloud.cn/kancloud/functional-programm-for-rest/56931" target="_blank" rel="external">傻瓜函数式编程</a>或者英文原版的<a href="http://www.defmacro.org/ramblings/fp.html" target="_blank" rel="external">Functional Programming For The Rest of Us</a>。</p>
<hr>
<p><br></p>
<h2 id="函数式编程的几个好处"><a href="#函数式编程的几个好处" class="headerlink" title="函数式编程的几个好处"></a>函数式编程的几个好处</h2><ol>
<li><p><strong>parallelization 并行</strong><br><br>在并行环境下，各个线程之间不需要同步或互斥(变量都是内部的，不需要共享)。</p>
</li>
<li><p><strong>lazy evaluation 惰性求值</strong><br><br>表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p>
</li>
<li><p><strong>determinism 确定性</strong><br><br>输入是确定的，输出就是确定的。</p>
</li>
</ol>
<h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><p>以往面向过程式的编程需要引入额外的逻辑变量以及使用循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upname =[<span class="string">'HAO'</span>, <span class="string">'CHEN'</span>, <span class="string">'COOLSHELL'</span>]</div><div class="line">lowname =[]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(upname)):</div><div class="line">    lowname.append( upname[i].lower() )</div></pre></td></tr></table></figure>
<p>而函数式编程则非常简洁易懂：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toUpper</span><span class="params">(item)</span>:</span></div><div class="line">  <span class="keyword">return</span> item.upper()</div><div class="line"></div><div class="line">upper_name = map(toUpper, [<span class="string">"hao"</span>, <span class="string">"chen"</span>, <span class="string">"coolshell"</span>])</div><div class="line"><span class="keyword">print</span> upper_name</div></pre></td></tr></table></figure>
<p>再看一个计算一个列表中所有正数的平均数的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">num =[<span class="number">2</span>, <span class="number">-5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">-2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">8</span>]</div><div class="line">positive_num_cnt = <span class="number">0</span></div><div class="line">positive_num_sum = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</div><div class="line">    <span class="keyword">if</span> num[i] &gt; <span class="number">0</span>:</div><div class="line">        positive_num_cnt += <span class="number">1</span></div><div class="line">        positive_num_sum += num[i]</div><div class="line"></div><div class="line"><span class="keyword">if</span> positive_num_cnt &gt; <span class="number">0</span>:</div><div class="line">    average = positive_num_sum / positive_num_cnt</div><div class="line"></div><div class="line"><span class="keyword">print</span> average</div></pre></td></tr></table></figure>
<p>如果采用函数式编程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">positive_num = filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, num)</div><div class="line">average = reduce(<span class="keyword">lambda</span> x,y: x+y, positive_num) / len( positive_num )</div></pre></td></tr></table></figure>
<p>可以看到<strong>函数式编程减少了变量的使用，也就减少了出Bug的可能，维护更加方便。可读性更高，代码更简洁</strong>。</p>
<p>更多的例子和解析详见<a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">函数式编程</a>。</p>
<hr>
<p><br></p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>前面已经提到了函数式编程中的高阶函数特性，这一节将针对Python中的使用方式进行更详细的描述。</p>
<h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs</div><div class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>这个例子表明在Python中变量是可以指向函数的，并且这样赋值的变量能够作为函数的别名使用。</p>
<hr>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs = <span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</div></pre></td></tr></table></figure>
<p>这里把abs函数赋值为10，这样赋值以后abs就变成一个整形变量，指向int型对象10而不指向原本的函数了。所以无法再作为函数使用。</p>
<p>想恢复abs函数要重启Python交互环境。 abs函数定义在 <code>__builtin__</code> 模块中，要让修改abs变量的指向在其它模块也生效，用 <code>__builtin__.abs = 10</code> 就可以了。 当然<strong>实际写代码绝对不应该这样做</strong>..</p>
<hr>
<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>函数能够作为参数传递，接收这样的参数的函数就称为高阶函数。 简单举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></div><div class="line">    <span class="keyword">return</span> f(x) + f(y)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">-5</span>, <span class="number">6</span>, abs)</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>这里abs函数可以作为一个参数传入我们编写的add函数中，add函数就是一个高阶函数。</p>
<hr>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>map()函数和reduce()函数是Python的两个内建函数(BIF)。</p>
<h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><p>map()函数接收两个参数，一个是函数，一个是<strong>Iterable对象</strong>，map将传入的函数依次作用到序列的每个元素，并把结果作为<strong>Iterator对象</strong>（惰性序列，可以用list转换为列表输出）返回。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>这里直接使用list()函数将迭代器对象转换为一个列表。</p>
<p>写循环也能达到同样效果，但是显然没有map()函数直观。 map()函数作为高阶函数，大大简化了代码，更易理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</div></pre></td></tr></table></figure>
<p>将一个整数列表转换为字符列表仅仅需要一行代码。</p>
<h4 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h4><p>reduce接收两个参数，一个是函数（假设该函数称为f），一个是Iterable对象（假设是l）。函数f必须接收两个参数，reduce函数每次会把上一次函数f返回的值和l的下一个元素传入到f中，直到l中所有元素都参与过运算时返回函数f最后返回的值（第一次传入时传入l的头两个元素）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>这里举了一个最简单的序列求和作例子(当然实际上我们直接用sum()函数更方便，这里只是为了举例子)。 这里reduce函数每次将add<strong>作用于序列的前两个元素</strong>，并<strong>把结果返回序列的头部</strong>，直到序列只剩下1个元素就返回结果（这样理解可能更直观一些）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s] <span class="comment">#字符对应整数的dict，返回传入字符对应的整数</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, map(char2num, <span class="string">'13579'</span>))</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<p>可以整理一下，作为一个整体的str2int函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line">        <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</div></pre></td></tr></table></figure>
<p>使用lambda匿名函数还可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, map(char2num, s))</div></pre></td></tr></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>1.利用map()函数，把不规范的英文名字变为首字母大写其他字母小写的规范名字。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>字符串支持切片操作，并且可以用加号做字符串拼接。</li>
<li>转换大写用upper函数，转换小写用lower函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> name[<span class="number">0</span>].upper()+name[<span class="number">1</span>:].lower()</div><div class="line"></div><div class="line">L1 = [<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]</div><div class="line">L2 = list(map(normalize, L1))</div><div class="line">print(L2)</div></pre></td></tr></table></figure>
<blockquote>
<p>2.编写一个prod()函数，可以接受一个list并利用reduce()求积。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>用匿名函数做两数相乘</li>
<li>用reduce函数做归约，得到列表元素连乘之积。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">(L)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y,L)</div><div class="line"></div><div class="line">print(<span class="string">'3 * 5 * 7 * 9 ='</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))</div></pre></td></tr></table></figure>
<blockquote>
<p>3.利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.45。</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>这题的思路是找到小数点的位置i(从个位开始数i个数字之后)，然后让转换出的整数除以10的i次方。</li>
<li>另外一种思路是在转换时遇到小数点后，改变转换的方式由 <code>num*10+当前数字</code> 变为 <code>num+当前数字/point</code>。 point初始为1，每次加入新数字前除以10。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pow</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chr2num</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,map(chr2num,s.replace(<span class="string">'.'</span>,<span class="string">''</span>))) / pow(<span class="number">10</span>,len(s)-s.find(<span class="string">'.'</span>)<span class="number">-1</span>)</div><div class="line"></div><div class="line">print(str2float(<span class="string">'985.64785'</span>))</div></pre></td></tr></table></figure>
<hr>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter()函数同样是内建函数，用于过滤序列。 filter()接收一个函数和一个Iterable对象。 和map()不同的时，filter()把传入的函数依次作用于每个元素，然后<strong>根据函数返回值是True还是False决定保留还是丢弃该元素</strong>。</p>
<p>简单的奇数筛选例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></div><div class="line"></div><div class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</div><div class="line"><span class="comment"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure>
<p>筛掉列表的空字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</div><div class="line"></div><div class="line">list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</div><div class="line"><span class="comment"># 结果: ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>其中，<code>strip</code> 函数用于删除字符串中特定字符，格式为：<code>s.strip(rm)</code>，删除s字符串中开头、结尾处的包含在rm删除序列中的字符。 rm为空时默认删除空白符(包括’\n’, ‘\r’,  ‘\t’,  ‘ ‘)。</p>
<p>注意到 <code>filter()</code> 函数返回的是一个 <strong>Iterator对象</strong>，也就是一个<strong>惰性序列</strong>，所以要强迫 <code>filter()</code> 完成计算结果，需要用 <code>list()</code> 函数获得所有结果并返回list。</p>
<p>filter函数最重要的一点就是正确地定义一个<strong>筛选函数</strong>（即传入filter作为参数的那个函数)。</p>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>1.用filter筛选素数</p>
</blockquote>
<p>这里使用<strong>埃氏筛法</strong>。</p>
<blockquote>
<p>首先，列出从2开始的所有自然数，构造一个序列：</p>
</blockquote>
<pre><code>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...
</code></pre><blockquote>
<p>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：</p>
</blockquote>
<pre><code>3, 5, 7, 9, 11, 13, 15, 17, 19, ...
</code></pre><blockquote>
<p>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：</p>
</blockquote>
<pre><code>5, 7, 11, 13, 17, 19, ...
</code></pre><blockquote>
<p>以此类推…</p>
</blockquote>
<p>首先构造一个生成器，输出3开始的奇数序列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></div><div class="line">    n = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = n + <span class="number">2</span></div><div class="line">        <span class="keyword">yield</span> n</div></pre></td></tr></table></figure>
<p>然后定义一个筛选函数，传入n，判断x能否除尽n：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里x是匿名函数的参数，<strong>由外部提供</strong>。</p>
<p>然后就是定义返回素数的生成器了。</p>
<ul>
<li><p>首先输出素数2，然后初始化奇数队列，每次输出队首(必然是素数，因为前一轮的过滤已经排除了比当前队首小且非素数的数)。</p>
</li>
<li><p>构造新的队列，每次用当前序列最小的数作为除数，检验后面的数是否素数。</p>
</li>
</ul>
<p>定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span></div><div class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></div><div class="line">        <span class="keyword">yield</span> n</div><div class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></div></pre></td></tr></table></figure>
<p>这里因为it是一个迭代器，每次使用next就得到队列的下一个元素，实际上就类似队列的出列操作，挤掉队首，不用担心重复。</p>
<p>然后这里filter的原理，就是把当前it队列的每个数都放进_not_divisible(n)中检测一下，注意<strong>不是作为参数n传入而是作为匿名函数的参数x传入</strong>！</p>
<p><code>_not_divisible(n)</code> 实际是<strong>作为一个整体来看</strong>的，它返回一个<strong>自带参数n的函数</strong>(也即那个匿名函数)，然后filter再把列表每一个元素一一传返回的匿名函数中。一定要搞清楚这一点。</p>
<ul>
<li>最后，因为primes产生的也是一个无限长的惰性序列，我们一般不需要求那么多，简单写个循环用作退出即可：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打印1000以内的素数:</span></div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</div><div class="line">        print(n)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>2.用filter筛选回文数</p>
</blockquote>
<p><strong>Hint</strong>:</p>
<ul>
<li>str可以把整数转换为字符串</li>
<li>[::-1]可以得到逆序的列表。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> str(n) == str(n)[::<span class="number">-1</span>]</div><div class="line"></div><div class="line">print(list(filter(is_palindrome, range(<span class="number">0</span>,<span class="number">1001</span>))))</div></pre></td></tr></table></figure>
<hr>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>Python内置的 <code>sorted()</code> 函数就可以对list进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>])</div><div class="line">[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure>
<p>并且 <code>sorted()</code> 作为<strong>高阶函数</strong>还允许接受一个key函数用于自定义排序，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure>
<p>key指定的函数将作用于list的每一个元素上，并<strong>根据key函数返回(映射)的结果进行排序</strong>，最后<strong>对应回列表中的元素</strong>进行输出。</p>
<p>再看一个字符串排序例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</div><div class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</div></pre></td></tr></table></figure>
<p>默认情况下是按ASCII码排序的，但我们往往希望按照字典序来排，思路就是把字符串变为全小写/全大写再排：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</div><div class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</div></pre></td></tr></table></figure>
<p>默认排序是由小到大，要反相排序只需把reverse参数设为True。 温习前面的知识，这里reverse参数是一个<strong>命名关键字参数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</div><div class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</div></pre></td></tr></table></figure>
<p>使用好sorted函数的关键就是定义好一个映射函数。</p>
<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>给出成绩表，分别按姓名和成绩进行排序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = sorted(L, key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])    <span class="comment">#按姓名排序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2</div><div class="line">[(<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L3 = sorted(L, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])    <span class="comment">#按成绩排序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L3</div><div class="line">[(<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>)]</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>比方说我们想实现一个对可变参数求和的函数，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(*args)</span>:</span></div><div class="line">    ax = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line">        ax = ax + n</div><div class="line">    <span class="keyword">return</span> ax</div></pre></td></tr></table></figure>
<p>调用时可以传入任意个数字，并得到这些数字的和。而如果我们不需要立即求和，而是后面再根据需要来进行求和，可以写为返回求和函数的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></div><div class="line">        ax = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line">            ax = ax + n</div><div class="line">        <span class="keyword">return</span> ax</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>在调用 <code>lazy_sum</code> 时，返回一个sum函数，但sum函数内部的求和代码没有执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</div></pre></td></tr></table></figure>
<p>当我们再调用返回的这个sum函数时，就能得到和值了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f()</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>注意！每一次调用 <code>lazy_sum</code> 返回的函数都是不同的！<strong>即使传入相同的参数，返回函数也是不同的</strong>！举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1==f2</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>f1和f2是不同的两个函数，虽然调用它们得到同样的结果，但它们是互不影响的。</p>
<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在Python中，从表现形式上来讲，闭包可以定义为：如果在一个内部函数里，对外部作用域（<strong>非全局作用域</strong>）的变量进行了引用，那么这个<strong>内部函数就被认为是闭包</strong>(closure)。 如上面例子中的f就是一个闭包，它调用了变量i，变量i属于外面的循环体而不是全局变量。</p>
<p>看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">             <span class="keyword">return</span> i*i</div><div class="line">        fs.append(f)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count()</div></pre></td></tr></table></figure>
<p>三个返回函数的调用结果是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>解析一下，这里count函数是一个返回三个函数的函数，里面使用了一个循环体来产生要返回的三个函数。从i为1开始到i等于3，每次产生一个函数f，返回i的平方值。如果按照平常的思路来看，可能会觉得返回的三个函数f1、f2、f3应该分别输出1、4、9。</p>
<p>但实际上并不是这样的，这是因为<strong>返回一个函数时，函数内部的代码是没有执行的！ 只有在调用这个返回的函数时才会执行</strong>！</p>
<p>调用count函数时，实际上返回了3个新的函数，循环变量i的值也变为3。在调用这3个返回的函数时，它们的代码才会执行，这时引用的i的值就都是3。</p>
<p>如果一定要在闭包中用到外部的循环变量，要怎么办呢？ 我们先定义一个函数，<strong>用它的参数绑定循环变量</strong>，然后再在它的里面定义要返回的函数。 这样无论后面循环变量怎么变，<strong>已经绑定到参数的值是不会变</strong>的，就能得到我们期望的结果了。也即把上面的例子改写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">return</span> j*j</div><div class="line">        <span class="keyword">return</span> g</div><div class="line"></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span></div><div class="line">    <span class="keyword">return</span> fs</div></pre></td></tr></table></figure>
<p>调用结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>这里闭包g用到的变量j是<strong>外部作用域f</strong>的，并且<strong>j作为参数绑定在f中不再改变</strong>，不同于外部作用域count函数中的变量i。 所以执行count返回的3个函数，每个的结果都不同。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>返回闭包时，<strong>不要在闭包的代码中引用外部作用域的循环变量或者外部作用域中会变化的变量</strong>。</p>
</li>
<li><p><strong>不应该在闭包中修改外部作用域的局部变量</strong>。</p>
</li>
</ul>
<hr>
<p><br></p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>当我们在使用函数作为参数时，有些时候，<strong>不需要预先显式地定义函数</strong>，直接传入一个匿名函数更方便。</p>
<p>举个简单例子，计算 <code>f(x)=x²</code> 时，不需要显示定义f(x)，使用匿名函数可以直接一行解决，这样写非常简洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p><strong>关键字lambda</strong>表示要定义一个匿名函数，<strong>冒号前面</strong>的x表示函数的参数。</p>
<p>匿名函数有个限制，就是<strong>只能包含一个表达式</strong>，不用写return，<strong>返回值就是该表达式的结果</strong>。</p>
<p>所以上面这个匿名函数就是：x作为参数传入，返回 <code>x*x</code> 的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，<strong>不必担心函数名冲突</strong>。此外，匿名函数也是一个<strong>函数对象</strong>，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>并且匿名函数作为一个函数对象，也能被函数返回(像上一节那样)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</div></pre></td></tr></table></figure>
<p>这里返回的函数是一个匿名函数，它没有参数，里面调用的变量x和变量y是绑定在外部作用域build中的参数。所以调用build时会根据使用的参数返回这个匿名函数，调用返回的这个函数时使用的变量x和变量y就是调用build时用的参数。</p>
<hr>
<p><br></p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>有时候我们希望为函数增加一些额外的功能，比如在调用函数的前后自动打印某些信息，但又<strong>不希望修改定义函数的代码</strong>。这时就可以使用<strong>装饰器（Decorator）</strong>了，它是python中对<a href="http://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">装饰器模式</a>的实现，可以<strong>在代码运行期间动态增加功能</strong>（装饰器的代码和要装饰的函数的代码还是要写好，这里只是说对要装饰的函数使用装饰器后，在运行时要装饰的函数会被重新包装一遍，使得它具有了装饰器中定义的功能）。</p>
<p>比方说我们要实现一个打印函数名的额外功能，它是通过调用函数对象的 <code>__name__</code> 属性获得的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2015-3-25'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'now'</span></div></pre></td></tr></table></figure>
<p>如果我们不想在每个函数中都重复写实现这个功能的代码，可以把它写为装饰器的形式，然后为每个函数添加这个装饰器。<strong>装饰器本身也是一个函数</strong>，这个例子可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>它<strong>像正常函数一样定义</strong>（没有特别的语法），接收一个函数作为参数，并且返回一个函数 <code>wrapper</code>（Python中函数也是对象，既可以作为参数，也能被返回）。回顾前一节的内容，可以看出 <code>wrapper</code> 函数是一个闭包，它本身接收可变参数 <code>*args</code> 和关键字参数 <code>**kw</code>，并且引用了外部作用域中绑定在 <code>log</code> 函数参数中的 <code>func</code> 变量。</p>
<p>使用装饰器时，借助Python的<strong>@语法</strong>，把装饰器放在函数定义的上一行即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div></pre></td></tr></table></figure>
<p>运行时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">call now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>原理是这样的，把 <code>@log</code> 放在 <code>now()</code> 函数的定义前，运行代码的时候，实际上是在函数定义后执行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now = log(now)</div></pre></td></tr></table></figure>
<p>也即执行了 <code>log</code> 函数，并把 <code>now</code> 这个变量名赋值为 <code>log(now)</code> 返回的 <code>wrapper(*args, **kw)</code> 函数（也即 <code>now</code> 引用的函数对象变了）。此时查看 <code>now</code> 变量指向的函数对象的名字，会发现已经变成了 <code>wrapper</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'wrapper'</span></div></pre></td></tr></table></figure>
<p>此时我们调用这个新的 <code>now()</code> 函数时，实际上执行的就是 <code>wrapper</code> 函数中的代码，打印出函数信息，然后再<strong>调用原来的 <code>now</code> 函数</strong>。要注意 <strong><code>wrapper</code> 调用的 <code>now</code> 函数和我们调用的 <code>now</code> 函数是不同的两个函数</strong>，我们调用的 <code>now</code> 函数已经变成了 <code>wrapper</code> 函数，而 <code>wrapper</code> 函数调用的则是绑定在 <code>log</code> 函数参数中的原本的 <code>now</code> 函数。</p>
<p><strong>简单归纳一下</strong>：</p>
<ul>
<li>装饰器也是一个函数</li>
<li>装饰器实际上是把传入的函数进行一层包装，返回一个新函数</li>
<li>要为函数添加装饰器时，在函数定义前使用 <code>@装饰器名</code> 即可</li>
</ul>
<p>装饰器的原理部分如果还有不清楚的，不妨看看知乎上<a href="https://www.zhihu.com/question/26930016/answer/105175177" target="_blank" rel="external">李冬</a>的答案，讲得比较浅显和清楚。</p>
<hr>
<h3 id="带参数的decorator"><a href="#带参数的decorator" class="headerlink" title="带参数的decorator"></a>带参数的decorator</h3><p>前面提到<strong>装饰器可以用于为函数提供增强功能而无须修改函数本身的代码</strong>，在装饰器函数中，闭包 <code>wrapper</code> 接收的参数就是函数的参数。但是，如果我们希望在使用装饰器时可以更灵活一些，为不同的函数添加功能类似但又略有不同的装饰器呢？这时我们可以使用<strong>带参数的装饰器</strong>来实现（装饰器本身也是函数，是可以传入参数的）。</p>
<p>比方说要实现一个自定义打印文本的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>注意到这里在 <code>wrapper</code> 和 <code>log</code> 之间又套了一层函数，现在变为了 <code>log</code> 接收参数 <code>text</code> 并返回一个装饰器 <code>decorator</code>。这个 <code>decorator</code> 接收一个函数对象，输出文本 <code>text</code> 和函数对象的名字，理解起来其实不难。</p>
<p>使用这个装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log('execute')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2015-3-25'</span>)</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">execute now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>事实上，把 <code>@log</code> 放在 <code>now()</code> 函数的定义前，运行代码时实际上在函数定义后执行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">'execute'</span>)(now)</div></pre></td></tr></table></figure>
<p>也即是先调用 <code>log</code> 函数，传入参数 <code>log(&#39;execute&#39;)</code>，这时返回了 <code>decorator</code> 这个装饰器，然后传入了 <code>now</code> 函数，最后返回包装好的 <code>now</code> 函数（也即 <code>wrapper</code> 函数）。</p>
<hr>
<h3 id="属性复制"><a href="#属性复制" class="headerlink" title="属性复制"></a>属性复制</h3><p>前面已经提到使用 <strong><code>@语法</code></strong> 之后，now变量指向的函数名字等属性都改变了，变成了 <code>wrapper</code> 函数的，实际上，我们希望变量 <code>now</code> 的属性依然是原本 <code>now()</code> 函数的属性，这时就需要进行<strong>属性复制</strong>。</p>
<p>我们不需要编写类似 <code>wrapper.__name__ = func.__name__</code> 这样的代码来逐个把原函数的属性复制给 <code>wrapper</code>，Python内置的 <code>functools.wraps</code> 装饰器可以满足我们的需求。方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @functools.wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>和原来定义装饰器的代码对比，唯一修改的就是加上了 <code>@functools.wraps(func)</code> 这一句。 当然，还要注意先导入functools模块。</p>
<hr>
<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><h4 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h4><blockquote>
<p>编写一个decorator，能在函数调用的前后分别打印出 <code>&#39;begin call&#39;</code> 和 <code>&#39;end call&#39;</code> 的日志。</p>
</blockquote>
<p><strong>解析：</strong></p>
<p>这题很简单，在 <code>wrapper</code> 调用原函数之前，各编写一条打印语句就可以了。</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line">        print(<span class="string">"begin call"</span>)</div><div class="line">        a = func(*args,**kw)</div><div class="line">        print(<span class="string">"end call"</span>)</div><div class="line">        <span class="keyword">return</span> a</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"haha"</span>)</div></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now   <span class="comment"># now是一个函数</span></div><div class="line">&lt;function decorator.&lt;locals&gt;.wrapper at <span class="number">0x00000254B45D8EA0</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now() <span class="comment"># 调用now函数</span></div><div class="line">begin call</div><div class="line">haha</div><div class="line">end call</div></pre></td></tr></table></figure>
<h4 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h4><blockquote>
<p>写出一个@log的decorator，使它既支持：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<blockquote>
<p>又支持：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@log('execute')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<p>思路很简单，我们知道使用不带参数的装饰器时，传入装饰器函数（即这里的 <code>log</code>）的参数就是要装饰的函数（比方说 <code>now</code> 函数）；而带参数的装饰器接收的参数则不是要装饰的函数而是别的（比方说一个字符串）。所以呀，我们可以依然使用带参数的装饰器作为原型，但在里面加入对参数类型的判断，如果接收到字符串参数则表示这次调用的是有参数的装饰器，否则就是调用不带参数的装饰器。</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span> <span class="comment"># 默认参数，没有参数时，text就是空字符串</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">        @functools.wraps(func)    # 属性复制</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line">            <span class="keyword">if</span> isinstance(text, str):</div><div class="line">                print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                print(<span class="string">'%s():'</span> % func.__name__)</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">if</span> isinstance(text, str): <span class="comment"># 接收到字符串后返回decorator函数</span></div><div class="line">        <span class="keyword">return</span> decorator</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> decorator(text) <span class="comment"># 接收到函数则直接返回wrapper函数</span></div><div class="line"></div><div class="line"><span class="meta">@log('execute')  # 带参数text的decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now1</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div><div class="line"></div><div class="line"><span class="meta">@log             # 不带参数text的decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now2</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2016-2-10'</span>)</div></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now1()</div><div class="line">execute now1():</div><div class="line"><span class="number">2016</span><span class="number">-2</span><span class="number">-10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now2()</div><div class="line">now2():</div><div class="line"><span class="number">2016</span><span class="number">-2</span><span class="number">-10</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是<strong>偏函数（Partial function）</strong>。</p>
<p><code>functools.partial(f, *args, **kw)</code> 的作用就是创建一个偏函数，<strong>把一个函数的某些参数给固定住</strong>（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<p>举个例子，字符串转整型数的函数int，可以使用<strong>关键字参数base</strong>，指定字符串的进制是多少，然后转换为int的时候会按照base进行进制转换，把字符串<strong>转换成十进制整数</strong>。 如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1000000'</span>, base=<span class="number">2</span>)</div><div class="line"><span class="number">64</span></div></pre></td></tr></table></figure>
<p>如果有大量的二进制字符串要转换，每次都写base=2很麻烦，我们就会希望定义一个新函数，把base参数固定为2，无须每次指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> int(x, base)</div></pre></td></tr></table></figure>
<p>实际上我们不需要自己定义，使用 <code>functools.partial</code> 就可以轻松创建偏函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</div><div class="line"><span class="number">64</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</div><div class="line"><span class="number">85</span></div></pre></td></tr></table></figure>
<p>运行int(‘1000000’)实际相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kw = &#123; <span class="string">'base'</span>: <span class="number">2</span> &#125;</div><div class="line">int(<span class="string">'1000000'</span>, **kw)</div></pre></td></tr></table></figure>
<p><strong>Notice</strong>：</p>
<p>这里创建偏函数只是设定了默认值为2，<strong>调用偏函数时依然可以把参数设置为其他值</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>, base=<span class="number">10</span>)</div><div class="line"><span class="number">1000000</span></div></pre></td></tr></table></figure>
<p><code>functools.partial</code> <strong>不但可以接收关键字参数，还可以接收可变参数</strong> <code>*args</code>，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>max2 = functools.partial(max, <span class="number">10</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>相当于max函数每次接收到若干数字时，都默认再放入一个整数10，然后找其中的最大值。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-03高级特性]]></title>
      <url>http://2wildkids.com/2016/11/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#切片">切片</a></li>
<li><a href="#迭代">迭代</a></li>
<li><a href="#列表生成式">列表生成式</a><ul>
<li><a href="#生成器">生成器</a></li>
<li><a href="#杨辉三角">杨辉三角</a></li>
</ul>
</li>
<li><a href="#迭代器">迭代器</a><ul>
<li><a href="#小结">小结</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<p>在Python中，代码越少越简单约好。基于这一思想，后面的几个篇章介绍Python一些非常有用的高级特性。</p>
<p>比方说构造一个1~99的奇数列表，可以简单地用循环实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line">n = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> n &lt;= <span class="number">99</span>:</div><div class="line">    L.append(n)</div><div class="line">    n = n + <span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片即取一个list或tuple部分元素的操作。 当我们需要取列表前n个元素，即索引0~<strong>N-1</strong>的元素时，有两种方法：</p>
<p>1.方法1是用循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line"><span class="meta">... </span>    r.append(L[i])</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>2.方法2是利用<strong>切片操作符</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>如果经常要取指定的索引范围，用循环就显得太过繁琐了，Python提供了切片操作来简化这个过程。注意，<strong>切片操作的索引左闭右开</strong>。</p>
<p>如果索引从0开始，还可以改写为 <code>L[:3]</code>。 如果索引到列表最后结束，同样可以简略写为 <code>L[0:]</code>。</p>
<p>此外，Python还支持<strong>倒数切片</strong>。<strong>列表最后一项的索引在倒数中为-1</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</div><div class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</div><div class="line">[<span class="string">'Bob'</span>]</div></pre></td></tr></table></figure>
<p>特别地，切片操作还支持每隔k个元素取1个这样的操作。先创建一个0~99的整数列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</div></pre></td></tr></table></figure>
<p>取后10个只需起始索引为-10即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-10</span>:]</div><div class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</div></pre></td></tr></table></figure>
<p>前十个数隔两个取一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p>所有数，隔五个取一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</div></pre></td></tr></table></figure>
<p>注意！<strong>对list进行切片操作得到的还是list；对tuple进行切片操作得到的还是tuple</strong>。 特别地，<strong>字符串也可看为一种list，同样可以使用切片操作</strong>。</p>
<hr>
<p><br></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>Python中可迭代的对象包括字符串，list，tuple，dict，set和文件等等。 对这些可迭代对象可以使用 <code>for...in</code> 循环来遍历。Python对for循环的抽象程度高于Java和C，所以即使没有下标也能迭代。</p>
<p>比如循环遍历一个dict：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</div><div class="line"><span class="meta">... </span>  print(key, d[key])</div><div class="line">...</div><div class="line">a <span class="number">1</span></div><div class="line">c <span class="number">3</span></div><div class="line">b <span class="number">2</span></div></pre></td></tr></table></figure>
<p>直接打印key会打印所有dict中的key，更改迭代的写法为 <code>for value in d.values()</code> 就变为迭代dict中所有的value。 如果同时要访问key和value，还可以使用 <code>for k, v in d.items()</code>。</p>
<p>字符串同样可以用for循环迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'ABC'</span>:</div><div class="line"><span class="meta">... </span>    print(ch)</div><div class="line">...</div><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure>
<p>要<strong>判断一个对象是否可迭代对象可以通过collections模块的 <code>Iterable</code> 类型</strong>来判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>正如上面迭代dict一样，for循环可以同时引用两个甚至多个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</div><div class="line"><span class="meta">... </span>    print(i, value)</div><div class="line">...</div><div class="line"><span class="number">0</span> A</div><div class="line"><span class="number">1</span> B</div><div class="line"><span class="number">2</span> C</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</div><div class="line"><span class="meta">... </span>    print(x, y)</div><div class="line">...</div><div class="line"><span class="number">1</span> <span class="number">1</span></div><div class="line"><span class="number">2</span> <span class="number">4</span></div><div class="line"><span class="number">3</span> <span class="number">9</span></div></pre></td></tr></table></figure>
<p>例子里的 <code>enumerate</code> 方法通过<a href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="external">enumerate官方文档</a>了解，它返回一个枚举对象，并且传入参数可迭代时它就是一个可迭代的对象。</p>
<p><strong>可以用 <code>list(enumerate(可迭代对象))</code> 把一个可迭代对象变为元素为tuple类型的list</strong>，每个tuple有两个元素，形式如：<code>(序号，原可迭代对象内容)</code>。</p>
<p>并且使用enumerate时可以指定开始的序号，<code>enumerate(iterable, start=0)</code>，不写时默认参数为0，即序号从0开始。 可以自己指定为其他数。</p>
<hr>
<p><br></p>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的用于创建list的方式。</p>
<p>比方说生成1到10，可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>要生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code>平方序列，笨办法是用循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</div><div class="line"><span class="meta">... </span>   L.append(x * x)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>用列表生成式只用一个语句就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素 <code>x * x</code> 放到前面，后面跟for循环，就可以把list创建出来。</p>
<p>在for循环后面还可以加上if判断，比方说这个例子用于筛选出偶数的平方数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>使用两层循环还可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</div><div class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</div></pre></td></tr></table></figure>
<p>列出当前目录下所有文件和目录名也非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></div><div class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.Trash'</span>,  <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>]</div></pre></td></tr></table></figure>
<p>前面一节提到for循环迭代可以同时用两个变量，这里列表生成式同样可以用两个变量来生成list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</div><div class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</div></pre></td></tr></table></figure>
<p>把list中所有字符串的大写字母换成小写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</div><div class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>通过列表生成式可以简单地创建列表，但受到内存限制，列表容量是有限的。如果列表元素很多，而我们仅需访问前面一部分元素，则会造成很大的存储空间的浪费。</p>
<p><strong>生成器(generator)</strong>就意在解决这个问题，允许在循环过程中不断推算出后续元素，而不用创建完整的list。在Python中，这种边循环边计算的机制称为生成器。</p>
<p>和列表生成式的区别很简单，仅仅是把外层的<strong>[]方括号</strong>换成<strong>()圆括号</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</div></pre></td></tr></table></figure>
<p>生成器无法通过索引访问，因为它<strong>保存的是算法</strong>，要遍历生成器需要通过 <code>next()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure>
<p>当到达最后一个元素时，再使用 <code>next()</code> 就会出现 <code>StopIteration</code> 错误。 当然，实际遍历生成器时不会这样一个一个用 <code>next()</code> 方法遍历，用for循环进行迭代即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure>
<p>当算法比较复杂，用简单for循环无法写出来时，还可以通过函数来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        print(b)</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div></pre></td></tr></table></figure>
<p>比方说这个计算斐波那契数列的函数，稍微改写一下即可变成generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b  <span class="comment">#只修改这里</span></div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div></pre></td></tr></table></figure>
<p>这是定义generator的另一种方法，<strong>如果一个函数定义中包含yield关键字，则该函数就变为一个generator</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;generator object fib at <span class="number">0x104feaaa0</span>&gt;</div></pre></td></tr></table></figure>
<p>函数是顺序执行，遇到return语句或到达最后一行函数语句就返回。而变成generator的函数，在每次调用 <code>next()</code> 的时候执行，<strong>遇到yield就返回</strong>，下次执行会从yield的地方开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>同样地，把函数改成generator后，我们不需要用next()方法获取写一个返回值，而是只借用for循环进行迭代。</p>
<p>但是这样就拿不到fib函数return语句的值(即字符串done)，要获取这个值必须捕获 <code>StopIteration</code> 这个错误，它的value就是我们返回的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</div><div class="line"><span class="meta">... </span>        x = next(g)</div><div class="line"><span class="meta">... </span>        print(<span class="string">'g:'</span>, x)</div><div class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line"><span class="meta">... </span>        print(<span class="string">'Generator return value:'</span>, e.value)</div><div class="line"><span class="meta">... </span>        <span class="keyword">break</span></div><div class="line">...</div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">2</span></div><div class="line">g: <span class="number">3</span></div><div class="line">g: <span class="number">5</span></div><div class="line">g: <span class="number">8</span></div><div class="line">Generator <span class="keyword">return</span> value: done</div></pre></td></tr></table></figure>
<p>生成器的工作原理是：在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。</p>
<p>对于函数改成的generator来说，<strong>遇到return语句或者执行到函数体最后一行语句就结束generator</strong>，for循环随之结束。</p>
<p>普通函数和生成器函数可以通过调用进行区分，调用普通函数会直接返回结果，调用生成器函数则会返回一个生成器对象。</p>
<hr>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>要求使用生成器生成1~10行的杨辉三角。 提示：把每一行当作一个list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">(max)</span>:</span></div><div class="line">    n = <span class="number">0</span></div><div class="line">    b = [<span class="number">1</span>]</div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b</div><div class="line">        b = [<span class="number">1</span>] + [ b[i] + b[i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b) - <span class="number">1</span>)] + [<span class="number">1</span>]</div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这段代码非常短，但是已经充分实现了题目要求，值得欣赏!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> L <span class="keyword">in</span> triangles(<span class="number">6</span>):</div><div class="line"><span class="meta">... </span>    L</div><div class="line">...</div><div class="line">[<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>代码里面有两个窍门，一是列表相加，注意不是列表元素相加。 列表相加相当于把后一个列表的元素全部append到前一个列表。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>R = [<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L+R</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<p>上面代码中的b即把每一行当作一个list，因为每一行的开头结尾都是1，所以可以每一行的list看作三个list的相加，一头一尾两个list是只有1个元素1的list，中间的list用列表生成式生成。</p>
<p>另一个窍门就是这里的列表生成式。 注意这里计算时还没赋值，引用列表b的内容是上一行的信息，所以能巧妙地借助上一行计算相邻两数之和，最终得到含有n-2项的中间列表。</p>
<p>补充解析一下代码执行的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b = [<span class="number">1</span>], n = <span class="number">0</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>] = [<span class="number">1</span>,<span class="number">1</span>], n = <span class="number">1</span> <span class="comment"># 无中间列表</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">2</span> <span class="comment"># 中间列表包含1个元素</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">2</span>, <span class="number">2</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">3</span> <span class="comment"># 中间列表包含2个元素</span></div><div class="line">b = [<span class="number">1</span>] + [<span class="number">1</span>+<span class="number">3</span>, <span class="number">3</span>+<span class="number">3</span>, <span class="number">3</span>+<span class="number">1</span>] + [<span class="number">1</span>], n = <span class="number">4</span> <span class="comment"># 中间列表包含4个元素</span></div><div class="line"><span class="meta">... </span>...</div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器即<strong>Iterator</strong>， 前面说到可以通过<strong>collections模块</strong>的<strong>Iterable类型</strong>来判断一个对象是否可迭代对象。 这里引入Iterator的概念，可以通过类似的方式判断。</p>
<p><strong>list，dict，str虽然都Iterable，却不是Iterator</strong>。 生成器都是Iterator。<strong>Iterator的特性允许对象通过next()函数不断返回下一个值</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p><strong>要把list，dict，str变为Iterator可以使用 <code>iter()</code> 函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>Python的Iterator对象表示的其实是一个<strong>数据流</strong>，Iterator对象可以被 <code>next()</code> 函数调用并不断返回下一个数据，直到没有数据时抛出 <code>StopIteration</code> 错误。</p>
<p>可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 <code>next()</code> 函数实现按需计算下一个数据，所以 <code>Iterator</code> 的计算是惰性的，只有在需要返回下一个数据时它才会计算，也因此能够节省空间。</p>
<p>Iterator甚至可以表示一个<strong>无限大的数据流</strong>，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>凡是可作用于for循环的对象都是 <code>Iterable</code> 类型；</p>
<p>凡是可作用于 <code>next()</code> 函数的对象都是 <code>Iterator</code> 类型，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是 <code>Iterable</code> 但不是 <code>Iterator</code>，不过可以通过 <code>iter()</code> 函数获得一个 <code>Iterator</code> 对象。</p>
<p>Python的<strong>for循环本质上就是通过不断调用 <code>next()</code> 函数实现的</strong>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>实际上完全等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先获得Iterator对象:</span></div><div class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment"># 循环:</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 获得下一个值:</span></div><div class="line">        x = next(it)</div><div class="line">    <span class="keyword">except</span> StopIteration:</div><div class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-02函数]]></title>
      <url>http://2wildkids.com/2016/11/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#定义函数">定义函数</a><ul>
<li><a href="#空函数">空函数</a></li>
<li><a href="#参数检查">参数检查</a></li>
<li><a href="#返回多个值">返回多个值</a></li>
</ul>
</li>
<li><a href="#函数的参数">函数的参数</a><ul>
<li><a href="#位置参数">位置参数</a></li>
<li><a href="#默认参数">默认参数</a></li>
<li><a href="#可变参数">可变参数</a></li>
<li><a href="#关键字参数">关键字参数</a></li>
<li><a href="#命名关键字参数">命名关键字参数</a></li>
<li><a href="#参数组合">参数组合</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#递归函数">递归函数</a><ul>
<li><a href="#汉诺塔">汉诺塔</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>Python支持函数，不仅可以灵活地自定义函数，而且本身也内置了很多有用的函数。</p>
<p>除了可以使用help(函数名)查看内置函数（<strong>built-in function, BIF</strong>）的用法和用途，也可以直接查看<a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">官方文档</a>。</p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个<strong>别名</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义函数要使用 <code>def</code> 语句，依次写出 <em>函数名</em>、<em>括号</em>、<em>括号中的参数</em> 和<em>冒号</em>，然后，在缩进块中编写函数体，函数的返回值用 <code>return</code> 语句返回。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> -x</div></pre></td></tr></table></figure>
<p>注意，如果没有return语句，则函数执行完毕也会返回 <code>None</code>，如果想要函数返回 <code>None</code>，除了写 <code>return None</code> 之外还可以直接写 <code>return</code>。</p>
<p>我们既可以直接在命令行定义函数，也可以把函数放在 <code>.py</code> 文件中定义。若采用后者,则使用函数时要先把工作目录跳转到文件保存的目录，再启动Python，然后用 <code>from 文件名 import 函数名</code> 即可导入函数。(这里文件名不需要包含文件扩展名 <code>.py</code>)</p>
<p>比方说把上面的 <code>my_abs</code> 函数写入到 <code>my_abs.py</code> 文件中，保存在桌面，使用该函数需要先 <code>cd</code> 到桌面目录，然后再导入和使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator&gt;cd Desktop</div><div class="line"></div><div class="line">C:\Users\Administrator\Desktop&gt;python</div><div class="line">Python <span class="number">3.5</span><span class="number">.1</span> |Anaconda <span class="number">4.0</span><span class="number">.0</span> (<span class="number">64</span>-bit)| (default, Feb <span class="number">16</span> <span class="number">2016</span>, <span class="number">09</span>:<span class="number">49</span>:<span class="number">46</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</div><div class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_abs <span class="keyword">import</span> my_abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">5</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">0</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">-5</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果还没想好怎么写一个函数，可以用 <code>pass</code> 语句来实现一个空函数，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><code>pass</code> 语句什么都不做，但可以用来做占位符。用在其他语句中也可以，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>当<strong>参数个数不对</strong>时，Python解释器会抛出 <code>TypeError</code> 错误，但是当<strong>参数类型错误</strong>时，如果函数里面没有给出对应的方法，Python解释器就无法抛出正确的错误提示信息。</p>
<p>上面实现的 <code>my_abs</code> 函数还不够完善，使用Python的内置函数 <code>isinstance()</code> 和 <code>raise</code> 语句来实现类型检查并报错的功能，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</div><div class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</div><div class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> -x</div></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">'a'</span>) <span class="comment"># 参数类型错误</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> my_abs</div><div class="line">TypeError: bad operand type</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 参数个数错误</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</div></pre></td></tr></table></figure>
<hr>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>举一个返回坐标点的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    <span class="keyword">return</span> nx, ny</div></pre></td></tr></table></figure>
<p>这里用到math包的函数 <code>cos</code> 和 <code>sin</code>，返回坐标点的两个维度的值。接收时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(x)</div><div class="line"><span class="number">151.96152422706632</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(y)</div><div class="line"><span class="number">70.0</span></div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</div><div class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</div></pre></td></tr></table></figure>
<p>实际上，在Python中，函数返回的仍然是一个变量，但<strong>在返回多个值时，Python会将它们合并为一个tuple返回</strong>，又因为语法上返回一个tuple可以省略括号，所以可以直接写成返回多个值的形式。 特别地，我们可以使用多个变量来接收一个返回的tuple，Python会按位置顺序来赋对应的值。</p>
<hr>
<p><br></p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数。</p>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>传入值按位置顺序依次赋给参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></div><div class="line">    s = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">        n = n - <span class="number">1</span></div><div class="line">        s = s * x</div><div class="line">    <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>如这个幂函数，调用时使用 <code>power(5,2)</code> 这样的格式即可，5和2会按位置顺序分别被赋给变量x和n。</p>
<hr>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>有时候我们希望函数带有默认设置，比方说令幂函数默认计算平方，这样就不需要每次都传入参数n了。 可以使用默认参数来实现这样的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></div><div class="line">s = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">    n = n - <span class="number">1</span></div><div class="line">    s = s * x</div><div class="line"><span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>此时使用 <code>power(5)</code> 也能调用幂函数，计算的是5的平方。</p>
<p>在编写函数的参数列表时，应当注意：</p>
<ol>
<li>必选参数在前，默认参数在后，否则Python的解释器会报错。</li>
<li>有多个参数时，把变化大的参数放前面，变化小的参数放后面。这样我们可以把变化小的参数设为默认参数，调用的时候就不需要每次都填写这个参数了。</li>
</ol>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender, age=<span class="number">6</span>, city=<span class="string">'Beijing'</span>)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name)</div><div class="line">    print(<span class="string">'gender:'</span>, gender)</div><div class="line">    print(<span class="string">'age:'</span>, age)</div><div class="line">    print(<span class="string">'city:'</span>, city)</div></pre></td></tr></table></figure>
<p>age和city是默认参数，调用时可以不提供。并且提供默认参数时既可以按顺序也可以不按顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enroll(<span class="string">'Bob'</span>, <span class="string">'M'</span>, <span class="number">7</span>)</div><div class="line">enroll(<span class="string">'Adam'</span>, <span class="string">'M'</span>, city=<span class="string">'Tianjin'</span>)</div></pre></td></tr></table></figure>
<p>按顺序不需指定参数名，<strong>不按顺序时则必须提供参数名，这样其他未提供的参数依然使用默认参数的值</strong>。</p>
<p>注意<strong>默认参数必须指向不可变对象</strong>！举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<p>多次使用默认参数时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure>
<p>可以看到这里默认参数的内容改变了，因为L是可变对象，每次调用add_end，函数会修改默认参数的内容。 所以切记默认参数要指向不可变对象，要实现同样的功能，使用None就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        L = []</div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<p>使用不可变对象做参数，在多任务环境下读取对象不需要加锁，同时读没有问题。因此能使用不可变对象就尽量用不可变对象。</p>
<hr>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数即<strong>传入的参数个数可变，传入任意个参数都可以</strong> 。先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></div><div class="line">    sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>这个求和函数只有一个参数，必须传入一个list或者tuple才行，即 <code>calc([1, 2, 3，7])</code> 或者 <code>calc((1, 3, 5, 7))</code>。如果使用可变参数，则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></div><div class="line">    sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>只是在参数前面加了一个 <code>*</code> 号，函数内容不需要改变。这样定义的函数可以使用任意个数的参数，包括0个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>传入参数时不需要构建list或者tuple，<strong>函数接收参数时会自动构建为一个tuple</strong>。 如果已经有一个list或者tuple要调用可变参数也很方便，<strong>将它变成可变参数</strong>就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums) <span class="comment"># 在列表前面加上一个星号即可完成转换</span></div><div class="line"><span class="number">14</span></div></pre></td></tr></table></figure>
<p>同样只需要加一个 <code>*</code> 号即可完成转换。</p>
<p>args是一个tuple类型的对象，<strong>没有传入时就是一个空的tuple</strong>。</p>
<hr>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许传入0个或任一个参数，这些可变参数会自动组装为一个tuple。 而<strong>关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数会自动组装为一个dict</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</div></pre></td></tr></table></figure>
<p>调用时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</div><div class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</div><div class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>kw是一个dict类型的对象，<strong>没有传入时就是一个空的dict</strong>。 和可变参数类似，先组装一个dict然后再传入也是可以的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>或者进行转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra) <span class="comment"># 在字典前面加上两个星号即可完成转换</span></div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>这里使用 <code>**</code> 转换的实质是把extra拷贝一份，然后令kw指向这个拷贝，所以<strong>函数内的操作不会对函数外的extra有任何影响</strong>。</p>
<hr>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>关键字参数的自由度很大，但有时我们需要限制用户可以传入哪些参数，这时就需要用到命名关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></div><div class="line">    print(name, age, city, job)</div></pre></td></tr></table></figure>
<p>和关键字参数不同，这里<strong>采用一个 <code>*</code> 号作为分隔符</strong>，<code>*</code> 号后面的参数被视为关键字参数。 调用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">Jack <span class="number">24</span> Beijing Engineer</div></pre></td></tr></table></figure>
<h4 id="错误举例"><a href="#错误举例" class="headerlink" title="错误举例"></a>错误举例</h4><p><strong>1.没有给参数名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</div></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，如果没有参数名，Python解释器会视其为位置参数，从而报参数个数超出的错误。</p>
<p><strong>2.没有传入参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#83&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>)</div><div class="line">TypeError: person() missing <span class="number">2</span> required keyword-only arguments: <span class="string">'city'</span> <span class="keyword">and</span> <span class="string">'job'</span></div></pre></td></tr></table></figure>
<p><strong>命名关键字参数若没有定义默认值则被视为必选参数</strong>。 可以为命名关键字参数设置默认值， 比如 <code>def person(name, age, *, city=&#39;Beijing&#39;, job):</code>，这样即使不传入也不会报错了。</p>
<p><strong>3.传入没有定义的参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, joc=<span class="string">'Engineer'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#84&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, joc=<span class="string">'Engineer'</span>)</div><div class="line">TypeError: person() got an unexpected keyword argument <span class="string">'joc'</span></div></pre></td></tr></table></figure>
<p><strong>命名关键字参数限制了可以传入怎样的参数，如果传入参数的参数名不在其中也会报错。</strong></p>
<hr>
<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数除了<strong>可变参数和命名关键字参数无法混合</strong>，可以任意组合必选参数、默认参数、可变参数、关键字参数和命名关键字参数。</p>
<p>注意！<strong>参数定义的顺序必须是： <code>必选参数 -&gt; 默认参数 -&gt; 可变参数/命名关键字参数 -&gt; 关键字参数</code></strong>。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></div><div class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></div><div class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</div></pre></td></tr></table></figure>
<p>除了这种普通的调用方式，通过tuple和dict也可以很神奇地调用！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</div><div class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div></pre></td></tr></table></figure>
<p>赋值是按照上面的固定顺序来进行的！<strong>对于任意函数，都可以通过类似 `func(*args, </strong>kw)` 的形式调用它，无论它的参数是如何定义的**。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p><strong>默认参数一定要用不可变对象</strong>，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code> 是可变参数，<code>*args</code> 接收的是一个<strong>tuple</strong>；</p>
<p><code>**kw</code> 是关键字参数，<code>**kw</code> 接收的是一个<strong>dict</strong>。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p><strong>可变参数既可以直接传入</strong>：func(1, 2, 3)，<strong>又可以先组装list或tuple</strong>，再通过 <code>*args</code> 传入： <code>func(*(1, 2, 3))</code>；</p>
<p><strong>关键字参数既可以直接传入</strong>：func(a=1, b=2)，<strong>又可以先组装dict</strong>，再通过 <code>**kw</code> 传入： <code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<p>使用 <code>*args</code> 和 <code>**kw</code> 这两个名字是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名关键字参数是为了限制调用者可以传入的参数名，并且我们可以为其提供默认值。</p>
<p><em>*定义命名关键字参数不要忘了写分隔符 `</em>` ，否则定义的将是位置参数。</p>
<hr>
<p><br></p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>若一个函数在函数内部调用自身，则该函数是一个递归函数。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>阶乘函数就是一个递归函数，<strong>使用递归函数需要注意防止栈溢出</strong>。在计算机中，函数调用是通过<strong>栈（stack）</strong>这种数据结构实现的。</p>
<p>每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。<strong>由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</strong>。</p>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，尾递归和循环效果一样，实际上可以把循环看作特殊的尾递归函数。</p>
<p><strong>尾递归要求函数返回时调用自身本身而不能包含表达式</strong>。这样编译器或解释器就可以把尾递归进行优化，无论递归了多少次都只占用一个栈帧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">  <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></div><div class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> product</div><div class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</div></pre></td></tr></table></figure>
<p>之前的函数定义有乘法表达式，所以不是尾递归。</p>
<p>计算过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">===&gt; fact(<span class="number">5</span>)</div><div class="line">===&gt; <span class="number">5</span> * fact(<span class="number">4</span>)</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * fact(<span class="number">3</span>))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * fact(<span class="number">2</span>)))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * fact(<span class="number">1</span>))))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * <span class="number">2</span>))</div><div class="line">===&gt; <span class="number">5</span> * (<span class="number">4</span> * <span class="number">6</span>)</div><div class="line">===&gt; <span class="number">5</span> * <span class="number">24</span></div><div class="line">===&gt; <span class="number">120</span></div></pre></td></tr></table></figure>
<p>这里改为在函数调用前先计算product，每次递归仅调用函数本身就可以了。</p>
<p>计算过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">===&gt; fact_iter(<span class="number">5</span>, <span class="number">1</span>)</div><div class="line">===&gt; fact_iter(<span class="number">4</span>, <span class="number">5</span>)</div><div class="line">===&gt; fact_iter(<span class="number">3</span>, <span class="number">20</span>)</div><div class="line">===&gt; fact_iter(<span class="number">2</span>, <span class="number">60</span>)</div><div class="line">===&gt; fact_iter(<span class="number">1</span>, <span class="number">120</span>)</div><div class="line">===&gt; <span class="number">120</span></div></pre></td></tr></table></figure>
<p>可惜<strong>Python标准的解释器没有对尾递归做优化，所以即使改为尾递归的写法还是有可能产生栈溢出</strong>。</p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>a有n个盘子（从上到下由轻到重），要求只借助a，b，c三个支架，把所有盘子移动到c。并且重的盘子不可以在轻的盘子上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a,<span class="string">' --&gt; '</span>,c)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        move(n<span class="number">-1</span>,a,c,b)    <span class="comment">#将前n-1个盘子从A移动到B上</span></div><div class="line">        print(a,<span class="string">' --&gt; '</span>,c) <span class="comment">#将最底下的最后一个盘子从A移动到C上</span></div><div class="line">        move(n<span class="number">-1</span>,b,a,c)    <span class="comment">#将B上的n-1个盘子移动到C上</span></div></pre></td></tr></table></figure>
<p>代码很短，思路很清晰，基于规则，每次只能把余下盘子中最重的移到c上。 这里通过改变传入参数的顺序可以灵活使用三个支架。 a在一次移动中可能充当b的角色，b，c也可能充当a的角色。</p>
<p>但总的来说，我们都是希望把充当a的支架上n-1个盘子先移到充当b的支架上，再把a的剩下的最重的一个盘子移动到充当c的支架上，然后递归，这时充当b的支架就变成a，充当a的支架就变成b，直到最后完成所有移动。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-01Python基础]]></title>
      <url>http://2wildkids.com/2016/10/21/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01Python%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>该笔记记录的是学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000#0" target="_blank" rel="external">廖雪峰Python3教程</a>的过程，摘录了一些重点，重新编排内容，并加入了更丰富的代码示例和对学习过程中所遇到问题的理解。</p>
<p>本章内容安排如下：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#数据类型和变量">数据类型和变量</a><ul>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#常量">常量</a></li>
</ul>
</li>
<li><a href="#使用list和tuple">使用list和tuple</a><ul>
<li><a href="#list">list</a></li>
<li><a href="#tuple">tuple</a></li>
</ul>
</li>
<li><a href="#使用dict和set">使用dict和set</a><ul>
<li><a href="#dict">dict</a></li>
<li><a href="#set">set</a></li>
<li><a href="#再议不可变对象">再议不可变对象</a></li>
</ul>
</li>
<li><a href="#条件判断">条件判断</a><ul>
<li><a href="#条件判断-1">条件判断</a></li>
<li><a href="#再议input">再议input</a></li>
<li><a href="#循环">循环</a></li>
</ul>
</li>
<li><a href="#字符串和编码">字符串和编码</a><ul>
<li><a href="#字符编码">字符编码</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#格式化">格式化</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python可以直接表达的数据类型包括：整数，浮点数，复数，字符串，布尔值和空值。</p>
<h5 id="整数-int"><a href="#整数-int" class="headerlink" title="整数 int"></a>整数 int</h5><p>任意大小，正负皆可。并且可以用0b、0o、0x分别表示二进制、八进制和十六进制数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0b10</span> <span class="comment"># 也可以是 0B10</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0o10</span> <span class="comment"># 也可以是 0O10</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0x10</span> <span class="comment"># 也可以是 0X10</span></div><div class="line"><span class="number">16</span></div><div class="line"></div><div class="line"><span class="comment"># 十进制转其他进制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">2</span>)</div><div class="line"><span class="string">'0b10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">8</span>)</div><div class="line"><span class="string">'0o10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">16</span>)</div><div class="line"><span class="string">'0x10'</span></div><div class="line"></div><div class="line"><span class="comment"># 其他进制转十进制（也可将字符串转换为十进制）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0b10</span>) <span class="comment"># 也可以是 int('10', 2)</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0o10</span>) <span class="comment"># 也可以是 int('10', 8)</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0x10</span>) <span class="comment"># 也可以是 int('10', 16)</span></div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>除了普通的写法之外，也可使<strong>用科学记数法</strong>，即1.23x10^9就是1.23e9 ，0.000012可以写成1.2e-5，等等。</p>
<p><strong>整数运算永远是精确的(结果也是整数)，浮点数运算则有四舍五入的误差</strong>。</p>
<p>Python提供两种除法+求余运算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><code>/</code></strong></td>
<td style="text-align:center">结果为浮点数，即使两数整除，<strong>结果也是浮点数</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>//</code></strong></td>
<td style="text-align:center">结果为整数，也称地板除，对<strong>结果向下取整</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>%</code></strong></td>
<td style="text-align:center">结果为整数，用于计算余数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p>Python中复数用j表示虚数部分，比如说 <code>x=2.4 + 5.6j</code>， 并且可以通过复数的类属性 <code>real</code> 取得实部，类属性 <code>imag</code> 取得虚部，通过类方法 <code>conjugate()</code> 获得共轭复数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">2.4</span> + <span class="number">5.6j</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</div><div class="line"><span class="number">2.4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</div><div class="line"><span class="number">5.6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.conjugate()</div><div class="line">(<span class="number">2.4</span><span class="number">-5.6j</span>)</div></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>使用单引号或双引号括起。而引号本身需要使用转义符<code>\</code>来表达。 用<code>\&#39;</code>来表示<code>&#39;</code>。</p>
<p>转义符还可以用来转义很多字符，如<code>\n</code>表示换行。<code>\t</code>表示制表符。 <code>\</code>本身也需要转义用 <strong>双斜杠</strong> 来代替。</p>
<p>如果一个字符串中很多字符都要转义就会很麻烦，所以Python又提供一种简便的写法，<strong><code>r&#39;&#39;</code>表示两个引号之间的内容是不需要转义的</strong>。 对于多行的字符串，为了避免加入<code>\n</code>的不方便，可以使用<code>&#39;&#39;&#39;something&#39;&#39;&#39;</code>的格式，即<strong>用三个引号来括起字符串，换行会被保留</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 没使用三引号</div><div class="line">&gt;&gt;&gt; a = '123</div><div class="line">  File "&lt;stdin&gt;", line 1</div><div class="line">a = '123</div><div class="line">   ^</div><div class="line">SyntaxError: EOL while scanning string literal</div><div class="line"></div><div class="line"># 使用了三引号</div><div class="line">&gt;&gt;&gt; a = '''123</div><div class="line">... 456</div><div class="line">... 789'''</div><div class="line">&gt;&gt;&gt; a</div><div class="line">'123\n456\n789'</div></pre></td></tr></table></figure>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>只有True和False两种，首字母大写。如果输入一个判断式，则Python会给出布尔值的结果。比方说输入3&gt;2，运行后会得到True。 对于布尔值有三个逻辑运算符，分别是and，or和not。 <strong>本质上True用1存储，False用0存储</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> != <span class="number">0</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == <span class="keyword">False</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><p>Python中用None表示，<strong>不同于数值0</strong>。数值0是有意义的，而None是一个特殊的空值。可以将None赋值给变量，但无法创建None以外的其他NoneType对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; a = None</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class 'NoneType'&gt;</div><div class="line">&gt;&gt;&gt; None == a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; None == ''</div><div class="line">False</div><div class="line">&gt;&gt;&gt; None == 0</div><div class="line">False</div></pre></td></tr></table></figure>
<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>Python是一门动态类型语言</strong>，这意味着在Python中，<strong>可以反复把任意数据类型的对象赋值给同一个变量</strong>，相比起静态语言更加地灵活。</p>
<p>在Python中变量名不可以以数字开头，构成可以包括大小写英文，数字及下划线。</p>
<p>当我们写：a=’ABC’ 时，Python解释器干了两件事情：</p>
<ol>
<li>在内存中创建了一个值为<code>&#39;ABC&#39;</code>的字符串对象；</li>
<li>在内存中创建了一个名为a的变量，并把它指向对象<code>&#39;ABC&#39;</code>。</li>
</ol>
<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>Python中没有常量</strong>，因为变量都可以重复赋值。但是一般<strong>约定用全部字母大写的单词来表示一个常量</strong>，如：PI=3.14。</p>
<hr>
<p><br></p>
<h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种Python内置的数据类型，表示<strong>有序集合</strong>，可动态删除和插入。通过索引可以访问列表元素，<strong>索引从0开始</strong>，即访问第一个列表元素。并且列表是循环的，<strong>可以通过索引－1访问最尾的元素</strong>，索引－2访问倒数第二个元素。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</div><div class="line"><span class="string">'Michael'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</div><div class="line"><span class="string">'Tracy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>]</div><div class="line"><span class="string">'Bob'</span></div></pre></td></tr></table></figure>
<p>另外，还可以用 <code>len()</code> 函数获取列表的元素个数。</p>
<p>list 是一个<strong>可变的</strong>有序表，所以，可以往 list 中追加元素到末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>也可以把元素插入到指定的位置，比如索引号为 1 的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure>
<p>要删除 list 末尾的元素，用 pop() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</div><div class="line"><span class="string">'Adam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</div><div class="line"><span class="string">'Jack'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素的数据类型可以不同，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</div></pre></td></tr></table></figure>
<p>list 里面的元素也可以是另一个 list，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>] <span class="comment"># 四个元素，其中第三个元素是一个列表</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</div><div class="line"><span class="string">'python'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</div><div class="line">[<span class="string">'asp'</span>, <span class="string">'php'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">0</span>]</div><div class="line"><span class="string">'asp'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">1</span>]</div><div class="line"><span class="string">'php'</span></div></pre></td></tr></table></figure>
<p>要注意s只有4个元素，s[2]作为一个list类型的元素。要拿到’php’可以用 <code>s[2][1]</code>，即把s看作一个二维数组，这样的嵌套可以有很多层。</p>
<p>如果一个 list 中一个元素也没有，就是一个空的 list，它的长度为 0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(L)</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple也是一种<strong>有序列表</strong>，但<strong>tuple一旦初始化就无法再修改</strong>，也因为这个特性，所以代码更安全。和list不同，tuple用小括号来括起。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</div></pre></td></tr></table></figure>
<p>定义空的tuple如下如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">()</div></pre></td></tr></table></figure>
<p>但是，要<strong>定义一个只有1个元素的 tuple</strong>，就要注意一下，如果使用t = (1)来定义，则得到的不是一个tuple，而是整数1，因为括号既可以表示tuple又可以表示数学公式中的小括号。这种情况下默认为后者。要定义1个元素的tuple格式如下，使用一个逗号进行区分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line"><span class="number">1</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="number">1</span>,)</div></pre></td></tr></table></figure>
<p>tuple也有 “可变” 的例子，如果tuple的其中一个元素是list，则这个list元素的内容是可以修改的，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</div></pre></td></tr></table></figure>
<p>这个例子实际修改的是list而不是tuple，tuple指向的位置不会变，而list指向的位置可变，上面的例子实际上是创建了字符串X和Y，然后让tuple的第三个元素也即list元素指向这两个新的字符串。</p>
<hr>
<p><br></p>
<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict即字典，用于存储键值对，查找速度极快。如果使用list来存键值对就需要两个list，要先从key list找出key，再从value list找到对应项的值，因此list越长，耗时越长。用dict实现则可以直接根据key来找value。格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</div><div class="line"><span class="number">95</span></div></pre></td></tr></table></figure>
<p>dict速度快是因为Python内部像字典一样建立了索引，字典有部首表，Python内部也会根据不同key算出一个存放的「页码」(哈希算法)，所以速度非常快。除了初始化赋值还可以对同一个key进行多次赋值，会覆盖原来的value，如果key不存在就会对dict插入一个新的键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>] = <span class="number">20</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Lincoln'</span>] = <span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p>要判断key是否在dict里面有两种方法：</p>
<p>1.使用in关键字，有则返回True，无则返回False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>2.使用dict提供的get方法，有则返回key对应的value，无则返回空值None或者自己指定的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</div><div class="line"><span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>删除一个key则对应的value也会从dict中删除，使用pop方法来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</div><div class="line"><span class="number">75</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'Tracy'</span>: <span class="number">85</span>, <span class="string">'Michael'</span>: <span class="number">20</span>, <span class="string">'Lincoln'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>dict的插入和查找速度极快，不会随着key的增加而增加，但需要占用大量的内存</strong>，内存浪费多。list则相反，插入和查找时间随元素增加而增加，但占用空间少。所以dict是一种用空间换时间的方法，注意<strong>dict的key必须是不可变对象</strong>，无法修改key，不然dict就混乱了。<strong>字符串和整数等都可以作为key，list无法作为key</strong>。</p>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict的原理是一样的，同样<strong>不可以放入可变对象做key</strong>，唯一的区别是<strong>set只有key没有value</strong>。显然<strong>set里面是没有重复的元素的</strong>，不然哈希时会出错。<strong>set是有序的，需要使用列表/元组做初始化</strong>，定义方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>列表中有重复元素时set会自动被过滤</strong>，添加可以使用add方法，如s.add(4)。删除则用remove方法，如s.remove(4)。</p>
<p>集合可以看成数学意义上无序和无重复的集合，<strong>可以做交集、并集、差集等操作</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</div><div class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1-s2</div><div class="line">&#123;<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="再议不可变对象"><a href="#再议不可变对象" class="headerlink" title="再议不可变对象"></a>再议不可变对象</h3><p>Python中一切皆对象，而对象又分可变对象和不可变两类对象两类，具体来说，它们的差别就是<strong>对象的内容是否可变</strong>。不可变对象包括int, float, string, tuple，空值等，可变对象包括list, dict, set等。要注意对象和变量的关系，<strong>在Python里，变量都是对对象的引用</strong>。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'b'</span>  <span class="comment"># 字符串对象本身是不可变的</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"></div><div class="line"><span class="comment"># 变量可以指向另一个字符串对象</span></div><div class="line"><span class="comment"># 但字符串对象'abc'并没有改变，它依然存在于内存中</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'bbc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'bbc'</span></div></pre></td></tr></table></figure>
<p>关于参数传递，可以简单总结为以下两点：</p>
<ul>
<li>当一个可变对象作为函数参数时，函数内对参数修改会生效。</li>
<li>当一个不可变对象作为函数参数时，函数内对参数修改无效，因为实际上函数是创建一个新的对象并返回而已，没有修改传入的对象。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</div><div class="line">&gt;&gt; a</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<p>list是可变对象，使用函数操作，内容会变化，注意区分一下<strong>变量</strong>和<strong>对象</strong>，这里a是一个变量，它指向一个列表对象，这个列表对象的内容才是[‘c’, ‘b’, ‘a’]。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line"><span class="string">'Abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'abc'</span></div></pre></td></tr></table></figure>
<p>字符串是不可变对象，所以replace函数并不会修改变量a指向的对象，实际上调用不可变对象的任意方法都不改变该对象自身的内容，只会创建新对象并返回，如果使用一个新的变量来接收返回的对象，就能得到操作结果。不接收则直接打印，<strong>原变量指向的对象不会变化</strong>。</p>
<p>注意，虽然tuple是不可变对象，但是如果使用tuple作为dict或者set的key，还是有可能产生错误，因为tuple允许元素中包含列表，列表内容可变。如果使用了带有列表元素的tuple作为key就会报 <strong><code>TypeError: unhashable type: &#39;list&#39;</code></strong> 的错误。</p>
<hr>
<p><br></p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>Python中代码块是以缩进作区分的，<strong>if－else条件判断注意要在判定条件后写冒号，并且代码块都正确对齐。多个判断条件可以使用多个elif来实现</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">age = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</div><div class="line">print(<span class="string">'teenager'</span>)</div><div class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</div><div class="line">print(<span class="string">'adult'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">'kid'</span>)</div></pre></td></tr></table></figure>
<p>判断条件并不一定要是一个判断式，可以简写为一个变量，<strong>当变量为非零数值，非空字符串，非空list等时，判断为True，否则为False</strong>。</p>
<hr>
<h3 id="再议input"><a href="#再议input" class="headerlink" title="再议input"></a>再议input</h3><p>有时会采取 <strong><code>input(&#39;提示语句&#39;)</code></strong> 的方式读取用户输入，作为判定条件。要注意<strong>用户输入属于字符串类型</strong>，要进行数值比较必须先转换为对应的数据类型，否则会报错。</p>
<p>Python提供int(), float(), str()等方法进行数据类型的转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输入1表示Yes，输入0表示No</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>choose = input(<span class="string">'If you choose yes, please input 1. Otherwise, input 0: '</span>)</div><div class="line">If you choose yes, please input <span class="number">1.</span> Otherwise, input <span class="number">0</span>: <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> choose: <span class="comment"># 没有进行转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">Yes</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> int(choose): <span class="comment"># 进行了转换</span></div><div class="line"><span class="meta">... </span>print(<span class="string">'Yes'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>print(<span class="string">'No'</span>)</div><div class="line">...</div><div class="line">No</div></pre></td></tr></table></figure>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Python提供两种循环写法，一种是 <strong><code>for...in...</code></strong> 循环，一种是 <strong><code>while...</code></strong> 循环。for循环依次把list或tuple中的每个元素赋值给目标标识符，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> names:</div><div class="line"><span class="meta">... </span>print(name)</div><div class="line">...</div><div class="line">Michael</div><div class="line">Bob</div><div class="line">Tracy</div></pre></td></tr></table></figure>
<p>当列表为连续数值时，可以用range方法生成，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line"><span class="meta">... </span>sum = sum + x</div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>while循环的写法和if－else很相似，也是在判定条件后面加一个冒号。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">11</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>sum = sum + n</div><div class="line"><span class="meta">... </span>n = n - <span class="number">2</span></div><div class="line"><span class="meta">... </span>print(sum)</div><div class="line">...</div><div class="line"><span class="number">11</span></div><div class="line"><span class="number">20</span></div><div class="line"><span class="number">27</span></div><div class="line"><span class="number">32</span></div><div class="line"><span class="number">35</span></div><div class="line"><span class="number">36</span></div></pre></td></tr></table></figure>
<p>另外，对于死循环的程序，可以通过<strong>Ctrl＋C</strong> 强制终止。</p>
<hr>
<p><br></p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li><p>ASCII</p>
<blockquote>
<p>最早的编码，包含大小写英文，数字及一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8位二进制组合(1个字节)，可表示128个不同字符(最高位用于校验)。</p>
</blockquote>
</li>
<li><p>GB2312</p>
<blockquote>
<p>处理中文时一个字节显然不足，至少需要用两个字节，并且不与ASCII冲突，因此有了中国自己制定的GB2312编码，可用于编码中文。</p>
</blockquote>
</li>
<li><p>Shift_JIS和Euc-kr</p>
<blockquote>
<p>日本编码为Shift_JIS，韩文编码为Euc-kr。这样各个国家都用自己不同的标准和编码就很容易在多语言的环境产生冲突，变成乱码。因此又有了通用的一套编码。</p>
</blockquote>
</li>
<li><p>Unicode</p>
<blockquote>
<p>Unicode将所有语言统一到一套编码中，一般使用2个字节，部分非常偏僻的字符会用到4个字节。但是使用Unicode编码，如果在大量英文的环境又非常浪费空间，因为存储和传输时大小是使用ASCII编码的两倍，不划算，于是又有了新的方式。</p>
</blockquote>
</li>
<li><p>UTF-8</p>
<blockquote>
<p>UTF-8是可变长编码，对Unicode字符不同的数字大小编码成1-6个字节，英文字母为1个字节，汉字一般是3个字节。需要用到4-6字节的字符非常少，这样比较节省空间。</p>
</blockquote>
</li>
</ul>
<p><strong>Example</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">ASCII</th>
<th style="text-align:center">Unicode</th>
<th style="text-align:center">UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">01000001</td>
<td style="text-align:center">00000000 01000001</td>
<td style="text-align:center">01000001</td>
</tr>
<tr>
<td style="text-align:center">中</td>
<td style="text-align:center">(超出范围)</td>
<td style="text-align:center">01001110 00101101</td>
<td style="text-align:center">11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
</div>
<h4 id="插播一段课外知识"><a href="#插播一段课外知识" class="headerlink" title="插播一段课外知识"></a>插播一段课外知识</h4><p>摘录整理自知乎提问<a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a>。</p>
<p>为什么要分Unicode和UTF-8，它们两者有什么区别和关联呢？</p>
<p>其实最早的时候，由于各地区使用的编码方式不同，使用不同语言的人交流就成了一个大问题。国际标准组织ISO制订了统一的<strong>通用字符集（Universal Character Set，UCS）</strong>，也<strong>简称为Unicode</strong>。<strong>早期的Unicode版本对应于UCS-2编码方式</strong>，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示 2^16 也即 65536 个字符，基本满足各种语言的使用。根据维基的说法，当前最新版本的Unicode标准收录了128,000个字符，已经远远超出两字节所能表示的65536了。所以<strong>把Unicode视作UCS-2是一种过时的说法，Unicode标准存在多于两字节的字符</strong>。</p>
<p><strong>Unicode有多种字符编码实现方式</strong>。一个Unicode字符的code point是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，<strong>会使用不同的字符编码来实现Unicode</strong>。<strong>这些字符编码统称为Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong>。</p>
<p>例如，对于一个仅包含ASCII字符(只需要7位)的Unicode文件，如果每个字符都使用2字节的<strong>原Unicode编码</strong>传输，其第一字节的首位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用<strong>UTF-8编码，这是一种变长编码，它将ASCII字符仍用7位编码表示，占用一个字节（首位补0）</strong>。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以ASCII字符为主的西文文档就大大节省了编码长度。</p>
<p>但是，<strong>现在所说的Unicode一般都指的是字符集而非编码方式</strong>，廖雪峰老师在教程里提到的Unicode编码实际上指的是UCS-2这种编码方式。又因为以前UCS-2和UTF-16是等价的，所以微软的文档习惯把UTF16称为Unicode，这也导致很多开发者容易对此产生误会。</p>
<p>以上内容虽然有部分针对廖雪峰老师教程中描述不准确的地方进行了修改，但可能还是存在一些让人迷惑的说法，更详细的讲解可以看我的博文<a href="http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%EF%BC%8C%E4%BB%A5%E5%8F%8APython3%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">字符集与编码的恩怨情仇，以及Python3中的编码问题</a>。</p>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><p>在计算机存储中，内存统一使用Unicode编码，而硬盘保存或者传输数据就用UTF-8编码。比方说打开记事本时，数据会从硬盘中UTF-8编码格式转换为Unicode格式，保存时则相反。</p>
<p>浏览网页时，服务器端动态生成的内容是Unicode编码，而传输时则会变为传输UTF-8编码格式的网页。所以常常在网页源码中看到 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的语句，表示该网页正是用的UTF-8编码。</p>
<p><strong>按我的理解，可以这样总结：在传输/储存时，为了节省带宽/空间，会使用UTF-8这样的Unicode字符集的实现方式；而在计算机要处理的时候，应当使用原Unicode编码方式，也即每个字符都是固定两字节，这样字符长度统一更便于操作。</strong></p>
<p>特别注意，在涉及到字节流和字符串转换的程序里，我们<strong>应始终坚持使用UTF-8编码进行转换</strong>，从而避免乱码问题。</p>
<p>另外，代码本身也是文本，所以也有编码相关的问题。在编写Python脚本时，一般会在文件头部加入以下两句注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统则会忽略这个注释；</p>
<p>第二行注释是为了告诉<strong>Python解释器，按照UTF-8编码读取源代码</strong>，否则，如果源代码中有中文的话，就会出现乱码了。</p>
<p>注意，这里<strong>仅仅是声明了读取时采用UTF-8编码，但文件本身的编码不一定是UTF-8</strong>，要确定把代码文件编码为UTF-8格式，我们需要对写代码的IDE/文本编辑器进行相应的设置。廖老师提到，<strong>要确保使用UTF-8 without BOM编码</strong>，<strong>那么BOM和without BOM有什么区别呢？</strong>暂不在此进行讨论。</p>
<p>关于Python3中编码的信息，可以再看看<a href="https://docs.python.org/3/howto/unicode.html#introduction-to-unicode" target="_blank" rel="external">官方文档</a>。</p>
<hr>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><p>Python中，<strong>字符串类型中的每个字符采用的是两字节的Unicode编码</strong>，支持多语言。</p>
<h4 id="ord函数"><a href="#ord函数" class="headerlink" title="ord函数"></a>ord函数</h4><p>ord函数可以<strong>获取字符的十进制整数表示</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</div><div class="line"><span class="number">20013</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'文'</span>)</div><div class="line"><span class="number">25991</span></div></pre></td></tr></table></figure>
<p>注意只能传入<strong>单个字符</strong>。</p>
<h4 id="chr函数"><a href="#chr函数" class="headerlink" title="chr函数"></a>chr函数</h4><p>chr函数可以<strong>将十进制整数转换为Unicode编码下对应的字符</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">20013</span>)</div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</div><div class="line"><span class="string">'文'</span></div></pre></td></tr></table></figure>
<p>此外,如果知道了字符的十进制编码，可以将其转换为十六进制，然后<strong>使用<code>\u</code>转义得到对应的Unicode字符</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">20013</span>)</div><div class="line"><span class="string">'0x4e2d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d'</span></div><div class="line"><span class="string">'中'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">25991</span>)</div><div class="line"><span class="string">'0x6587'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u6587'</span></div><div class="line"><span class="string">'文'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span> <span class="comment"># 多个字符</span></div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<p>补充一下，Unicode编码是多语言的，不仅限于中文和英文，还可以使用多种语言的字符及符号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: ord(<span class="string">'한'</span>) <span class="comment"># 韩语</span></div><div class="line">Out[<span class="number">1</span>]: <span class="number">54620</span></div><div class="line">In [<span class="number">2</span>]: hex(<span class="number">54620</span>)</div><div class="line">Out[<span class="number">2</span>]: <span class="string">'0xd55c'</span></div><div class="line">In [<span class="number">3</span>]: <span class="string">'\ud55c'</span></div><div class="line">Out[<span class="number">3</span>]: <span class="string">'한'</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: ord(<span class="string">'に'</span>) <span class="comment"># 日语</span></div><div class="line">Out[<span class="number">4</span>]: <span class="number">12395</span></div><div class="line">In [<span class="number">5</span>]: hex(<span class="number">12395</span>)</div><div class="line">Out[<span class="number">5</span>]: <span class="string">'0x306b'</span></div><div class="line">In [<span class="number">6</span>]: <span class="string">'\u306b'</span></div><div class="line">Out[<span class="number">6</span>]: <span class="string">'に'</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: ord(<span class="string">'a'</span>) <span class="comment"># 英语</span></div><div class="line">Out[<span class="number">7</span>]: <span class="number">97</span></div><div class="line">In [<span class="number">8</span>]: hex(<span class="number">97</span>)</div><div class="line">Out[<span class="number">8</span>]: <span class="string">'0x61'</span></div><div class="line">In [<span class="number">9</span>]: <span class="string">'\u0061'</span></div><div class="line">Out[<span class="number">9</span>]: <span class="string">'a'</span></div><div class="line"></div><div class="line">In [<span class="number">10</span>]: ord(<span class="string">'1'</span>) <span class="comment"># 数字</span></div><div class="line">Out[<span class="number">10</span>]: <span class="number">49</span></div><div class="line">In [<span class="number">11</span>]: hex(<span class="number">49</span>)</div><div class="line">Out[<span class="number">11</span>]: <span class="string">'0x31'</span></div><div class="line">In [<span class="number">12</span>]: <span class="string">'\u0031'</span></div><div class="line">Out[<span class="number">12</span>]: <span class="string">'1'</span></div><div class="line"></div><div class="line">In [<span class="number">13</span>]: ord(<span class="string">','</span>) <span class="comment"># 符号</span></div><div class="line">Out[<span class="number">13</span>]: <span class="number">44</span></div><div class="line">In [<span class="number">14</span>]: hex(<span class="number">44</span>)</div><div class="line">Out[<span class="number">14</span>]: <span class="string">'0x2c'</span></div><div class="line">In [<span class="number">15</span>]: <span class="string">'\u002c'</span></div><div class="line">Out[<span class="number">15</span>]: <span class="string">','</span></div></pre></td></tr></table></figure>
<p>从以上代码可以看到，这里的Unicode编码中<strong>每个字符都是固定用两字节表示（一个字符用4位16进制数表示，每个16进制数需要4bit，所以一共是4*4 = 16bits = 2bytes）</strong>，<strong>和廖老师教程中所说的若干个字节不一致，是否真的有多于两字节的Unicode字符呢？有待考究。</strong></p>
<h4 id="bytes类型"><a href="#bytes类型" class="headerlink" title="bytes类型"></a>bytes类型</h4><p>因为Python程序执行时，字符串类型是用Unicode编码的，一个字符对应若干字节（<strong>若干字节还是固定两个字节呢？</strong>），要在网络中传输或存储到硬盘中就要把字符串变为bytes类型（<strong>因为传输和存储都是以字节为单位的，所以需要进行转换。又因为要节省资源，所以会使用别的编码方式如utf-8</strong>）。</p>
<p>Python显示bytes类型的数据会用b作前缀，要注意 <strong><code>b&#39;ABC&#39;</code></strong> 和 <strong><code>&#39;ABC&#39;</code></strong> 的差别，尽管内容一样，但前者的每个字符都只占1个字节，而后者在Python中以Unicode进行编码，每个字符占两个字节。也即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x41\x42\x43'</span>  <span class="comment"># bytes类型，每个英文字符占1个字节</span></div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u0041\u0042\u0043'</span> <span class="comment"># Unicode类型，每个英文字符占2个字节，前8bit用0填充</span></div><div class="line"><span class="string">'ABC'</span></div></pre></td></tr></table></figure>
<p>Unicode字符串可以通过 <strong><code>encode()</code></strong> 方法编码为指定的bytes，如ASCII编码，utf-8编码etc，bytes类型的数据如果字符不属于ASCII码的范围，就用 <strong><code>&#39;\x##</code></strong> 的格式表示。 相应地，如果读取字节流的数据，就要用 <strong><code>decode()</code></strong> 方法解码。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure>
<h4 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h4><p><strong>对字符串使用len函数会得到字符的数目</strong>，而<strong>对字节流使用len函数则会得到有多少字节</strong>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>) <span class="comment"># 字符串'中文'包含两个字符</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u4e2d\u6587'</span>) <span class="comment"># 用4个字节表示字符串'中文'</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 字符串'中文'编码为utf-u格式后，占6个字节</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 用6个字节表示字节流'中文'</span></div><div class="line"><span class="number">6</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>) <span class="comment"># 字符串'ABC'包含三个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\u0041\u0042\u0043'</span>) <span class="comment"># 用6个字节表示字符串'ABC'</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)) <span class="comment"># 字符串'ABC'编码为ASCII格式后，占3个字符</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\x41\x42\x43'</span>) <span class="comment"># 用3个字节表示字节流'ABC'</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>和C语言类似，Python中使用百分号 <code>％</code> 占位符实现格式化的功能。<code>％s</code>表示用字符串替换，<code>％d</code>，<code>％f</code>，<code>％x</code>分别表示用整数，浮点数和十六进制数替换。其中<code>％s</code>可以将任意数据类型转换为字符串。而<code>％d</code>和<code>％f</code>则可以指定整数和小数部分的位数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的格式化</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %d %f %x'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.200000 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %s可以转换任意数据类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s %s %s %s'</span> % (<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">1.2</span>,<span class="number">0x2</span>)</div><div class="line"><span class="string">'a 1 1.2 2'</span></div><div class="line"></div><div class="line"><span class="comment"># %d可以控制整数部分的位数，不足的位数默认以空格填充</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%4d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'   5'</span></div><div class="line"></div><div class="line"><span class="comment"># 除了用空格填充之外，也可以使用0填充不足的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%04d'</span> % <span class="number">5</span></div><div class="line"><span class="string">'0005'</span></div><div class="line"></div><div class="line"><span class="comment"># %f也可以控制整数和小数部分的位数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%f - %.2f - %2.2f - %02.2f'</span> % (<span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.2</span>)</div><div class="line"><span class="string">'1.200000 - 1.20 - 1.20 - 1.20'</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>只有一个占位符时，后面变量不需要用括号括起。</li>
<li>如果字符串本身包含<code>％</code>，则需要转义，用<code>％％</code>来表示百分号。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %'</span> % <span class="number">7</span> <span class="comment"># 没有转义百分号</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: incomplete format</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span> <span class="comment"># 转义了百分号</span></div><div class="line"><span class="string">'growth rate: 7 %'</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符集与编码的恩怨情仇]]></title>
      <url>http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87/</url>
      <content type="html"><![CDATA[<p>最近在整理Python学习笔记的时候，发现自己一直以来对Unicode的认识和廖雪峰老师在Python3教程中所说的有不一致的地方，抱着求知的态度，查找多方资料后总算是弄明白了，也就整理成了这一篇文章。</p>
<p>编码问题一直以来都是很多程序员的噩梦，有时候好不容易写好一个带着详细注释的代码文件，保存一下再打开就发现注释全都乱码了。自己工作的时候还好，摸索一下弄对编码就好了。但是如果是多人协作或者发布产品时，没有统一好编码就会造成很大的问题，特别是对于来自不同国家使用不同语言的工作人员/用户来说。因此，统一编码是非常重要的，也就有了Unicode的出现。</p>
<p>下文将通过以下顺序进行讲解：</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#编码的历史">编码的历史</a></li>
<li><a href="#标准、字符集与编码">标准、字符集与编码</a><ul>
<li><a href="#character-repertoire">Character repertoire</a></li>
<li><a href="#coded-character-set">Coded character set</a></li>
<li><a href="#character-encoding-form">Character encoding form</a></li>
<li><a href="#character-encoding-scheme">Character encoding scheme</a></li>
</ul>
</li>
<li><a href="#带bom和不带bom">带BOM和不带BOM</a></li>
<li><a href="#windows中的编码问题">Windows中的编码问题</a></li>
<li><a href="#python3中的编码问题">Python3中的编码问题</a></li>
<li><a href="#参考与感谢">参考与感谢</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="编码的历史"><a href="#编码的历史" class="headerlink" title="编码的历史"></a>编码的历史</h2><p>首先需要理解一下<strong>为什么要进行编码</strong>。我们知道，对计算机而言，一切信息都不过是01比特串，不同的01组合成不同的比特串从而可以表示不同的信息。但是，对人类来说，我们阅读写作所用的是自然语言，于是就存在着<strong>如何使用01比特串来表示自然语言</strong>这样一个问题。</p>
<p>在计算机中，8个比特（bit）组成1个字节（byte），可以表示256种不同状态。在最早的时候，计算机使用者用的都是英语，于是美国人就设计了<strong>ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）</strong>，它包含了大小写英文，数字，控制码以及其它一些符号。大写A编码为65，小写a编码为97。字符0编码为48。使用8个比特(也即1个字节)，可表示128个不同字符(最高位留出，用于校验)。这样计算机就能使用不同的字节来表示英文了，显示时GUI工具或者字体渲染器只需要根据字节来显示相应的字母就可以了。</p>
<p>后来随着计算机技术的发展，各个国家都开始使用计算机了，但并不是每个国家都使用英语呀。中华文化博大精深，光是常用汉字就有6000多个，显然处理中文时一个字节是不足够的，至少要用两个字节，并且不能与ASCII冲突，因此就有了中国自己制定的<strong>GB2312标准</strong>（每个字符两字节）。后来由于中文字实在太多了，然后还有一些少数民族使用的文字，于是又相继推出了GBK标准和GB18030标准。</p>
<p>日本和韩国也不例外，日本制定了<strong>Shift_JIS标准</strong>，韩国制定了<strong>Euc-kr标准</strong>。还有很多使用其他语言的国家/地区也纷纷制定了适合自己语言的编码标准。</p>
<p>但是，各个国家都用自己不同的标准和编码，在多语言的环境下就很容易产生冲突，产生乱码。国际标准组织ISO看不下去了，就制定了一套统一的标准：<strong>通用字符集（Universal Character Set，UCS）</strong>，后来发展为俗称的<strong>Unicode标准</strong>，将多种语言文字统一到一套标准中。</p>
<h2 id="标准、字符集与编码"><a href="#标准、字符集与编码" class="headerlink" title="标准、字符集与编码"></a>标准、字符集与编码</h2><p>在查找相关资料的过程中，我发现<strong>标准、字符集、编码这几个概念相当容易被混淆</strong>，甚至不少资深程序员也会说混。在廖雪峰老师的Python3教程中，他所说的Unicode指的是一种编码，而现在我们讨论Unicode的时候，一般是指Unicode字符集，它有多种编码，如UTF-8、UTF-16和UTF-32。那是不是廖雪峰老师所说的是错误的呢？<strong>XXX标准、XXX字符集、XXX编码到底有什么区别呢？</strong></p>
<p>首先呀，像前面一节说到的那样，根据需要会制定出不同的<strong>标准（standard）</strong>。有时候一套标准只涉及到字符集，就称为字符集标准。但是一套标准里面还可能涉及到实现该字符集的一种或多种编码以及其它一些细节。</p>
<p><strong>字符集（character set）</strong>是什么呢？更准确的说，应该称其为<strong>编码字符集coded character set (CCS)</strong>。它定义的是<strong>字符和code point的映射关系</strong>，code point通常是用十六进制表示的整数，比方说Unicode字符集中，使用4位十六进制数的code point <code>0061</code>（十进制的97） 来表示小写字母 <code>a</code>。字符集里的每一条标识包括code point，对应的字符以及一个明确的字符名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061</span><span class="string">'a'</span>; LATIN SMALL LETTER A</div><div class="line"><span class="number">0062</span><span class="string">'b'</span>; LATIN SMALL LETTER B</div><div class="line"><span class="number">0063</span><span class="string">'c'</span>; LATIN SMALL LETTER C</div><div class="line">...</div><div class="line"><span class="number">007</span>B<span class="string">'&#123;'</span>; LEFT CURLY BRACKET</div></pre></td></tr></table></figure>
<p>接下来再说说最难说清楚的<strong>编码、编码方式、编码方案、实现方式、字符编码（character encoding）</strong>，这几个术语经常都会混用，甚至在同一篇文献中的不同地方也常常出现不同的称谓，它们之间或许有一些细微的差别，但是由于中文文献中混用得太多，基本上都被认为是同一样东西了。</p>
<p>那<strong>为什么有时候很难分清标准、字符集、编码这几个概念呢？</strong></p>
<p>其实呀，对于 ASCII、GB2312、Big5、GBK、GB18030 之类的标准来说，基本上一个字符集只对应一种编码。比如 ASCII标准 本身就直接规定了 ASCII字符集 和 ASCII编码；而 GB2312标准 则是一套字符集标准，实际上用 EUC-CN 来编码。GBK 和 GB18030 等也类似。</p>
<p>又因为很多文献中，写作并不严谨，有时就会省略掉 “标准”、”字符集”、”编码”这样的后缀，只使用名称。在提及 ASCII 的时候，实际上指的既可以是 ASCII字符集 又可以是 ASCII编码，还可以是 ASCII标准 这样一个整体；提及 GB2312 时，指的则是 GB2312字符集 和 EUC-CN编码 组合起来的整体。于是呀，很多人受到这些遗留标准的影响，以为字符集和编码是同一回事儿，而无法正确理解字符集和编码的关系。</p>
<p>但是，<strong>对 Unicode标准 来说，字符集和编码是明确区分的</strong>。Wikipedia的Unicode词条是这样说的：</p>
<blockquote>
<p><strong>Unicode</strong> is a computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world’s writing systems. <strong>Developed in conjunction with the Universal Coded Character Set (UCS) standard</strong> and <strong>published as The Unicode Standard.</strong> …… The standard consists of a set of code charts for visual reference, an encoding method and set of standard character encodings, a set of reference data files, and a number of related items, such as character properties, rules for normalization, decomposition, collation, rendering, and bidirectional display order (for the correct display of text containing both right-to-left scripts, such as Arabic and Hebrew, and left-to-right scripts).</p>
</blockquote>
<p>那么这里又产生一个新问题了？<strong>UCS和Unicode的关系是怎样的呢？</strong></p>
<p>最开始的时候，UCS和Unicode是两个不同的标准，由不同的组织提出。Unicode是Unicode联盟进行整理和编码的。和Unicode联盟类似，ISO也做了类似的事情，创造了UCS字符集标准。后来双方意识到世界上并不需要两套通用字符集，于是就开始整合，到了Unicode2.0时，Unicode和UCS的编码（字符集）就基本一致了，所以<strong>粗略来说，可以认为Unicode和UCS是同一样东西，它们是共同发展的</strong>。</p>
<p>但是从细节上来说，UCS中除了字符集，还定义有<strong>UCS-2（曾被称为Unicode，但现在Unicode字符集的范围已经远远超出UCS-2所能表示的，所以UCS-2被废弃了）</strong>、UCS-4等等用于实现UCS字符集的编码；而Unicode标准不但能够使用UCS-2和UCS-4编码，还针对传输/存储定义了另外一些编码，如UTF-8、UTF-16（可以认为是UCS-2的扩展）和UTF-32（可以认为是UCS-4的子集）等等。综上所述，<strong>说 Unicode 是一种编码是带误导性并且不合时的。</strong></p>
<p>再贴一段Wikipedia上的原话：</p>
<blockquote>
<p>Unicode can be implemented by different character encodings. The most commonly used encodings are UTF-8, UTF-16 and the now-obsolete UCS-2.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>Unicode（字符集标准） 可以使用不同的字符编码进行实现。 最常用的编码（方式）有UTF-8，UTF-16以及现在已经废弃了的UCS-2。</p>
</blockquote>
<p>最后再总结一下几个概念吧：</p>
<h3 id="Character-repertoire"><a href="#Character-repertoire" class="headerlink" title="Character repertoire"></a>Character repertoire</h3><p>字符集，是一个系统所能支持的所有抽象字符（包含一种或多种语言以及使用的标点符号）的集合。它有可能是闭合的，比如ASCII标准的字符集，只包含西文字符和符号等等；也可能是开放的，比如Unicode标准的字符集，可以允许继续添加新的字符。</p>
<h3 id="Coded-character-set"><a href="#Coded-character-set" class="headerlink" title="Coded character set"></a>Coded character set</h3><p>编码字符集，是一个把字符映射为code point的函数，每个code point对应一个字符。比方说给定一个Character repertoire，拉丁字母中的大写字母A可以被表示为65这个code point。多个编码字符集可能使用同一个Character repertoire，但采用不同的映射方式。</p>
<h3 id="Character-encoding-form"><a href="#Character-encoding-form" class="headerlink" title="Character encoding form"></a>Character encoding form</h3><p>字符编码方式，是code point和一个/多个code unit之间的映射。比方说一个使用16 bit code unit来存储信息的系统，它的一个code unit最多能表示0~65535，对于code point小于等于65535的字符，一个code unit就能存储了，而code point大于65535的字符则需要使用多个code unit来存储。</p>
<h3 id="Character-encoding-scheme"><a href="#Character-encoding-scheme" class="headerlink" title="Character encoding scheme"></a>Character encoding scheme</h3><p>字符编码方案，是code unit和octets序列之间的映射。在传统的二进制数字概念中，1 byte（字节）=8 bit（位）。<strong>大多数因特网标准使用octet（八位组）这个术语而不是使用字节来表示8 bit</strong>。该术语起始于TCP/IP发展的早期，当时许多早期的工作是在诸如DEC－10这样的系统上进行的，然而这些系统的结构使用的字节(byte)长度是10位（bit）,因此出现了octet的单位，即准确定义 1 octet = 8 bit。字符编码方案包括UTF-8、UTF-16等等。</p>
<p>所以呀，从这里可以看出<strong>编码方式和编码方案还是有那么一些区别的</strong>，我们知道英文字母只需要8 bit就能存储了，如果都采用16 bit的code unit来存就会造成很大的浪费。正因为这样，所以又有了编码方案，在存储/传输的实现上进行改变，从而节省空间/带宽。但是混用得实在太多了，也就很难再分清了。</p>
<h2 id="带BOM和不带BOM"><a href="#带BOM和不带BOM" class="headerlink" title="带BOM和不带BOM"></a>带BOM和不带BOM</h2><p>先贴一段wikipedia的原文：</p>
<blockquote>
<p>The byte order mark (BOM) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), whose appearance as a magic number at the start of a text stream can signal several things to a program consuming the text:</p>
</blockquote>
<ul>
<li><blockquote>
<p>What byte order, or endianness, the text stream is stored in;</p>
</blockquote>
</li>
<li><blockquote>
<p>The fact that the text stream is Unicode, to a high level of confidence;</p>
</blockquote>
</li>
<li><blockquote>
<p>Which of several Unicode encodings that text stream is encoded as.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>BOM use is optional, and, if used, should appear at the start of the text stream.</p>
</blockquote>
<p>BOM其实就是用来标示Unicode纯文本字节流用的是哪一种编码，它设计出来不是用来支持HTML和XML的。要识别文本的编码，HTML可以使用charset属性，XML可以使用encoding属性，没必要使用BOM。使用BOM主要是微软的习惯，UNIX系统是不鸟BOM的。</p>
<p>有一个最主要的原因是，在UNIX系统中，所有脚本语言通用的首行 <code>#!</code> 标示依赖于shell解析，而很多shell出于兼容的考虑是不检测BOM的。因此在文本开头加入BOM时，shell会把它解释为某个普通字符，从而破坏了 <code>#!</code> 标示。另外还有一点就是，BOM本身违反了一个UNIX设计的常见原则，就是文档中存在的数据必须可见，而BOM不能作为可见字符被文本编辑器编辑。</p>
<p>注意，我们<strong>在使用文件编辑器保存文本文件时，应当保存为UTF-8 without BOM的格式</strong>，在UTF-8文件中放置 BOM 主要是微软的习惯。BOM是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。</p>
<h2 id="Windows中的编码问题"><a href="#Windows中的编码问题" class="headerlink" title="Windows中的编码问题"></a>Windows中的编码问题</h2><p>这一节所说的Windows中的编码，主要是指Windows自带的文本编辑器-记事本中的语境。</p>
<p>在记事本中：</p>
<ul>
<li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码[1]。</li>
<li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16[2]。</li>
<li>所谓的「UTF-8」指的是带 BOM 的 UTF-8[3]。</li>
</ul>
<p><strong>标注</strong></p>
<ul>
<li><p>[1] Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。</p>
</li>
<li><p>[2] 把带有 BOM 的小端序 UTF-16（即UTF-16LE）称作「Unicode」也是 Windows 的臭毛病。Windows 从 Windows 2000 开始就已经支持 surrogate pair 了，所以已经是 UTF-16 了，「UCS-2」这个说法已经不合适了。UCS-2 只能编码 BMP 范围内的字符，从 1996 年起就在 Unicode/ISO 标准中被 UTF-16 取代了（UTF-16 通过蛋疼的 surrogate pair 来编码超出 BMP 的字符）。都十多年了，求求大家别再误称了……</p>
</li>
<li><p>[3] 把带 BOM 的 UTF-8 称作「UTF-8」又是 Windows 的臭毛病。如果忽略 BOM，那么在 ASCII 范围内与 ASCII 一致。</p>
</li>
</ul>
<h2 id="Python3中的编码问题"><a href="#Python3中的编码问题" class="headerlink" title="Python3中的编码问题"></a>Python3中的编码问题</h2><p>廖雪峰老师说Python3中字符串使用Unicode编码，但正如我们前面所说的，现在说Unicode是一种编码是不合时的，准确来说，Python3中字符串用的是严格使用两个字节的UCS-2编码，即使是英文字母也使用两个字节。</p>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><p><strong>廖雪峰-Python3教程</strong></p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="external">字符串和编码</a></li>
</ul>
<p><strong>Python官方文档</strong></p>
<ul>
<li><a href="https://docs.python.org/3/c-api/unicode.html" target="_blank" rel="external">Unicode Objects and Codecs</a></li>
<li><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="external">Unicode HOWTO</a></li>
</ul>
<p><strong>知乎</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？</a></li>
<li><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">Unicode 和 UTF-8 有何区别？</a></li>
<li><a href="https://www.zhihu.com/question/20167122" target="_blank" rel="external">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a></li>
<li><a href="https://www.zhihu.com/question/19817672" target="_blank" rel="external">为什么不少网站使用 UTF-8 编码？</a></li>
</ul>
<p><strong>Wikipedia</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Wide_character" target="_blank" rel="external">Wide character</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode#Mapping_and_encodings" target="_blank" rel="external">Unicode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Byte_order_mark" target="_blank" rel="external">Byte order mark</a></li>
<li><a href="https://en.wikipedia.org/wiki/Character_encoding#Code_unit" target="_blank" rel="external">Character encoding</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="external">Universal Coded Character Set</a></li>
</ul>
<p>最后，特别感谢知乎用户<a href="https://www.zhihu.com/people/lianghai" target="_blank" rel="external">梁海</a>、<a href="https://www.zhihu.com/people/chen-fu-zhou" target="_blank" rel="external">陈甫鸼</a>和<a href="https://www.zhihu.com/people/yu-yang-31-64" target="_blank" rel="external">于洋</a>，他们的回答都对我构建这篇文章很有帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何处理Hexo和MathJax的兼容问题]]></title>
      <url>http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天写文章写得正高兴，码Latex公式的时候突然发现无法渲染，经过一番推敲和实践，最终解决了这个问题，在这篇博文中简单记录一下，方便其他遇到同样问题的朋友们也能顺利解决。<strong>不想看解决思路的朋友也可以<a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#小结">跳到文章末尾直接看解决方案（Jump to the end to see sulution）</a></strong>。</p>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>先重现一下这个问题。在写文章的时候，我码了一个相当简单的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$$</div></pre></td></tr></table></figure>
<p>渲染出来却变成了（红框内变为了斜体）：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer1.png" alt="before"></p>
<a id="more"></a>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>琢磨了一下，MathJax支持是开了的，这么简单的公式都渲染不出，肯定不是MathJax要背的锅。简单地测试了一下，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$R_&#123;m \times n&#125;$$</div></pre></td></tr></table></figure>
<p>这个公式是能work的，那到底是什么问题呢？回到前面的公式，细心观察一下，不难发现渲染之后<strong>下划线 <code>_</code> 被吞掉了</strong>，而<strong>两个下划线 <code>_</code> 之间的文本变为了斜体</strong>，这就很有意思了。</p>
<p>浏览一下网页源码，可以看到对应这一条公式的代码是：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/Before_Change_Markdown_Renderer2.png" alt="before"></p>
<p>原来下划线被渲染成了 <code>&lt;em&gt;</code>，在HTML里这个tag是用于将文本准换为斜体进行强调的。为什么会产生这样的错误呢？其实，在Markdown语法中 <em>两个下划线之间的文本会被转换为斜体</em>，所以<strong>这个错误是由Markdown渲染器引起的</strong>。Markdown本身没有支持Latex，在渲染时正则匹配到两条下划线就会把下划线替换成了 <code>&lt;em&gt;</code>，于是到了MathJax渲染公式时就彻底懵了。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>意识到这个问题的本质后，带着疑问，我先来到Next主题的<a href="https://github.com/iissnan/hexo-theme-next/" target="_blank" rel="external">Github主页</a>，在<a href="https://github.com/iissnan/hexo-theme-next/issues?utf8=%E2%9C%93&amp;q=mathjax" target="_blank" rel="external">issue</a>里面搜索MathJax。很可惜，没有找到直接的答案，但是思路清晰了一些。<strong>Next不背这个锅</strong>，我们要做的是<strong>更换Hexo使用的Markdown渲染器</strong>。</p>
<p>接下来我又到Hexo的<a href="https://github.com/hexojs/hexo/" target="_blank" rel="external">Github主页</a>搜索相关的解决方案，在<a href="https://github.com/hexojs/hexo/issues/524" target="_blank" rel="external">issue #524</a> 中，有人提到了<strong>可以使用 rawblock 来解决</strong>，可是每次要写公式都得在公式前后加上 rawblock 来声明实在太烦了，对于公式大户来说简直要崩溃（想想之后要写机器学习的相关文章，一大堆公式证明，已经想手动再见了）。</p>
<p>另一个提出的解决方案是<strong>更换pandoc渲染器</strong>，pandoc大法固然好，但要下载安装完pandoc然后再装hexo插件实在是太重量级了.. 我只是想轻松愉悦地写写博客呀。当然，感兴趣的朋友也不妨去<a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="external">hexo-renderer-pandoc主页</a>看看。</p>
<p>有没有更好的方法呢？我在<a href="https://segmentfault.com/q/1010000003987383/a-1020000003987577/revision" target="_blank" rel="external">segmentfault</a>查到另一位朋友写的解决方案，可以<strong>使用 hexo-renderer-markdown-it 进行渲染</strong>，似乎是个不错的思路，在hexo-renderer-markdown-it的<a href="https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started" target="_blank" rel="external">文档</a>中可以看到操作相当简单：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-markdown-it --save</code></li>
</ol>
<p>两行命令即可完成，先卸载Hexo自带的Markdown解析器 hexo-renderer-marked 再安装 hexo-renderer-markdown-it 就可以了。安装完以后，先 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态网页，然后 <code>hexo s</code> 查看，这回公式能正常显示了：</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/After_Change_Markdown_Renderer1.png" alt="after"></p>
<p>但是这是我又发现一个新的问题，使用 hexo-renderer-markdown-it 渲染之后，我原本为Markdown编写的<strong>TOC里的链接都失效了</strong>，而<strong>侧边栏的快速导航链接也都失效了</strong>。这怎么可以呢？文章写得短还好，鼠标滚轮滚一滚就好了。要是写得长那岂不就得浪费很多时间才能定位到自己想看的地方？这可不行！！！</p>
<p>继续查找更优的解决方案，Hexo有没有更好的Markdown渲染插件呢？有的，在<a href="https://hexo.io/plugins/" target="_blank" rel="external">Hexo主站的插件页</a>搜索关键字 Markdown，发现了 hexo-renderer-kramed 这个插件，打开它的<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">Github主页</a>，描述已经说得很清楚，作者fork了 hexo-renderer-marked 项目，并且只针对MathJax支持进行了改进，这正是我们需要的！！卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），然后安装 hexo-renderer-kramed：</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>这下，不仅能正常使用TOC，也能完美地支持MathJax渲染了。至此，问题得到了解决。</p>
<p>P.S. 其实，这个问题就是因为Markdown渲染和MathJax渲染冲突造成的，除了换别的渲染器，<strong>直接修改渲染用的正则表达式</strong>也是一种解决思路，但是这个思路有一定风险，如果引起了别的bug而没有及时发现，自己又没有做好备份和记录，就需要浪费很多额外的时间来定位问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单来说，要让你的Hexo支持MathJax渲染公式，你只需要使用两条命令：<br>To fully support MathJax in your Hexo blog, you can simply use the following commands:</p>
<ol>
<li><code>npm uninstall hexo-renderer-marked --save</code></li>
<li><code>npm install hexo-renderer-kramed --save</code></li>
</ol>
<p>第一条命令用于卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），它是hexo自带的Markdown渲染引擎。<br>The first command uninstall Hexo’s default Markdown renderer.</p>
<p>第二条命令用于安装 hexo-renderer-kramed 插件，这个渲染插件针对MathJax支持进行了改进。安装完成后，重新生成博客就会惊喜地发现你的公式已经能够正常显示了。<br>The second command install new Markdown renderer which can support MathJax fully. After installation, you should regenerate your blog to see the changes.</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>作为一名编程人员，不屈服于bug，不妥协于简陋的solution是很重要的。除此之外，也要善于定位问题和解决问题，能够弄清楚出问题的地方，并且利用丰富的网络资源来解决问题。</p>
<p>最后，感谢开源和分享。</p>
<p>最后的最后，再码一条写在SVM笔记里的长公式检验一下吧：</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad  i=1,2,...,m\qquad(9)</script><p>完美~ The end.</p>
<hr>
<p><strong>备注</strong></p>
<p>补充一下评论中L同学的问题，关于行内代码，确实还存在一点问题，之后有时间会再研究一下。</p>
<ul>
<li>首先，我们希望行内公式可以用两个 <code>$</code> 符标识；</li>
<li>而当我们使用的行内代码中出现两个 <code>$</code> 符时，它们之间的内容不应被转义为Latex公式，而是应该按原来的内容展示；</li>
<li>同理，在代码块中出现两个 <code>$</code> 符时，我们也不希望它们之间的内容不应被转义为Latex公式。</li>
</ul>
<p><strong>行内公式</strong>： $R<em>{m \times n} = U</em>{m \times m} S<em>{m \times n} V</em>{n \times n}’$</p>
<p><strong>包含两个 $ 的行内代码</strong>： <script type="math/tex">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'</script></p>
<p><strong>行间公式</strong>：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'</script><p><strong>包含两个 $ 的代码块</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$R_&#123;m \times n&#125; = U_&#123;m \times m&#125; S_&#123;m \times n&#125; V_&#123;n \times n&#125;&apos;$</div></pre></td></tr></table></figure>
<p>这里可以看到行内公式和行内代码的渲染确实有问题，这是因为kramed对行内公式的实现就是基于行内代码来做的，也就是说，对于kramed而言，<strong>出现 ` 符以后的两个 <code>$</code> 符之间的部分才会被kramed认为是行内公式（注意，即使没有用两个 ` 符括起来也会被匹配成行内公式，相当容易出bug）</strong>，要解决这个问题需要修改kramed的渲染机制。而在代码块中这种情况是没问题的，因为kramed里面对行内公式和行间公式的实现机制不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用推荐算法]]></title>
      <url>http://2wildkids.com/2016/10/04/%E5%B8%B8%E7%94%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这篇<a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247483811&amp;idx=1&amp;sn=fc3ee4ddfc4a8d6014a4cd90cdb5983c&amp;scene=4#wechat_redirect" target="_blank" rel="external">文章</a>首发在【阿里技术】这个微信公众号，内容上主要围绕电商中用到的一些推荐算法，参考了 Xavier Amatriain 在CMU的 Machine Learning 暑期学校上的讲授的内容。不仅有提到一些基础的推荐算法，也讲了一些推荐系统领域比较新的研究方向，个人认为是一篇不错的概括性文章，摘录在博客里，加入一点自己的理解。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC -->
<ul>
<li><a href="#推荐系统简介">推荐系统简介</a></li>
<li><a href="#传统的推荐算法">传统的推荐算法</a><ul>
<li><a href="#非个性化推荐：热度排行（popularity）">非个性化推荐：热度排行（Popularity）</a></li>
<li><a href="#协同过滤（collaborative-filtering）">协同过滤（Collaborative Filtering）</a></li>
<li><a href="#基于内容知识的推荐（content-basedknowledge-based）">基于内容/知识的推荐（Content-based/Knowledge-based）</a></li>
<li><a href="#混合方法（hybird-approaches）">混合方法（Hybird Approaches）</a></li>
</ul>
</li>
<li><a href="#推荐算法的最新研究">推荐算法的最新研究</a><ul>
<li><a href="#学习排序（learning-to-rank）">学习排序（Learning to Rank）</a></li>
<li><a href="#页面整体优化（page-optimization）">页面整体优化（Page Optimization）</a></li>
<li><a href="#情景推荐：张量分解分解机（factoriztion-machine）">情景推荐：张量分解/分解机（Factoriztion Machine）</a></li>
<li><a href="#深度学习（deep-learning）">深度学习（Deep Learning）</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- /MarkdownTOC -->
<a id="more"></a>
<h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image2.jpeg" alt="g2"></p>
<p>推荐系统本身就是为了解决信息过载这个问题而出现的，在互联网出现以后，人们在生活中所能获取到的消息呈爆炸性增长。从衣食住行再到其他一些更高端的需求，我们都有非常多的选择，但是要怎么在较短的时间内从这么多的选择里找到自己最感兴趣的那个呢？推荐系统解决的就是这样一个问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image3.jpeg" alt="g3"></p>
<p>事实上，<strong>解决信息过载的问题并不是只有推荐系统这一个手段</strong>。PC时代早期出现的门户网站是一种手段，帮助上网的人快速找到想要浏览的网站。而搜索引擎也是一种很好的办法，通过关键字来筛选出用户想要看的网页。但以上两种途径展示的内容对任意两个上网用户来说都是相同的。由于每个人的喜好总会有一部分和别人重叠，而一部分比较特殊，为了展示的内容能尽可能符合大多数人的期望，导航/搜索引擎只能给出重叠最多的部分，也即最流行的网站/网页，没有办法做到根据不同用户的喜好提供不同结果。推荐系统则致力于解决这一难点，实现千人千面的效果。</p>
<p>P.S. 事实上，目前在搜索引擎这个研究领域，已经有根据用户搜索习惯和搜索历史进行个性化结果展示的研究了，可以说是吸取了推荐系统的精髓进行改进的结果吧。随着计算机处理数据的能力上升，个性化将是未来的必然趋势。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image4.jpeg" alt="g4"></p>
<p>Netflix举办的百万美元竞赛绝对是推荐系统发展史上一个重要的标志，可以说从那以后，推荐系统的研究才开始真正地被重视，随后就是百花齐放，越来越多的算法和推荐架构被提出来了。</p>
<p>特别Mark一下<strong>推荐系统的未来——基于上下文的推荐</strong>，这个确实是很值得思考的。尽管目前关注推荐系统的研究已经不少了，但绝大部分都是使用协同过滤技术，或者把推荐视作一个二分类问题来解决的。有一个很明显的缺点就是它们都需要大量的标记数据才能实现准确的预测。还有一个问题就是，这里说的推荐并没有针对用户实际所处的环境来给出结果，只是从用户的历史记录和习惯来推测，给出他可能喜欢的其它商品，而<strong>没有关注用户是否真的有需求</strong>。<strong>怎么把我们从大量历史数据中学习到的知识应用到用户所处的具体场景中？</strong>这是一个等待研究的相当有价值的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image5.jpeg" alt="g5"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image6.jpeg" alt="g6"></p>
<p>这些指标都蛮有意思的，但是并不是都能通过离线测试来得出，比方说用户满意度、惊喜性等等，都是一些比较主观的东西，在这种情况下，怎么能够提高这些指标呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image7.jpeg" alt="g7"></p>
<p>这里列了几个比较传统的因素：相似的人越喜欢一件物品，那么用户就越有可能也喜欢它；用户对相似的物品越喜爱，那么也越有可能喜欢这一件物品；对这件物品的评论中赞赏的话越多，则用户也越有可能对这件物品感兴趣；用户和这件物品的历史交互行为越多，也意味着用户对这件物品越感兴趣…</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image8.jpeg" alt="g8"></p>
<p>虽然说我们做研究主要是针对推荐的算法，但在工业界里，一个真正的推荐产品，必须要有良好的用户界面，准确的产品定位，否则从一开始就输了，连用户数据都获取不到，自然也就没有所谓个性化的后话了。特别地，花在处理数据上的时间应该是最多的，因为从真实场景中收集到的数据往往都有很大的噪音，如果不经过处理就放进算法跑的话，算法再好也难以获得好的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image9.jpeg" alt="g9"></p>
<h2 id="传统的推荐算法"><a href="#传统的推荐算法" class="headerlink" title="传统的推荐算法"></a>传统的推荐算法</h2><h3 id="非个性化推荐：热度排行（Popularity）"><a href="#非个性化推荐：热度排行（Popularity）" class="headerlink" title="非个性化推荐：热度排行（Popularity）"></a>非个性化推荐：热度排行（Popularity）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image10.jpeg" alt="g10"></p>
<p>其实在没有电商的时候，传统的线下店铺就是采用热度排行的方式来增加销量的，因为能展示给客户的商品有限，所以只能选最热门的商品放在店铺里。</p>
<p>虽然这种做法可以避免新用户的冷启动窘境，因为我们不需要知道新用户是怎样的，只要知道大的趋势就可以了。但这样做对新的商品来说显然是致命的，因为热门的商品被展示得越多就越热门，长期占据热度榜，而新商品得不到被展示的机会，就只能烂在仓库里了。这个问题也被称为<strong>马太效应（The Matthew Effect）</strong>。</p>
<p>比较有意思的是这里指出除了单纯地考虑热度，<strong>在基于热度排行时还可以综合考虑一些其它因素</strong>。事实上，即使是如此强调个性化的今天，热度依然是影响用户做出购买决定的一个很重要的因素，所以在构建推荐系统时也要充分考虑到这一点。</p>
<h3 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h3><h4 id="Memory-based-方法"><a href="#Memory-based-方法" class="headerlink" title="Memory-based 方法"></a>Memory-based 方法</h4><p>Memory-based 方法又可以称为 <strong>neighborhood-based方法</strong>。可以简单分为User-based CF和Item-based CF两种思路。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image11.jpeg" alt="g11"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image12.jpeg" alt="g12"></p>
<p>注意一下Step3过滤这个步骤，比方说用户已经买过某一本书，如果再推荐他重复购买是不合理的。但是，对于一些可能会周期性购买的物品（如抽纸、沐浴露etc），我们要怎么处理呢？</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image13.jpeg" alt="g13"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image14.jpeg" alt="g14"></p>
<p>可以说各有各好处吧，Item-based更流行除了准确性好之外，物品的变动相对用户较少也是一个很大的原因，这能够减少很多计算花费。但是相对地，Item-based可能没有办法很好地承担<strong>开拓用户的眼界</strong>这个功能，是不是真的这样呢？值得思考。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image15.jpeg" alt="g15"></p>
<p>这里提到的缺点是需要注意的，但<strong>并不是说协同过滤就必定有这些缺点</strong>，我们可以针对这些缺点对协同过滤进行改良。这里记录一下一些简单的思路：</p>
<ul>
<li><p>冷启动问题怎么解决呢？是否可以引入一些领域知识？或者引入额外的数据来源（社交、地点、时间etc）呢？如果引入了，又该怎么使用呢？</p>
</li>
<li><p>过去的行为真的决定现在吗？过去的行为有哪些特征是可以视为用户的特征的呢？有哪些特征可能只是干扰因素呢？</p>
</li>
<li><p>怎么才能引入小众偏好，让推荐系统更强调个性化呢？</p>
</li>
</ul>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image16.jpeg" alt="g16"></p>
<p>LSH是一个相当有意思的减少计算量的方法。协同过滤的一个最基本步骤就是计算相似性，而无论从用户的角度还是从物品的角度来看，维度都相当高，计算花费很大。而使用LSH进行映射后，既能保持相似关系不会发生太大的变化，又能降低维度，确实是一种很好的解决方案。不过<strong>要特别注意哈希函数的选择</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image17.jpeg" alt="g17"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image18.jpeg" alt="g18"></p>
<h4 id="Model-based方法"><a href="#Model-based方法" class="headerlink" title="Model-based方法"></a>Model-based方法</h4><p>基于模型的方法，用到的技术就比较多涉及到机器学习领域了。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image19.jpeg" alt="g19"></p>
<h5 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image20.jpeg" alt="g20"></p>
<p>关联规则挖掘其实跟买东西的场景是非常搭的，有兴趣的朋友不妨查查 “啤酒与尿布” 这个经典案例。</p>
<p>值得注意的是：我们<strong>从结果反推出的 “现象” 并不一定是事实</strong>，这其中有可能存在巧合的因素，所以我们一定要慎重地对待。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image21.jpeg" alt="g21"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image22.jpeg" alt="g22"></p>
<p>Mark一下这里产生悖论的原因：<strong>数据的不同分组之间基数差异很大</strong>，导致合并时产生了偏差。用上面的例子来说就是对顾客分组是，在职人员的数量要远多于大学生的数量，在把这两个分组合并为顾客来考虑时就会产生偏差。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image23.jpeg" alt="g23"></p>
<h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image24.jpeg" alt="g24"></p>
<p>事实上，我们并不一定要在同一个簇里面找推荐物品的候选集，完全可以基于簇之间来使用KNN，把最近邻的簇对应的物品集作为候选，这样做就有一定概率引入一些额外的物品，给用户带来惊喜了。当然，如何平衡好这一点和推荐的准确性是需要研究的。</p>
<h5 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image25.jpeg" alt="g25"></p>
<p>比方说把推荐看作一个二分类问题，预测用户是否购买/点击；把推荐看作一个回归问题，预测用户对推荐物品的评分。这样来看的话，很多有监督学习的机器学习技术都能被用上了。但是，如何获得大量独立同分布的训练数据会是一个很大的问题。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image26.jpeg" alt="g26"></p>
<ul>
<li>如何应对评分矩阵的稀疏性？ —— 现实问题，用户接触到的商品仅占非常小的一部分，会进行反馈的就更少了</li>
<li>如何降低大规模矩阵计算的时间开销？ —— 决定能否满足实时性的需求</li>
</ul>
<p>图片中的两条式子可能有些模糊，它们分别是是：</p>
<script type="math/tex; mode=display">R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}' \qquad(1)</script><p>和</p>
<script type="math/tex; mode=display">R_{m \times n} \approx U_{m \times k} S_{k \times k} V_{k \times n}' \qquad(2)</script><p>式（1）是标准的SVD矩阵分解，式（2）则是<strong>利用SVD技术进行低阶近似</strong>，也称为<strong>截断SVD（Truncated SVD）</strong>，它只取最大的k个奇异值，而k要远小于原矩阵的行数m和列数n，因此能够大大地降低计算开销。由于篇幅原因，这里就不科普SVD相关的知识了，详细内容可以check一下<a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank" rel="external">维基百科里对SVD的描述</a>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image27.jpeg" alt="g27"></p>
<p>Funk提出的这种矩阵分解算法在很大程度上弥补了标准SVD的不足，它不需要关注缺失值，而且计算复杂度也降低了很多。这种矩阵分解方法后来被Netflix Prize的冠军Koren称为<strong>Latent Factor Model（简称LFM）</strong>，也即后来大名鼎鼎的<strong>隐语义模型</strong>。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image28.jpeg" alt="g28"></p>
<p>加入偏置项是一种很直觉的想法，举一个简单的例子，对商品要求较高的用户通常会给出较低的评分，所以在满意程度同等时，他给出的评分可能比其他用户都要低。如果我们不排除这个影响的话，他的评分就会错误地拉低了商品的评价。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image29.jpeg" alt="g29"></p>
<p>更进一步地，我们还可以考虑用户的历史行为对评分的影响。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image30.jpeg" alt="g30"></p>
<p>向量化可以理解为对原事物表现形式的改变，不仅仅用于推荐系统领域，也是很多其他研究领域的基础。比方说自然语言处理，要理解对话，就先就要把对话的句子进行向量化，将句子分解为不同的单词，每个单词对应一个维度（最近Google翻译已经改进为以句子为单元了，使得翻译更加准确，不过由于我没有进行过自然语言处理相关的研究，所以不太清楚具体的情况）。</p>
<h5 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image31.jpeg" alt="g31"></p>
<p>Boltzmann机是全连接的一个网络，参数相当多，即使去除同同一层内的连接，变为RBM，参数依然很多。参数越多，自然拟合的能力就越强，所以RBM可以说是浅层学习（相对于深度学习的一个概念，毕竟RBM就只有两层神经元）中非常强大的一个模型。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image32.jpeg" alt="g32"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image33.jpeg" alt="g33"></p>
<p>Mark一下，<strong>一个用户一个RBM</strong>，也即为每个用户都训练一个RBM模型，这样开销固然很大，但私以为这样做要比协同过滤更加符合<strong>个性化</strong>的需求。除了开销大之外，这种方法还需要海量的训练数据，否则无法得到可以接受的结果。</p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image34.jpeg" alt="g34"></p>
<p>自从深度学习火了之后，越来越多的研究者开始对其进行研究。在推荐系统领域也不例外，虽然RBM并不算“深”，但是可以帮助我们理解深度学习技术是如何应用到推荐系统领域的。我个人还不是太过了解深度学习，上面的PPT也不是讲得讲得很清楚（在推荐系统问题中应用的RBM是改良过的）。感兴趣的朋友不妨阅读一下腾讯数字音乐部智能推荐组编写的文章——<strong><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=417547354&amp;idx=1&amp;sn=1cda80702cff4f9d0f739f75d30eb773" target="_blank" rel="external">解密深度学习在智能推荐系统的实践与应用</a></strong>。</p>
<h5 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h5><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image35.jpeg" alt="g35"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image36.jpeg" alt="g36"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image37.jpeg" alt="g37"></p>
<p>Mark一下：<strong>图模型可以发现协同过滤发现不来的弱相似性，给推荐带来一定的惊喜。</strong></p>
<h3 id="基于内容-知识的推荐（Content-based-Knowledge-based）"><a href="#基于内容-知识的推荐（Content-based-Knowledge-based）" class="headerlink" title="基于内容/知识的推荐（Content-based/Knowledge-based）"></a>基于内容/知识的推荐（Content-based/Knowledge-based）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image38.jpeg" alt="g38"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image39.jpeg" alt="g39"></p>
<h3 id="混合方法（Hybird-Approaches）"><a href="#混合方法（Hybird-Approaches）" class="headerlink" title="混合方法（Hybird Approaches）"></a>混合方法（Hybird Approaches）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image40.jpeg" alt="g40"></p>
<p>所谓混合方法，指的是将多个算法集成在一起来完成任务，更详细的讲解可以查询集成学习相关的内容了解。</p>
<h2 id="推荐算法的最新研究"><a href="#推荐算法的最新研究" class="headerlink" title="推荐算法的最新研究"></a>推荐算法的最新研究</h2><h3 id="学习排序（Learning-to-Rank）"><a href="#学习排序（Learning-to-Rank）" class="headerlink" title="学习排序（Learning to Rank）"></a>学习排序（Learning to Rank）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image41.jpeg" alt="g41"></p>
<p>对NDCG和MRR这两种排序评价准则感兴趣的朋友可以浏览<a href="http://www.cnblogs.com/startover/archive/2013/06/18/3141616.html" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="页面整体优化（Page-Optimization）"><a href="#页面整体优化（Page-Optimization）" class="headerlink" title="页面整体优化（Page Optimization）"></a>页面整体优化（Page Optimization）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image42.jpeg" alt="g42"></p>
<h3 id="情景推荐：张量分解-分解机（Factoriztion-Machine）"><a href="#情景推荐：张量分解-分解机（Factoriztion-Machine）" class="headerlink" title="情景推荐：张量分解/分解机（Factoriztion Machine）"></a>情景推荐：张量分解/分解机（Factoriztion Machine）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image43.jpeg" alt="g43"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image44.jpeg" alt="g44"></p>
<h3 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h3><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image45.jpeg" alt="g45"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image46.jpeg" alt="g46"></p>
<p>Mark一下：<strong>仅仅利用行为数据的RNN可能效果有限，可以结合更多数据来源。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image47.jpeg" alt="g47"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image48.jpeg" alt="g48"></p>
<p><img src="http://oe0e8k1nf.bkt.clouddn.com/RecAlgorithm/image49.jpeg" alt="g49"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction]]></title>
      <url>http://2wildkids.com/2016/10/03/Introduction/</url>
      <content type="html"><![CDATA[<p>自从知道了Github Pages和Hexo这对绝佳搭配之后，一直心心念念地想做一个自己的独立博客。虽然从阅读量来说，肯定还是在CSDN、简书或者知乎专栏发布会有更多被阅读的机会，但总感觉或多或少地有些阻碍，不能随心所欲地写作。之前倒是一直把Github当作一个博客，天天把markdown写的笔记contribute到仓库里面，不过鉴于Github支持的是源生的markdown，而markdown本身是不支持latex公式的，所以多少有点遗憾。Anyway，终于用Github Pages+Hexo搭建了这个博客，有MathJax和七牛图床的支持，终于可以随心所欲地写作了~</p>
<p>鉴于大四一直在忙自己的项目和论文，所以少有时间做些真正原创的技术分享，前期主要打算在这个博客做一些阅读笔记。暑假一直在读周志华博士写的《机器学习》一书，把本科生课程部分（书的前半部分）的笔记基本都整理好了，放在了Github上面，但这显然是不够的，想做研究当然还是得往更深的技术里钻，所以书的后半部分还要继续细读精读。另一方面，这本书比较新，所以习题部分目前网上还没有比较好的解答。书中的公式有些比较复杂，对工程人员来说理解可能有不少困难，所以我也希望可以用课余的时间认真地把这本书的习题过一遍，如何对公式进行向量化，如何融入到实际的项目中，用代码进行实现。希望可以分享出来，为开源做点贡献，为其他书友带来一点帮助，自己应该也会有不少的收获。之后会逐渐把笔记和解答迁移到这个博客里，需要花费的时间也比较多，不过贵在坚持。</p>
<a id="more"></a>
<p>因为个人研究方向主攻数据挖掘的推荐系统领域，所以阅读的书籍和文章也比较多涉及这个方面。而中文书籍中，个人认为推荐系统领域最好的一本入门书籍是项亮的《推荐系统实践》，之后也会在这个博客中更新阅读这本书的笔记。另外也会搬运一些机器学习和数据挖掘比较好的文章到这个博客中，加入一些自己的理解，算是记录自己成长的轨迹吧，虽然不是技术原创，但在阅读和学习的过程中，记录下自己的见解，以后再看也会有很大的帮助。</p>
<p>另外，我个人也非常喜欢Python这门编程语言，在数据科学方面的研究中，Python是一个不可多得的利器，所以要是遇到好的Python相关的文章，也会收录到这个博客中。再有就是linux和Hadoop、Spark方面的一些笔记了，要做大数据总是免不了碰到这些东西。虽然工具年年变，说不定以后Spark就不像现在这么火了，但是好的工具总是有研究价值的，好好学的话还是会有不错的收获。</p>
<p>最后，也是一点小寄望吧，希望以后可以能逐渐有多一些技术原创，多一些项目分享，目前就先脚踏实地地积累知识吧。</p>
<p>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://2wildkids.com/2016/09/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Test-MathJAX"><a href="#Test-MathJAX" class="headerlink" title="Test MathJAX"></a>Test MathJAX</h3><script type="math/tex; mode=display">a = \frac{1}{5}</script><p>something is equals to $\alpha 5$.</p>
]]></content>
    </entry>
    
  
  
</search>
